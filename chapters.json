[{
  "name": "Working with Java Data Types",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "Which of the following are not valid variable names? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "_"
      }, {
        "code": "B",
        "value": "_blue"
      }, {
        "code": "C",
        "value": "2blue"
      }, {
        "code": "D",
        "value": "blue$"
      }, {
        "code": "E",
        "value": "Blue"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "1. A,C. An identifier name must begin with a letter, dollar sign ($), or underscore (_). Numbers are permitted only for subsequent characters. Therefore, option C is not a valid variable name. Additionally, an identifier may not be a single underscore, making option A an invalid variable name."
      }
    },
    "2": {
      "nbr": 2,
      "value": "What is the value of tip after executing the following code snippet?\nint meal = 5;\nint tip = 2;\nvar total = meal + (meal>6 ? tip++ : tip--);",
      "responses": [{
        "code": "A",
        "value": "1"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "3"
      }, {
        "code": "D",
        "value": "7"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "2. A. In a ternary expression, only one of the two right‐most expressions is evaluated. Since meal>6 is false, tip‐‐ is evaluated, and tip++ is skipped. The result is that tip is changed from 2 to 1, making option A the correct answer. The value of total is 7, since the post‐decrement operator was used on tip, although you did not need to know this to solve the question."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Which is equivalent to var q = 4.0f;?",
      "responses": [{
        "code": "A",
        "value": "float q = 4.0f;"
      }, {
        "code": "B",
        "value": "Float q = 4.0f;"
      }, {
        "code": "C",
        "value": "double q = 4.0f;"
      }, {
        "code": "D",
        "value": "Double q = 4.0f;"
      }, {
        "code": "E",
        "value": "Object q = 4.0f;"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "3. A. The f in 4.0f means the type is a float, making option A correct. Local variable type inference chooses an exact match rather than using autoboxing to choose Float."
      }
    },
    "4": {
      "nbr": 4,
      "value": "What is the output of the following?\n12: var b = \"12\";\n13: b += \"3\";\n14: b.reverse();\n15: System.out.println(b.toString());",
      "responses": [{
        "code": "A",
        "value": "12"
      }, {
        "code": "B",
        "value": "123"
      }, {
        "code": "C",
        "value": "321"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "4. D. Trick question. There is no reverse method on the String class. There is one on the StringBuilder class. Therefore, the code does not compile, and option D is correct."
      }
    },
    "5": {
      "nbr": 5,
      "value": "What is the output of the following?\n5: var line = new StringBuilder(\"-\");\n6: var anotherLine = line.append(\"-\");\n7: System.out.print(line == anotherLine);\n8: System.out.print(\" \");\n9: System.out.print(line.length());",
      "responses": [{
        "code": "A",
        "value": "false 1"
      }, {
        "code": "B",
        "value": "false 2"
      }, {
        "code": "C",
        "value": "true 1"
      }, {
        "code": "D",
        "value": "true 2"
      }, {
        "code": "E",
        "value": "It does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "5. D. A StringBuilder is mutable, so the length is 2 after line 6 completes. The StringBuilder methods return a reference to the same object, so you can chain method calls. Therefore, line and anotherLine refer to the same object. This means that line 7 prints true. Then on line 9, both references point to the same object of length 2, and option D is correct."
      }
    },
    "6": {
      "nbr": 6,
      "value": "Given the following Venn diagram and the boolean variables, apples, oranges, and bananas, which expression most closely represents the filledin region of the diagram?",
      "responses": [{
        "code": "A",
        "value": "apples && oranges && !bananas"
      }, {
        "code": "B",
        "value": "orange || (oranges && !bananas)"
      }, {
        "code": "C",
        "value": "(apples || bananas) && oranges"
      }, {
        "code": "D",
        "value": "oranges && apples"
      }, {
        "code": "E",
        "value": "(apples || oranges) && !bananas"
      }, {
        "code": "F",
        "value": "apples ^ oranges"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "6. E. The diagram represents all cases where apples or oranges is true, but bananas is false, making option E correct. Option A is close but is correct only if the top overlapping portion of apples and oranges was filled in. For fun, you should try to draw the diagrams that would represent the other answers."
      }
    },
    "7": {
      "nbr": 7,
      "value": "What is the output of the following?\n5: var line = new String(\"-\");\n6: var anotherLine = line.concat(\"-\");\n7: System.out.print(line == anotherLine);\n8: System.out.print(\" \");\n9: System.out.print(line.length());",
      "responses": [{
        "code": "A",
        "value": "false 1"
      }, {
        "code": "B",
        "value": "false 2"
      }, {
        "code": "C",
        "value": "true 1"
      }, {
        "code": "D",
        "value": "true 2"
      }, {
        "code": "E",
        "value": "Does not compile"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "7. A. A String is immutable, so a different object is returned on line 6. The object anotherLine points to is of length 2 after line 6 completes. However, the original line reference still points to an object of length 1. Therefore, option A is correct."
      }
    },
    "8": {
      "nbr": 8,
      "value": "Which can fill in the blank? (Choose two.)\npublic void math() {\n_____ pi = 3.14;\n}",
      "responses": [{
        "code": "A",
        "value": "byte"
      }, {
        "code": "B",
        "value": "double"
      }, {
        "code": "C",
        "value": "float"
      }, {
        "code": "D",
        "value": "short"
      }, {
        "code": "E",
        "value": "var"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "8. B,E. Options A and D are incorrect because byte and short do not store values with decimal points. Option C is tempting. However, 3.14 is automatically a double. It requires casting to float or writing 3.14f to be assigned to a float. Therefore, option B is correct. Additionally, option E is correct because local variable type inference is able to automatically determine the type is double."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Fill in the blanks: The operators !=, _______, _______, _______, and ++\nare listed in the same or increasing level of operator precedence. (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "==, *, !"
      }, {
        "code": "B",
        "value": "/, %, *"
      }, {
        "code": "C",
        "value": "*, ‐‐, /"
      }, {
        "code": "D",
        "value": "!, *, %"
      }, {
        "code": "E",
        "value": "+=, &&, *"
      }, {
        "code": "F",
        "value": "*, <, /"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B"
        ],
        "explanation": "9. A,B. Option A is correct and lists the operators in the same or increasing\nlevel of operator precedence. In option B, the three operators actually have\nthe same operator precedence, so it is correct. Option C is incorrect, as\ndivision (/) has a lower precedence than the decrement operator (‐‐).\nOption D is incorrect because the logical complement operator (!) has a\nhigher order of precedence than the other two operators. Option E lists the\noperators in the correct order, but they don't fit within not equals (!=) and\nthe increment operator (++) as listed in the question. In particular,\ncompound addition operator (+=) and short‐circuit logical operator (&&)\nhave a lower precedence than the not equals operator (!=). Finally, option F\nis incorrect because the relational operator (<) does not fit between\nmultiplication operator (*) and the division operator (/) in order of\nprecedence."
      }
    },
    "10": {
      "nbr": 10,
      "value": "How many of these compile?\n18: Comparator<String> c1 = (j, k) -> 0;\n19: Comparator<String> c2 = (String j, String k) -> 0;\n20: Comparator<String> c3 = (var j, String k) -> 0;\n21: Comparator<String> c4 = (var j, k) -> 0;\n22: Comparator<String> c5 = (var j, var k) -> 0;",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }, {
        "code": "F",
        "value": "5"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "10. D. Line 18 compiles because neither type is specified for the lambda\nparameters. Lines 19 and 22 compile because the lambda parameters use a\ntype or var consistently. These are the three lines that compile, making\noption D correct. Lines 20 and 21 do not compile because var must be used\nfor all parameters in a lambda if it is used for any."
      }
    },
    "11": {
      "nbr": 11,
      "value": "The author of this method forgot to include the data type. Which of the\nfollowing reference types can best fill in the blank to complete this method?\npublic static void secret(___________ mystery) {\nchar ch = mystery.charAt(3);\nmystery = mystery.insert(1, \"more\");\nint num = mystery.length();\n}",
      "responses": [{
        "code": "A",
        "value": "String"
      }, {
        "code": "B",
        "value": "StringBuilder"
      }, {
        "code": "C",
        "value": "Both"
      }, {
        "code": "D",
        "value": "Neither"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "11. B. The charAt() and length() methods are declared on both String and\nStringBuilder.However, the insert() method is declared only on a\nStringBuilder and not a String. Therefore, option B is correct."
      }
    },
    "12": {
      "nbr": 12,
      "value": "What is the output of the following?\nvar teams = new StringBuilder(\"333\");\nteams.append(\" 806\");\nteams.append(\" 1601\");\nSystem.out.print(teams);",
      "responses": [{
        "code": "A",
        "value": "333"
      }, {
        "code": "B",
        "value": "333 806 1601"
      }, {
        "code": "C",
        "value": "The code compiles but outputs something else."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "12. B. Since StringBuilder is mutable, each call to append adds to the value.\nWhen calling print, toString() is automatically called, and 333 806 1601\nis output. Therefore, option B is correct."
      }
    },
    "13": {
      "nbr": 13,
      "value": "Which of the following declarations does not compile?",
      "responses": [{
        "code": "A",
        "value": "double num1, int num2 = 0;"
      }, {
        "code": "B",
        "value": "int num1, num2;"
      }, {
        "code": "C",
        "value": "int num1, num2 = 0;"
      }, {
        "code": "D",
        "value": "int num1 = 0, num2 = 0;"
      }, {
        "code": "E",
        "value": "All of the above"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "13. A. Option A does not compile because Java does not allow declaring\ndifferent types as part of the same declaration. The other three options show\nvarious legal combinations of combining multiple variables in the same\ndeclarations with optional default values."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Given the file Magnet.java shown, which of the marked lines can you\nindependently insert the line var color; into and still have the code\ncompile?\n// line a1\npublic class Magnet {\n// line a2\npublic void attach() {\n// line a3\n}\n// line a4\n}",
      "responses": [{
        "code": "A",
        "value": "a2"
      }, {
        "code": "B",
        "value": "a3"
      }, {
        "code": "C",
        "value": "a2 and a3"
      }, {
        "code": "D",
        "value": "a1, a2, a3, and a4"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "14. E. Local variable type inference requires a value, so that the type can be\ninferred. The statement var color; without a value is not allowed, making\noption E the answer."
      }
    },
    "15": {
      "nbr": 15,
      "value": "Which is one of the lines output by this code?\n10: var list = new ArrayList<Integer>();\n11: list.add(10);\n12: list.add(9);\n13: list.add(8);\n14:\n15: var num = 9;\n16: list.removeIf(x -> {int keep = num; return x !=\nkeep;});\n17: System.out.println(list);\n18:\n19: list.removeIf(x -> {int keep = num; return x ==\nkeep;});\n20: System.out.println(list);",
      "responses": [{
        "code": "A",
        "value": "[]"
      }, {
        "code": "B",
        "value": "[8, 10]"
      }, {
        "code": "C",
        "value": "[8, 9, 10]"
      }, {
        "code": "D",
        "value": "[10, 8]"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "15. A. The code starts by creating a list of three elements. On line 16, it\nremoves two elements and then removes the final one on line 19. This\nprints an empty list, making option A the correct answer. Note that num is\neffectively final, so can be used in a lambda."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Which of the following can fill in the blank so the code prints true?\nvar happy = \" :) - (: \";\nvar really = happy.trim();\nvar question = _____________________;\nSystem.out.println(really.equals(question));",
      "responses": [{
        "code": "A",
        "value": "happy.substring(0, happy.length() ‐ 1)"
      }, {
        "code": "B",
        "value": "happy.substring(0, happy.length())"
      }, {
        "code": "C",
        "value": "happy.substring(1, happy.length() ‐ 1)"
      }, {
        "code": "D",
        "value": "happy.substring(1, happy.length())"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "16. C. The trim() method returns a String with all leading and trailing white\nspace removed. In this question, that's the seven‐character String: \":) ‐\n(:\". Options A and B are incorrect because they do not remove the first\nblank space in happy. Option D is incorrect because it does not remove the\nlast character in happy. Therefore, option C is correct."
      }
    },
    "17": {
      "nbr": 17,
      "value": "How many of the following lines contain a compiler error?\ndouble num1 = 2.718;\ndouble num2 = 2._718;\ndouble num3 = 2.7_1_8;\ndouble num4 = _2.718;",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "17. C. Underscores are allowed between any two digits in a numeric literal,\ncausing num4 to fail to compile. Additionally, underscores are not allowed\nadjacent to a decimal point, causing a compiler error in num2. Since two\nlines have errors, option C is the correct answer."
      }
    },
    "18": {
      "nbr": 18,
      "value": "What is the output of the following application?\npublic class Airplane {\nstatic int start = 2;\nfinal int end;\npublic Airplane(int x) {\nx = 4;\nend = x;\n}\npublic void fly(int distance) {\nSystem.out.print(end-start+\" \");\nSystem.out.print(distance);\n}\npublic static void main(String… start) {\nnew Airplane(10).fly(5);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "2 5"
      }, {
        "code": "B",
        "value": "8 5"
      }, {
        "code": "C",
        "value": "6 5"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "18. A. The code compiles, so option D is incorrect. The input to the\nconstructor is ignored, making the assignment of end to be 4. Since start is\n2, the subtraction of 4 by 2 results in the application printing 2, followed by\n5, making option A the correct answer."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What is the output of the following class?\n1: package rocket;\n2: public class Countdown {\n3: public static void main(String[] args) {\n4: var builder = \"54321\";\n5: builder = builder.substring(4);\n6: System.out.println(builder.charAt(2));\n7: }\n8: }",
      "responses": [{
        "code": "A",
        "value": "2"
      }, {
        "code": "B",
        "value": "3"
      }, {
        "code": "C",
        "value": "4"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "19. D. Line 4 creates a String of length 5. Since String is immutable, line 5\ncreates a new String with the value 1 and assigns it to builder. Remember\nthat indexes in Java begin with zero, so the substring() method is taking\nthe values from the fifth element through the end. Since the first element is\nthe last element, there's only one character in there. Then line 6 tries to\nretrieve the second indexed element. Since there is only one element, this\ngives a StringIndexOutOfBoundsException, and option D is correct."
      }
    },
    "20": {
      "nbr": 20,
      "value": "What is the output of the following application?\npackage transporter;\npublic class Rematerialize {\npublic static void main(String[] input) {\nint init = 11;\nint split = 3;\nint partA = init / split;\nint partB = init % split;\nint result = split * (partB + partA);\nSystem.out.print(result);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "9"
      }, {
        "code": "B",
        "value": "11"
      }, {
        "code": "C",
        "value": "12"
      }, {
        "code": "D",
        "value": "15"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "20. D. The code compiles and runs without issue, making option E incorrect.\nIn this example, partA is the integer division of the two numbers. Since 3\ndoes not divide 11 evenly, it is rounded down to 3. The variable partB is\nthe remainder from the first expression, which is 2. The results are added\ntogether, resulting in the expression 3 * 5, or 15, and making option D\ncorrect."
      }
    },
    "21": {
      "nbr": 21,
      "value": "What is the result of the following code?\nvar sb = new StringBuilder(\"radical\")\n.insert(sb.length(), \"robots\");\nSystem.out.println(sb);",
      "responses": [{
        "code": "A",
        "value": "radicarobots"
      }, {
        "code": "B",
        "value": "radicalrobots"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "21. C. Calling the constructor and then insert() is an example of method\nchaining. However, the sb.length() call is a problem. The sb reference\ndoesn't exist until after the chained calls complete. Just because it happens\nto be on a separate line doesn't change when the reference is created. Since\nthe code does not compile, option C is correct."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Given the following code snippet, what is the value of dinner after it is\nexecuted?\nint time = 9;\nint day = 3;\nvar dinner = ++time>= 10 ? day-- <= 2\n? \"Takeout\" : \"Salad\" : \"Leftovers\";",
      "responses": [{
        "code": "A",
        "value": "Takeout"
      }, {
        "code": "B",
        "value": "Leftovers"
      }, {
        "code": "C",
        "value": "Salad"
      }, {
        "code": "D",
        "value": "The code does not compile but would compile if parentheses were\nadded."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "22. C. While parentheses are recommended for ternary operations, especially\nembedded ones, they are not required, so option D is incorrect. The first\nexpression evaluates to 10 >= 10, so the first branch of the ternary\noperation is selected, and \"Leftovers\" can be eliminated. The expression\nin the second ternary operation evaluates to 3 <= 2, which is false, so\n\"Salad\" is selected, and option C is correct."
      }
    },
    "23": {
      "nbr": 23,
      "value": "What is the output of the following?\nvar teams = new String(\"694\");\nteams.concat(\" 1155\");\nteams.concat(\" 2265\");\nteams.concat(\" 2869\");\nSystem.out.println(teams);",
      "responses": [{
        "code": "A",
        "value": "694"
      }, {
        "code": "B",
        "value": "694 1155 2265 2869"
      }, {
        "code": "C",
        "value": "The code compiles but outputs something else."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "23. A. Since String is immutable, each call to concat() returns a new object\nwith the new value. However, that return value is ignored, and the teams\nvariable never changes in value. Therefore, it stays as 694, and option A is\ncorrect."
      }
    },
    "24": {
      "nbr": 24,
      "value": "How many of the following lines compile?\nbool b = null;\nBool bl = null;\nint i = null;\nInteger in = null;\nString s = null;",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "24. C. First, bool and Bool are not valid Java types. They should be boolean\nand Boolean, respectively. Next, objects are allowed to have a null\nreference while primitives cannot. Since Integer and String are objects,\nthose lines compile. Finally, the line with int is a primitive, so assigning\nnull to it does not compile. Therefore, option C is correct."
      }
    },
    "25": {
      "nbr": 25,
      "value": "What is the output of the following code snippet?\nint height = 2, length = 3;\nboolean w = height> 1 | --length < 4;\nvar x = height!=2 ? length++ : height;\nboolean z = height % length == 0;\nSystem.out.println(w + \"-\" + x + \"-\" + z);",
      "responses": [{
        "code": "A",
        "value": "true‐2‐true"
      }, {
        "code": "B",
        "value": "false‐2‐false"
      }, {
        "code": "C",
        "value": "true‐2‐false"
      }, {
        "code": "D",
        "value": "true‐3‐false"
      }, {
        "code": "E",
        "value": "true‐3‐true"
      }, {
        "code": "F",
        "value": "false‐3‐false"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "25. A. In the first expression, height > 1 is true. Since it uses the logical\noperator (|), which evaluates both sides, the right side is still executed,\nresulting in length being assigned a value of 2 and w assigned a value of\ntrue. In the second expression, only the right‐hand side of the expression is\nevaluated, so x is assigned a value of 2, and length is unchanged. The last\nexpression evaluates to 2 % 2, which is 0, so z is assigned a value of 0."
      }
    },
    "26": {
      "nbr": 26,
      "value": "What is the output of the following?\n1: public class Legos {\n2: public static void main(String[] args) {\n3: var sb = new StringBuilder();\n4: sb.append(\"red\");\n5: sb.deleteCharAt(0);\n6: sb.delete(1, 2);\n7: System.out.println(sb);\n8: }\n9: }",
      "responses": [{
        "code": "A",
        "value": "e"
      }, {
        "code": "B",
        "value": "d"
      }, {
        "code": "C",
        "value": "ed"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "26. A. Line 3 creates an empty StringBuilder. Line 4 adds three characters to\nit. Line 5 removes the first character, resulting in ed. Line 6 deletes the\ncharacters starting at position 1 and ending right before position 2, which\nremoves the character at index 1, which is d. The only character left is e, so\noption A is correct."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Which is a true statement?",
      "responses": [{
        "code": "A",
        "value": "If s.contains(\"abc\") is true, then s.equals(\"abc\") is also true."
      }, {
        "code": "B",
        "value": "If s.contains(\"abc\") is true, then s.startsWith(\"abc\") is also\ntrue."
      }, {
        "code": "C",
        "value": "If s.startsWith(\"abc\") is true, then s.equals(\"abc\") is also true."
      }, {
        "code": "D",
        "value": "If s.startsWith(\"abc\") is true, then s.contains(\"abc\") is also\ntrue."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "27. D. Options A and B are not true if the String is \"deabc\". Option C is not\ntrue if the String is \"abcde\". Option D is true in all cases."
      }
    },
    "28": {
      "nbr": 28,
      "value": "What is the output of the following code snippet?\nboolean carrot = true;\nBoolean potato = false;\nvar broccoli = true;\ncarrot = carrot & potato;\nbroccoli = broccoli ? !carrot : potato;\npotato = !broccoli ^ carrot;\nSystem.out.println(carrot + \",\" + potato + \",\" + broccoli);",
      "responses": [{
        "code": "A",
        "value": "true,false,true"
      }, {
        "code": "B",
        "value": "true,true,true"
      }, {
        "code": "C",
        "value": "false,false,false"
      }, {
        "code": "D",
        "value": "false,true,true"
      }, {
        "code": "E",
        "value": "false,false,true"
      }, {
        "code": "F",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "28. E. The code compiles, so option F is incorrect. The first expression\nevaluates to true & false, which sets carrot to false. The next\nexpression resolves to true ? true : false, which results in broccoli\nbeing set to true. The last expression reduces to false ^ false, which\nsets potato to false. Therefore, option E is the correct output."
      }
    },
    "29": {
      "nbr": 29,
      "value": "What does this code output?\nvar babies = Arrays.asList(\"chick\", \"cygnet\", \"duckling\");\nbabies.replaceAll(x -> { var newValue = \"baby\";\nreturn newValue; });\nSystem.out.println(babies);",
      "responses": [{
        "code": "A",
        "value": "[baby]"
      }, {
        "code": "B",
        "value": "[baby, baby, baby]"
      }, {
        "code": "C",
        "value": "[chick, cygnet, duckling]"
      }, {
        "code": "D",
        "value": "None of the above."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "29. B. The code successfully defines a local variable inside the lambda. Each\nvalue is replaced with baby. Since we have a List, all three are output, and\noption B is the correct answer."
      }
    },
    "30": {
      "nbr": 30,
      "value": "What is the output of the following class?\n1: package rocket;\n2: public class Countdown {\n3: public static void main(String[] args) {\n4: var builder = new StringBuilder(\"54321\");\n5: builder.substring(2);\n6: System.out.println(builder.charAt(1));\n7: }\n8: }",
      "responses": [{
        "code": "A",
        "value": "1"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "3"
      }, {
        "code": "D",
        "value": "4"
      }, {
        "code": "E",
        "value": "Does not compile"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "30. D. Line 4 creates a StringBuilder of length 5. Pay attention to the\nsubstring() method in StringBuilder. It returns a String with the value\n321. It does not change the StringBuilder itself. Then line 6 retrieves the\nsecond indexed element from that unchanged value, which is 4. Therefore,\noption D is correct."
      }
    }
  }
}, {
  "name": "Controlling Program Flow",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "Variables declared as which of the following are never permitted in a\nswitch statement? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "var"
      }, {
        "code": "B",
        "value": "double"
      }, {
        "code": "C",
        "value": "int"
      }, {
        "code": "D",
        "value": "String"
      }, {
        "code": "E",
        "value": "char"
      }, {
        "code": "F",
        "value": "Object"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "1. B,F. A switch statement supports the primitive types byte, short, char,\nand int and the wrapper classes Character, Byte, Short, and Integer. It\nalso supports String and enumerated types. Finally, it permits var if it can\nbe resolved to one of the previous types. Floating‐point types like float\nand double are not supported; therefore, option B is correct. Object is also\nnot supported since it could include any class, making option F correct as\nwell."
      }
    },
    "2": {
      "nbr": 2,
      "value": "What happens when running the following code snippet?\n3: var gas = true;\n4: do (\n5: System.out.println(\"helium\");\n6: gas = gas ^ gas;\n7: gas = !gas;\n8: ) while (!gas);",
      "responses": [{
        "code": "A",
        "value": "It completes successfully without output."
      }, {
        "code": "B",
        "value": "It outputs helium once."
      }, {
        "code": "C",
        "value": "It outputs helium repeatedly."
      }, {
        "code": "D",
        "value": "Line 6 does not compile."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "2. E. The code does not compile because parentheses, (), are used instead of\nbraces, {}, making option E the correct answer. If the code was fixed to use\nbraces, then option B would be the correct answer. The exclusive or (^) of\ntwo true values is false. Therefore, gas would be true at the end of the\nfirst loop and would exit since the loop condition !gas is false."
      }
    },
    "3": {
      "nbr": 3,
      "value": "What is output by the following?\n10: int m = 0, n = 0;\n11: while (m < 5) {\n12: n++;\n13: if (m == 3)\n14: continue;\n15:\n16: switch (m) {\n17: case 0:\n18: case 1:\n19: n++;\n20: default:\n21: n++;\n22: }\n23: m++;\n24: }\n25: System.out.println(m + \" \" + n);",
      "responses": [{
        "code": "A",
        "value": "3 10"
      }, {
        "code": "B",
        "value": "3 12"
      }, {
        "code": "C",
        "value": "5 10"
      }, {
        "code": "D",
        "value": "5 12"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "3. F. When getting this type of question, the best approach is to write down\nthe values of the variables. Both start out as 0 on line 10. On the first\niteration of the loop, n becomes 1, while m remains 0, so the clause in the if\nstatement doesn't run. In the switch statement, the value of m remains 0, so\nit matches the first case. Since there is no break, the default block is also\nexecuted, and n is incremented twice and is now 3. Finally, m is incremented\nto 1.\nOn the second iteration of the loop, m goes from 1 to 2, and n goes from 3 to"
      }
    },
    "4": {
      "nbr": 4,
      "value": "Given the following, which can fill in the blank and allow the code to\ncompile? (Choose three.)\nvar quest = ;\nfor(var zelda : quest) {\nSystem.out.print(zelda);\n}",
      "responses": [{
        "code": "A",
        "value": "3"
      }, {
        "code": "B",
        "value": "new int[] {3}"
      }, {
        "code": "C",
        "value": "new StringBuilder(\"3\")"
      }, {
        "code": "D",
        "value": "List.of(3)"
      }, {
        "code": "E",
        "value": "new String[3]"
      }, {
        "code": "F",
        "value": "\"Link\""
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "E"
        ],
        "explanation": "4. B,D,E. A for‐each loop accepts arrays and classes that implement\njava.lang.Iterable, such as List. For these reasons, options B, D, and E\nare correct. Option A is incorrect because it is a primitive value. Options C\nand F are incorrect because StringBuilder and String do not implement\nIterable."
      }
    },
    "5": {
      "nbr": 5,
      "value": "Which of the following rules about a default branch in a switch statement\nare correct? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "A switch statement is required to declare a default statement."
      }, {
        "code": "B",
        "value": "A default statement must be placed after all case statements."
      }, {
        "code": "C",
        "value": "A default statement can be placed between any case statements."
      }, {
        "code": "D",
        "value": "Unlike a case statement, a default statement does not take a\nparameter value."
      }, {
        "code": "E",
        "value": "A switch statement can contain more than one default statement."
      }, {
        "code": "F",
        "value": "A default statement can be used only when at least one case\nstatement is present."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "5. C,D. A default statement inside a switch statement is optional and can\nbe placed in any order within the switch's case statements, making options\nA and B incorrect and option C correct. Option D is also correct because a\ndefault statement does not take a parameter value. Options E and F are\nincorrect rules about switch statements."
      }
    },
    "6": {
      "nbr": 6,
      "value": "What does the following method output?\nvoid dance() {\nvar singer = 0;\nwhile (singer)\nSystem.out.print(singer++);\n}",
      "responses": [{
        "code": "A",
        "value": "The code does not compile."
      }, {
        "code": "B",
        "value": "The method completes with no output."
      }, {
        "code": "C",
        "value": "The method prints 0 and then terminates."
      }, {
        "code": "D",
        "value": "The method enters an infinite loop."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "6. A. A while loop requires a boolean condition. While singer is a variable,\nit is not a boolean. Therefore, the code does not compile, and option A is\ncorrect."
      }
    },
    "7": {
      "nbr": 7,
      "value": "Which are true statements comparing for‐each and traditional for loops?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Both can iterate through an array starting with the first element."
      }, {
        "code": "B",
        "value": "Only the for‐each loop can iterate through an array starting with the\nfirst element."
      }, {
        "code": "C",
        "value": "Only the traditional for loop can iterate through an array starting with\nthe first element."
      }, {
        "code": "D",
        "value": "Both can iterate through an array starting from the end."
      }, {
        "code": "E",
        "value": "Only the for‐each loop can iterate through an array starting from the\nend."
      }, {
        "code": "F",
        "value": "Only the traditional for loop can iterate through an array starting from\nthe end."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "F"
        ],
        "explanation": "7. A,F. A traditional for loop gives you full control over the order of\niteration. This means you can iterate through the array backward or\nforward. By contrast, with a for‐each loop, the iteration order is determined\nfor you. With an array, this means starting with index 0. Options A and F\nmatch this scenario."
      }
    },
    "8": {
      "nbr": 8,
      "value": "What is the output of the following application?\npackage planning;\npublic class ThePlan {\npublic static void main(String[] input) {\nvar plan = 1;\nplan = plan++ + --plan;\nif(plan==1) {\nSystem.out.print(\"Plan A\");\n} else { if(plan==2) System.out.print(\"Plan B\");\n} else System.out.print(\"Plan C\"); }\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Plan A"
      }, {
        "code": "B",
        "value": "Plan B"
      }, {
        "code": "C",
        "value": "Plan C"
      }, {
        "code": "D",
        "value": "The class does not compile."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "8. D. This code does not compile because it has two else statements as part\nof a single if statement. Notice that the second if statement is not\nconnected to the last else statement. For this reason, option D is the correct\nanswer."
      }
    },
    "9": {
      "nbr": 9,
      "value": "What is true about the following code? (Choose two.)\n23: var race = \"\";\n24: loop:\n25: do {\n26: race += \"x\";\n27: break loop;\n28: } while (true);\n29: System.out.println(race);",
      "responses": [{
        "code": "A",
        "value": "It outputs x."
      }, {
        "code": "B",
        "value": "It does not compile."
      }, {
        "code": "C",
        "value": "It is an infinite loop."
      }, {
        "code": "D",
        "value": "With lines 25 and 28 removed, it outputs x."
      }, {
        "code": "E",
        "value": "With lines 25 and 28 removed, it does not compile."
      }, {
        "code": "F",
        "value": "With lines 25 and 28 removed, it is an infinite loop."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "9. A,E. The code compiles as is. Due to the break statement on line 27, the\nloop executes only once. It prints a single x, which means option A is the\nfirst correct answer. While the label on line 24 is present with lines 25 and\n28 removed, it no longer points to a loop. This causes the code to not\ncompile, and option E is the other correct answer."
      }
    },
    "10": {
      "nbr": 10,
      "value": "Which of the following can replace the body of the perform() method to\nproduce the same output on any nonempty input? (Choose two.)\npublic void perform(String[] circus) {\nfor (int i=circus.length-1; i>=0; i--)\nSystem.out.print(circus[i]);\n}",
      "responses": [{
        "code": "A",
        "value": "for (int i=circus.length; i>0; i--)\nSystem.out.print(circus[i-1]);"
      }, {
        "code": "B",
        "value": "for-reversed (String c = circus)\nSystem.out.print(c);"
      }, {
        "code": "C",
        "value": "for (var c : circus)\nSystem.out.print(c);"
      }, {
        "code": "D",
        "value": "for(var i=0; i<circus.length; i++)\nSystem.out.print(circus[circus.length-i-1]);"
      }, {
        "code": "E",
        "value": "for (int i=circus.length; i>0; i--)\nSystem.out.print(circus[i+1]);"
      }, {
        "code": "F",
        "value": "for-each (String c circus)\nSystem.out.print(c);"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D"
        ],
        "explanation": "10. A,D. The method prints the elements of the array in the reverse order in\nwhich they are defined. Option A correctly accomplishes this using a\ndifferent starting value for the loop. Options B and F do not compile, as\nthey do not use the correct syntax in a for‐each loop. Option C compiles\nand runs without issue, but prints the items in their natural ordering, as\nopposed to the reverse ordering. Option D is correct, as it increments in\npositive order but reverses the output within the body of the for loop.\nFinally, option E is incorrect. The first element read is\ncircus[circus.length+1], which results in an\nArrayIndexOutOfBoundsException."
      }
    },
    "11": {
      "nbr": 11,
      "value": "What does the following code snippet output?\nvar bottles = List.of(\"glass\", \"plastic\", \"can\");\nfor (int type = 1; type < bottles.size();) {\nSystem.out.print(bottles.get(type) + \"-\");\nif(type < bottles.size()) break;\n}\nSystem.out.print(\"end\");",
      "responses": [{
        "code": "A",
        "value": "glass‐end"
      }, {
        "code": "B",
        "value": "glass‐plastic‐can‐end"
      }, {
        "code": "C",
        "value": "plastic‐end"
      }, {
        "code": "D",
        "value": "plastic‐can‐end"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "11. C. The first time through the loop, type is 1, and plastic‐ is output. The\nbreak statement then terminates the loop, with end bring printed. If the\nbreak keyword was removed, then this would be an infinite loop because\ntype is not incremented between loop executions."
      }
    },
    "12": {
      "nbr": 12,
      "value": "What is the result of executing the following code snippet?\nfinal var GOOD = 100;\nvar score = 10;\nswitch (score) {\ndefault:\n1 : System.out.print(\"1-\");\n-1 : System.out.print(\"2-\"); break;\n4,5 : System.out.print(\"3-\");\n6 : System.out.print(\"4-\");\n9 : System.out.print(\"5-\");\n}",
      "responses": [{
        "code": "A",
        "value": "1‐"
      }, {
        "code": "B",
        "value": "1‐2‐"
      }, {
        "code": "C",
        "value": "2‐"
      }, {
        "code": "D",
        "value": "3‐"
      }, {
        "code": "E",
        "value": "4‐"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "12. F. The code does not compile because the switch statement is missing the\ncase keyword for each value. Also, two case values cannot be combined as\nin 4,5."
      }
    },
    "13": {
      "nbr": 13,
      "value": "What is the output of the following application?\npackage dinosaur;\npublic class Park {\npublic final static void main(String… arguments) {\nint pterodactyl = 8;\nlong triceratops = 3;\nif(pterodactyl % 3> 1 + 1)\ntriceratops++;\ntriceratops--;\nSystem.out.print(triceratops);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "2"
      }, {
        "code": "B",
        "value": "3"
      }, {
        "code": "C",
        "value": "4"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "13. A. First, determine whether the if statement's expression is executed. The\nexpression 8 % 3 evaluates to 2. The right‐hand side of the expression is\nevaluated next since + has a higher precedence than >. Since 2 > 2 is\nfalse, the expression triceratops++ is not called. Notice there are no\nbraces, {}, in the if statement. Despite the triceratops–– line being\nindented, it is not part of the if statement. Therefore, triceratops–– is\nalways executed, resulting in a value of 2 for triceratops, and making\noption A the correct answer."
      }
    },
    "14": {
      "nbr": 14,
      "value": "What variable type of red allows the following application to compile?\npackage tornado;\npublic class Kansas {\npublic static void main(String[] args) {\nint colorOfRainbow = 10;\n___________ red = 5;\nswitch(colorOfRainbow) {\ndefault:\nSystem.out.print(\"Home\");\nbreak;\ncase red:\nSystem.out.print(\"Away\");\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "long"
      }, {
        "code": "B",
        "value": "double"
      }, {
        "code": "C",
        "value": "int"
      }, {
        "code": "D",
        "value": "var"
      }, {
        "code": "E",
        "value": "String"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "14. F. The value of a case statement must be a constant, a literal value, or a\nfinal variable. Since red is missing the final attribute, no variable type\nallows the code to compile, making option F the correct answer. If the\nfinal modifier was added to the declaration of red, then int or var would\nbe correct. The other options use types that are incompatible with switch\nstatements or with colorOfRainbow."
      }
    },
    "15": {
      "nbr": 15,
      "value": "How many lines of the magic() method contain compilation errors?\n10: public void magic() {\n11: do {\n12: int trick = 0;\n13: LOOP: do {\n14: trick++;\n15: } while (trick < 2--);\n16: continue LOOP;\n17: } while (1> 2);\n18: System.out.println(trick);\n19: }",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "15. D. Line 15 does not compile because the post‐decrement operator can be\napplied only to variables, not values. Line 16 also does not compile because\nthe label LOOP is out of scope after line 15. Finally, line 18 does not compile\nbecause trick is declared within the do/while loop and out of scope after\nline 17. For these reasons, option D is the correct answer."
      }
    },
    "16": {
      "nbr": 16,
      "value": "How many of these statements can be inserted after the println to have the\ncode flow follow the arrow in this diagram?\nbreak;\nbreak letters;\nbreak numbers;\ncontinue;\ncontinue letters;\ncontinue numbers;",
      "responses": [{
        "code": "A",
        "value": "One"
      }, {
        "code": "B",
        "value": "Two"
      }, {
        "code": "C",
        "value": "Three"
      }, {
        "code": "D",
        "value": "Four"
      }, {
        "code": "E",
        "value": "Five"
      }, {
        "code": "F",
        "value": "None of above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "16. C. If the code follows the arrow, then it prints each letter once, breaking\nout of the inner loop on every iteration. Since a break without a label\napplies to the innermost structure, break and break numbers are\nequivalent, and both of these are correct answers. Likewise, continue and\ncontinue numbers are both equivalent although both wrong in this case\nsince they resume operation of the inner loop. That leaves break letters\nand continue letters. In this case, break letters stops the outer loop\nafter printing just one letter, so it is incorrect. On the other hand, continue\nletters exits the inner loop and returns control to the outer loop, which is\nthe desired behavior. Since three statements are correct, option C is correct."
      }
    },
    "17": {
      "nbr": 17,
      "value": "What is the output of the following application?\npackage dessert;\npublic class IceCream {\npublic final static void main(String… args) {\nvar flavors = 30;\nint eaten = 0;\nswitch(flavors) {\ncase 30: eaten++;\ncase 40: eaten+=2;\ndefault: eaten--;\n}\nSystem.out.print(eaten);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "1"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "3"
      }, {
        "code": "D",
        "value": "The code does not compile because var cannot be used in a switch\nstatement."
      }, {
        "code": "E",
        "value": "The code does not compile for another reason."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "17. B. The code compiles without issue, so options D and E are incorrect. A\nvar can be used in a switch statement, provided the underlying type\nresolves to a supported switch type. Next, notice there are no break\nstatements. Once the matching case statement, 30, is reached, all remaining\ncase statements will be executed. The variable eaten is increased by 1, then\n2, then reduced by 1, resulting in a final value of 2, making option B the\ncorrect answer."
      }
    },
    "18": {
      "nbr": 18,
      "value": "Which of the following statements compile and create infinite loops at\nruntime? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "while (!false) {}"
      }, {
        "code": "B",
        "value": "do {}"
      }, {
        "code": "C",
        "value": "for( : ) {}"
      }, {
        "code": "D",
        "value": "do {} while (true);"
      }, {
        "code": "E",
        "value": "while {}"
      }, {
        "code": "F",
        "value": "for( ; ; ) {}"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "F"
        ],
        "explanation": "18. A,D,F. A while loop and do/while loop both require a boolean\nexpression, making options A and D correct and options B and E incorrect.\nOption C is incorrect because a for‐each statement requires an assignment\ntype and an object to iterate on. Option F is correct and shows a traditional\nfor loop with no arguments."
      }
    },
    "19": {
      "nbr": 19,
      "value": "Which of the following iterates a different number of times than the others?",
      "responses": [{
        "code": "A",
        "value": "for (int k=0; k < 5; k++) {}"
      }, {
        "code": "B",
        "value": "for (int k=1; k <= 5; k++) {}"
      }, {
        "code": "C",
        "value": "int k=0; do { } while(k++ < 5);"
      }, {
        "code": "D",
        "value": "int k=0; while (k++ < 5) {}"
      }, {
        "code": "E",
        "value": "All of these iterate the same number of times."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "19. C. Option A goes through five indexes on the iterations: 0, 1, 2, 3, and 4.\nOption B also goes through five indexes: 1, 2, 3, 4, and 5. Option D goes\nthrough five iterations as well, from 0 to 4. However, option C goes through\nsix iterations since the loop condition is at the end of the loop. Therefore, it\nis not like the others, and option C is the correct answer."
      }
    },
    "20": {
      "nbr": 20,
      "value": "What is the output of the following code snippet?\nint count = 0;\nvar stops = new String[] { \"Washington\", \"Monroe\",\n\"Jackson\", \"LaSalle\" };\nwhile (count < stops.length)\nif (stops[++count].length() < 8)\nbreak;\nelse continue;\nSystem.out.println(count);",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "20. B. On the first iteration of the loop, stops[++count] evaluates to\nstops[1], while also setting count to 1. Since stops[1] is Monroe and it\nhas six characters, the break is reached, and the loop stops. For this reason,\n1 is printed, making option B correct."
      }
    },
    "21": {
      "nbr": 21,
      "value": "What is the output of the following code snippet?\nint hops = 0;\nint jumps = 0;\njumps = hops++;\nif(jumps)\nSystem.out.print(\"Jump!\");\nelse\nSystem.out.print(\"Hop!\");",
      "responses": [{
        "code": "A",
        "value": "Jump!"
      }, {
        "code": "B",
        "value": "Hop!"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "21. C. The statement if(jumps) evaluates to if(0), and since 0 is not a\nboolean value, the code does not compile. Java requires boolean\nexpressions in if statements."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Which of the following best describes the flow of execution in this for loop\nif beta always returns false?\nfor (alpha; beta; gamma) {\ndelta;\n}",
      "responses": [{
        "code": "A",
        "value": "alpha"
      }, {
        "code": "B",
        "value": "alpha, beta"
      }, {
        "code": "C",
        "value": "alpha, beta, gamma"
      }, {
        "code": "D",
        "value": "alpha, gamma"
      }, {
        "code": "E",
        "value": "alpha, gamma, beta"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "22. B. The initializer, which is alpha, runs first. Then Java checks the\ncondition, which is beta, to see whether loop execution should start. Since\nbeta returns false, the loop is never entered, and option B is correct."
      }
    },
    "23": {
      "nbr": 23,
      "value": "What is the output of the following code snippet?\nboolean balloonInflated = false;\ndo {\nif (!balloonInflated) {\nballoonInflated = true;\nSystem.out.print(\"inflate-\");\n}\n} while (! balloonInflated);\nSystem.out.println(\"done\");",
      "responses": [{
        "code": "A",
        "value": "done"
      }, {
        "code": "B",
        "value": "inflate‐done"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "This is an infinite loop."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "23. B. On the first iteration of the loop, the if statement executes and prints\ninflate‐. Then the loop condition is checked. The variable\nballoonInflated is true, so the loop condition is false, and the loop\ncompletes and done is printed."
      }
    },
    "24": {
      "nbr": 24,
      "value": "Which of these code snippets behaves differently from the others?",
      "responses": [{
        "code": "A",
        "value": "if (numChipmunks == 1)\nSystem.out.println(\"One chipmunk\");\nif (numChipmunks == 2)\nSystem.out.println(\"Two chipmunks\");\nif (numChipmunks == 3)\nSystem.out.println(\"Three chipmunks\");"
      }, {
        "code": "B",
        "value": "switch (numChipmunks) {\ncase 1: System.out.println(\"One chipmunk\");\ncase 2: System.out.println(\"Two chipmunks\");\ncase 3: System.out.println(\"Three chipmunks\");\n}"
      }, {
        "code": "C",
        "value": "if (numChipmunks == 1)\nSystem.out.println(\"One chipmunk\");\nelse if (numChipmunks == 2)\nSystem.out.println(\"Two chipmunks\");\nelse if (numChipmunks == 3)\nSystem.out.println(\"Three chipmunks\");"
      }, {
        "code": "D",
        "value": "All three code snippets do the same thing."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "24. B. Options A and C print one line if numChipmunks is 1, 2, or 3. Option B\ndoes not behave the same way if numChipmunks is 1 or 2. There is no break\nstatement, so the case statements fall through, and more than one statement\nwill be printed."
      }
    },
    "25": {
      "nbr": 25,
      "value": "Which statements about loops are correct? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "A do/while loop requires a body."
      }, {
        "code": "B",
        "value": "A while loop cannot be exited early with a return statement."
      }, {
        "code": "C",
        "value": "A while loop requires a conditional expression."
      }, {
        "code": "D",
        "value": "A do/while loop executes the body (if present) at least once."
      }, {
        "code": "E",
        "value": "A do/while loop cannot be exited early with a return statement."
      }, {
        "code": "F",
        "value": "A while loop executes the body (if present) at least once."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "D"
        ],
        "explanation": "25. A,C,D. A do/while loop requires a body, making option A correct.\nOptions B and E are incorrect, as both types of while loops can be exited\nearly with a return statement. Both also require a conditional expression,\nmaking option C correct. What distinguishes a do/while loop from a while\nloop is that it executes its body at least once, making option D correct and\noption F incorrect."
      }
    },
    "26": {
      "nbr": 26,
      "value": "Given the following enum and class, which option fills in the blank and\nallows the code to compile?\nenum Season { SPRING, SUMMER, WINTER }\npublic class Weather {\npublic int getAverageTemperate(Season s) {\nswitch (s) {\ndefault:\n______________ return 30;\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "case Season.WINTER:"
      }, {
        "code": "B",
        "value": "case WINTER, SPRING:"
      }, {
        "code": "C",
        "value": "case SUMMER | WINTER:"
      }, {
        "code": "D",
        "value": "case SUMMER ‐>"
      }, {
        "code": "E",
        "value": "case FALL:"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "26. F. Option A is incorrect because the enum type Season is not used within\na case statement. If it were just case WINTER:, then it would compile.\nOptions B and C do not compile because switch statements do not support\nmultiple values within a case statement. Option D is incorrect because ‐> is\nused instead of :. Option E is incorrect because FALL is not defined in the\nlist of values for the enum Season. Since none of the lines of code is\ncorrect, option F is correct."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Fill in the blank with the line of code that causes the application to compile\nand print exactly one line at runtime.\npackage nyc;\npublic class TourBus {\npublic static void main(String… args) {\nvar nycTour = new String[] { \"Downtown\", \"Uptown\",\n\"Brooklyn\" };\nvar times = new String[] { \"Day\", \"Night\" };\nfor (_______________ i<nycTour.length &&\nj<times.length;\ni++, j++)\nSystem.out.println(nycTour[i] + \"-\" + times[j]);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "int i=1; j=1;"
      }, {
        "code": "B",
        "value": "int i=0, j=1;"
      }, {
        "code": "C",
        "value": "int i=1; int j=0;"
      }, {
        "code": "D",
        "value": "int i=1, int j=0;"
      }, {
        "code": "E",
        "value": "int i=1, j=0;"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "27. B. In a traditional for loop, only one initialization type is allowed to be\nspecified. If more than one variable is supplied, then they are separated by a\ncomma. Therefore, options A, C, and D do not compile. Options B and E\nboth compile, although only option B prints a single line at runtime. Option\nE instead prints two lines since nycTour is of size 3 and times is of size 2."
      }
    },
    "28": {
      "nbr": 28,
      "value": "The code contains six pairs of curly braces. How many pairs can be\nremoved without changing the behavior?\n12: public static void main(String[] args) {\n13: int secret = 0;\n14: for (int i = 0; i < 10; i++) {\n15: while (i < 10) {\n16: if (i == 5) {\n17: System.out.println(\"if\");\n18: } else {\n19: System.out.println(\"in\");\n20: System.out.println(\"else\");\n21: }\n22: }\n23: }\n24: switch (secret) {\n25: case 0: System.out.println(\"zero\");\n26: }\n27: }",
      "responses": [{
        "code": "A",
        "value": "One"
      }, {
        "code": "B",
        "value": "Two"
      }, {
        "code": "C",
        "value": "Three"
      }, {
        "code": "D",
        "value": "Four"
      }, {
        "code": "E",
        "value": "Five"
      }, {
        "code": "F",
        "value": "Six"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "28. C. The braces on lines 12/27 are required because they comprise the\nmethod body. The braces on lines 24/26 are required because a switch\nstatement needs braces regardless of how many case statements are inside.\nFinally, the braces on lines 18/21 are required because the else has two\nstatements inside.\nThe braces on lines 14/23, 15/22, and 16/18 are all optional because there is\nonly one statement inside. Since there are three pairs, option C is correct."
      }
    },
    "29": {
      "nbr": 29,
      "value": "Which of the following can replace the body of the travel() method to\nproduce the same output on any nonempty input?\npublic void travel(List<Integer> roads) {\nfor (int w = 1; w <= roads.size(); w++)\nSystem.out.print(roads.get(w-1));\n}",
      "responses": [{
        "code": "A",
        "value": "for (int r = 0; r < roads.size(); r += 1)\nSystem.out.print(roads.get(0));"
      }, {
        "code": "B",
        "value": "for(var z : roads)\nSystem.out.print(z);"
      }, {
        "code": "C",
        "value": "for (int t = roads.size(); t> 0; t--)\nSystem.out.print(roads.get(t));"
      }, {
        "code": "D",
        "value": "for (var var : roads)\nSystem.out.print(roads);"
      }, {
        "code": "E",
        "value": "for (int q = roads.size(); q>= 0; q++)\nSystem.out.print(roads.get(q));"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "29. B. The method prints the elements of the list in the order in which they are\ndefined. Option A is incorrect and prints the first element repeatedly.\nOption B is correct and prints the elements using a for‐each loop. Options C\nand E are incorrect because the first element read results in an\nArrayIndexOutOfBoundsException. Finally, option D is incorrect because\nthe entire list is printed each time."
      }
    },
    "30": {
      "nbr": 30,
      "value": "Which statement about the following code snippet is correct?\n3: final var javaVersions = List.of(9,10,11);\n4: var exams = List.of(\"1Z0-811\", \"1Z0-819\");\n5: V: for (var e1 : javaVersions) {\n6: E: for (String e2 : exams)\n7: System.out.println(e1 + \"_\" + e2);\n8: break;\n9: }",
      "responses": [{
        "code": "A",
        "value": "One line does not compile."
      }, {
        "code": "B",
        "value": "Two lines do not compile."
      }, {
        "code": "C",
        "value": "Three lines do not compile."
      }, {
        "code": "D",
        "value": "It compiles and prints two lines at runtime."
      }, {
        "code": "E",
        "value": "It compiles and prints three lines at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "30. D. The code snippet compiles, making options A, B, and C incorrect.\nNotice that the inner for‐each loop does not use braces, {}, so the break\nstatement applies to the outer loop only. On the first iteration of the outer\nloop, the inner loop prints 9_1Z0‐811 and 9_1Z0‐819. Then, the break\nstatement is encountered, and the outer loop is terminated, making option D\ncorrect. If braces were added around lines 7 and 8, then the code would\ninstead print 9_1Z0‐811, 10_1Z0‐811, and 11_1Z0‐811, and option E would\nbe correct."
      }
    }
  }
}, {
  "name": "Java Object‐Oriented Approach",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "What is the output of the following application?\npackage dnd;\nfinal class Story {\nvoid recite(int chapter) throws Exception {}\n}\npublic class Adventure extends Story {\nfinal void recite(final int chapter) { // g1\nswitch(chapter) { // g2\ncase 2: System.out.print(9);\ndefault: System.out.print(3);\n}\n}\npublic static void main(String… u) {\nvar bedtime = new Adventure();\nbedtime.recite(2);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "3"
      }, {
        "code": "B",
        "value": "9"
      }, {
        "code": "C",
        "value": "93"
      }, {
        "code": "D",
        "value": "The code does not compile because of line g1."
      }, {
        "code": "E",
        "value": "The code does not compile because of line g2."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "The result is that the combined value is 20",
          " making option E the correct\nanswer"
        ],
        "explanation": "1. The result is that the combined value is 20, making option E the correct\nanswer."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Which of the following lines of code are not permitted as the first line of a\nJava class file? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "import widget.*;"
      }, {
        "code": "B",
        "value": "// Widget Manager"
      }, {
        "code": "C",
        "value": "int facilityNumber;"
      }, {
        "code": "D",
        "value": "package sprockets;"
      }, {
        "code": "E",
        "value": "/** Author: Cid **/"
      }, {
        "code": "F",
        "value": "void produce() {}"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "2. C,F. A class can start with a comment, an optional package statement, or\nan import statement if there is no package statement. It cannot start with a\nvariable definition or method declaration, since those cannot be declared\noutside a type. Therefore, options C and F are correct."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Which of the following modifiers can be applied to an abstract method?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "final"
      }, {
        "code": "B",
        "value": "private"
      }, {
        "code": "C",
        "value": "public"
      }, {
        "code": "D",
        "value": "default"
      }, {
        "code": "E",
        "value": "protected"
      }, {
        "code": "F",
        "value": "concrete"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "3. C,E. An abstract method cannot include the final or private modifier. If\na method contained either of these modifiers, then no concrete subclass\nwould ever be able to override it with an implementation. For these reasons,\noptions A and B are incorrect. Option D is also incorrect because the\ndefault keyword applies to concrete interface methods, not abstract\nmethods. Option F is incorrect because there is no concrete modifier. That\nleaves options C and E as the correct answer. The protected, packageprivate,\nand public access modifiers can each be applied to abstract\nmethods."
      }
    },
    "4": {
      "nbr": 4,
      "value": "What is the result of compiling and executing the following class?\n1: public class ParkRanger {\n2: int birds = 10;\n3: public static void main(String[] data) {\n4: var trees = 5;\n5: System.out.print(trees+birds);\n6: }\n7: }",
      "responses": [{
        "code": "A",
        "value": "It compiles and outputs 5."
      }, {
        "code": "B",
        "value": "It compiles and outputs 15."
      }, {
        "code": "C",
        "value": "It does not compile."
      }, {
        "code": "D",
        "value": "It compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "4. C. The code does not compile because of line 5, making option C the\ncorrect answer. For this question, it helps to understand variable scope. The\nmain() method is static and does not have access to any class instance\nvariables. The birds variable is not static and requires a class instance\nvariable to access. Therefore, the code does not compile when the static\nmethod attempts to access a non‐static variable without an instance of the\nclass."
      }
    },
    "5": {
      "nbr": 5,
      "value": "Fill in the blanks: The ___________________ access modifier allows\naccess to everything the ___________________ access modifier does and\nmore.",
      "responses": [{
        "code": "A",
        "value": "package‐private, protected"
      }, {
        "code": "B",
        "value": "private, package‐private"
      }, {
        "code": "C",
        "value": "private, protected"
      }, {
        "code": "D",
        "value": "private, public"
      }, {
        "code": "E",
        "value": "public, private"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "5. E. The public access modifier allows access to members in the same\nclass, package, subclass, or even classes in other packages, while the\nprivate modifier allows access only to members in the same class.\nTherefore, the public access modifier allows access to everything the\nprivate access modifier does, and more, making option E the correct\nanswer. Options A, B, C, and D are incorrect because the first term is a\nmore restrictive access modifier than the second term."
      }
    },
    "6": {
      "nbr": 6,
      "value": "Which set of modifiers, when added to a default method within an\ninterface, prevents it from being overridden by a class implementing the\ninterface?",
      "responses": [{
        "code": "A",
        "value": "const"
      }, {
        "code": "B",
        "value": "final"
      }, {
        "code": "C",
        "value": "static"
      }, {
        "code": "D",
        "value": "private"
      }, {
        "code": "E",
        "value": "private static"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "6. F. There is no modifier that can prevent a default method from being\noverridden in a class implementing an interface, making option F correct."
      }
    },
    "7": {
      "nbr": 7,
      "value": "Given the following application, fill in the missing values in the table\nstarting from the top and going downward.\npackage competition;\npublic class Robot {\nstatic String weight = \"A lot\";\ndouble ageMonths = 5, ageDays = 2;\nprivate static boolean success = true;\npublic void main(String[] args) {\nfinal String retries = \"1\";\n// P1\n}\n}\nVariable Type Number of Variables Accessible at P1\nClass _____\nInstance _____\nLocal _____",
      "responses": [{
        "code": "A",
        "value": "2, 0, 1"
      }, {
        "code": "B",
        "value": "2, 2, 1"
      }, {
        "code": "C",
        "value": "1, 0, 1"
      }, {
        "code": "D",
        "value": "0, 2, 1"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "7. B. Notice in this question that main() is not a static method; therefore, it\ncan access both class and instance variables. Since there are two class\nvariables and two instance variables defined, option B is the correct answer."
      }
    },
    "8": {
      "nbr": 8,
      "value": "Given the following code, what values inserted, in order, into the blank\nlines allow the code to compile? (Choose two.)\n_______ agent;\npublic _______ Banker {\nprivate static _______ getMaxWithdrawal() {\nreturn 10;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "package, new, int"
      }, {
        "code": "B",
        "value": "package, class, long"
      }, {
        "code": "C",
        "value": "import, class, null"
      }, {
        "code": "D",
        "value": "//, class, int"
      }, {
        "code": "E",
        "value": "import, interface, void"
      }, {
        "code": "F",
        "value": "package, class, void"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "8. B,D. Option A is incorrect because new cannot be used to declare a type.\nOption C is incorrect because null is a literal and cannot be used as the\nname of a class. Options E and F are incorrect because a void method\ncannot return a value. That leaves options B and D as the correct answers.\nNote that 10 can be returned as an int or implicitly promoted to a long,\nwithout issue."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Which of the following are correct? (Choose two.)\npublic class Phone {\nprivate int size;\n// insert constructor here\npublic static void sendHome(Phone p, int newSize) {\np = new Phone(newSize);\np.size = 4;\n}\npublic static final void main(String… params) {\nfinal var phone = new Phone(3);\nsendHome(phone,7);\nSystem.out.print(phone.size);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The following is a valid constructor:\npublic static Phone create(int size) {\nreturn new Phone(size);\n}"
      }, {
        "code": "B",
        "value": "The following is a valid constructor:\npublic static Phone newInstance(int size) {\nreturn new Phone();\n}"
      }, {
        "code": "C",
        "value": "The following is a valid constructor:\npublic Phone(int size) {\nthis.size=size;\n}"
      }, {
        "code": "D",
        "value": "The following is a valid constructor:\npublic void Phone(int size) {\nthis.size=size;\n}"
      }, {
        "code": "E",
        "value": "With the correct constructor, the output is 3."
      }, {
        "code": "F",
        "value": "With the correct constructor, the output is 7."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "9. C,E. Options A and B are static methods rather than constructors. Option\nD is a method that happens to have the same name as the class. It is not a\nconstructor because constructors don't have return types. Option C is a valid\nconstructor.\nAs for the output, the key is that Java uses “pass by value” to send object\nreferences to methods. Since the Phone reference p was reassigned in the\nfirst line of the sendHome() method, any changes to the p reference were\nmade to a new object. In other words, no changes in the sendHome()\nmethod affected the object that was passed in. Therefore, the value of size\nwas the same before and after the method call, making the output 3 and\noption E the correct answer."
      }
    },
    "10": {
      "nbr": 10,
      "value": "Given the following class structures, which lines can be inserted into the\nblank independently that would allow the class to compile? (Choose two.)\npublic class Dinosaur {\nclass Pterodactyl extends Dinosaur {}\npublic void roar() {\nvar dino = new Dinosaur();\n___________________;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "dino.Pterodactyl()"
      }, {
        "code": "B",
        "value": "Dinosaur.new Pterodactyl()"
      }, {
        "code": "C",
        "value": "dino.new Pterodactyl()"
      }, {
        "code": "D",
        "value": "new Dino().new Pterodactyl()"
      }, {
        "code": "E",
        "value": "new Dinosaur().Pterodactyl()"
      }, {
        "code": "F",
        "value": "new Dinosaur.Pterodactyl()"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "10. C,F. Options A and E are incorrect because the new keyword before\nPterodactyl is required to create an instance of the member inner class\nPterodactyl using a member of the outer class Dinosaur. Option B is\nincorrect, as this is not a valid way to instantiate a member inner class.\nOption C is correct and relies on the dino instance variable for the outer\nclass instance. Option D would be correct if Dino was changed to the\ncorrect class name, Dinosaur. Finally, option F is correct and relies on the\nfact that roar() is an instance method, which means there's an implicit\ninstance of the outer class Dinosaur available. The Dinosaur. prefix is\noptional, though."
      }
    },
    "11": {
      "nbr": 11,
      "value": "What is the output of the Computer program?\nclass Laptop extends Computer {\npublic void startup() {\nSystem.out.print(\"laptop-\");\n}\n}\npublic class Computer {\npublic void startup() {\nSystem.out.print(\"computer-\");\n}\npublic static void main(String[] args) {\nComputer computer = new Laptop();\nLaptop laptop = new Laptop();\ncomputer.startup();\nlaptop.startup();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "computer‐laptop‐"
      }, {
        "code": "B",
        "value": "laptop‐computer‐"
      }, {
        "code": "C",
        "value": "laptop‐laptop‐"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "11. C. Both objects are instances of the class Laptop. This means the\noverridden startup() method in the Laptop class gets called both times\nthanks to polymorphism, making option C correct."
      }
    },
    "12": {
      "nbr": 12,
      "value": "What access modifier is used to mark class members package‐private?",
      "responses": [{
        "code": "A",
        "value": "default"
      }, {
        "code": "B",
        "value": "friend"
      }, {
        "code": "C",
        "value": "protected"
      }, {
        "code": "D",
        "value": "private"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "12. E. In Java, the lack of an access modifier indicates that the member is\npackage‐private; therefore, option E is correct. Note that the default\nkeyword is used for interfaces, annotations, and switch statements, and is\nnot an access modifier."
      }
    },
    "13": {
      "nbr": 13,
      "value": "How many lines does the following code output?\npublic class Cars {\nprivate static void drive() {\nstatic {\nSystem.out.println(\"static\");\n}\nSystem.out.println(\"fast\");\n{ System.out.println(\"faster\"); }\n}\npublic static void main(String[] args) {\ndrive();\ndrive();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "Three."
      }, {
        "code": "D",
        "value": "Four."
      }, {
        "code": "E",
        "value": "None of the above. The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "13. E. A static initializer is not allowed inside a method. It should go on the\nclass level rather than the method level. Therefore, the code does not\ncompile, and option E is correct."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Which statements about static interface methods are correct? (Choose\nthree.)",
      "responses": [{
        "code": "A",
        "value": "A static interface method can be final."
      }, {
        "code": "B",
        "value": "A static interface method can be declared private."
      }, {
        "code": "C",
        "value": "A static interface method can be package‐private."
      }, {
        "code": "D",
        "value": "A static interface method can be declared public."
      }, {
        "code": "E",
        "value": "A static interface method can be declared protected."
      }, {
        "code": "F",
        "value": "A static interface method can be declared without an access\nmodifier."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "F"
        ],
        "explanation": "14. B,D,F. Option A is incorrect as methods cannot be marked final within\nan interface. Interfaces support static methods that are marked public or\nprivate, making options B and D correct and option E incorrect. Option F\nis correct and lack of access modifier makes the method implicitly public,\nnot package‐private, making option C incorrect."
      }
    },
    "15": {
      "nbr": 15,
      "value": "Fill in the blanks with the only option that makes this statement false: A(n)\n______________ can access ______________ of the enclosing class in\nwhich it is defined.",
      "responses": [{
        "code": "A",
        "value": "static nested class, static members"
      }, {
        "code": "B",
        "value": "static nested class, instance members"
      }, {
        "code": "C",
        "value": "member inner class, static members"
      }, {
        "code": "D",
        "value": "member inner class, instance members"
      }, {
        "code": "E",
        "value": "local class, instance members from within an instance method"
      }, {
        "code": "F",
        "value": "anonymous class, instance members from within an instance method"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "15. B. A static nested class cannot access instance members of the enclosing\nclass, making option B correct. The rest of the options form true statements."
      }
    },
    "16": {
      "nbr": 16,
      "value": "What is the result of executing the following program?\npublic class Canine {\npublic String woof(int bark) {\nreturn \"1\"+bark.toString();\n}\npublic String woof(Integer bark) {\nreturn \"2\"+bark.toString();\n}\npublic String woof(Object bark) {\nreturn \"3\"+bark.toString();\n}\npublic static void main(String[] a) {\nSystem.out.println(woof((short)5));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "15"
      }, {
        "code": "B",
        "value": "25"
      }, {
        "code": "C",
        "value": "35"
      }, {
        "code": "D",
        "value": "One line does not compile."
      }, {
        "code": "E",
        "value": "Two lines do not compile."
      }, {
        "code": "F",
        "value": "The program compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "16. E. The first woof() method does not compile because bark is a primitive,\nnot an object, and does not have a toString() method. The main() method\nalso does not compile because it is static and all of the woof() methods\nrequire an instance of Canine. Since these two lines do not compile, option\nE is the correct answer. If the toString() was removed from the first\nmethod and all of the methods were marked static, then the program\nwould print 15 at runtime."
      }
    },
    "17": {
      "nbr": 17,
      "value": "What statement best describes the notion of effectively final in Java?",
      "responses": [{
        "code": "A",
        "value": "A local variable that is marked final"
      }, {
        "code": "B",
        "value": "A static variable that is marked final"
      }, {
        "code": "C",
        "value": "A local variable whose primitive value or object reference does not\nchange after it is initialized"
      }, {
        "code": "D",
        "value": "A local variable whose primitive value or object reference does not\nchange after a certain point in the method"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "17. C. A local variable is effectively final when its primitive value or object\nreference does not change after it is initialized, making option C the correct\nanswer. Note that option D is incorrect because any change to the variable\nafter it is initialized disqualifies it for being considered effectively final."
      }
    },
    "18": {
      "nbr": 18,
      "value": "What is the output of the Turnip class?\npackage animal;\ninterface GameItem {\nint sell();\n}\nabstract class Vegetable implements GameItem {\npublic final int sell() { return 5; }\n}\npublic class Turnip extends Vegetable {\npublic final int sell() { return 3; }\npublic static void main(String[] expensive) {\nSystem.out.print(new Turnip().sell());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "3"
      }, {
        "code": "B",
        "value": "5"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "18. C. The sell() method is declared final in the Vegetable class. The\nTurnip class then attempts to override this method, resulting in a\ncompilation error, making option C the correct answer."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What is the output of the following application?\npackage holiday;\nenum DaysOff {\nThanksgiving, PresidentsDay, ValentinesDay\n}\npublic class Vacation {\npublic static void main(String… unused) {\nfinal DaysOff input = DaysOff.Thanksgiving;\nswitch(input) {\ndefault:\ncase DaysOff.ValentinesDay:\nSystem.out.print(\"1\");\ncase DaysOff.PresidentsDay:\nSystem.out.print(\"2\");\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "1"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "12"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "19. D. The case statements incorrectly use the enum name as well as the\nvalue, such as DaysOff.ValentinesDay. Since the type of the enum is\ndetermined by the value of the variable in the switch statement, the enum\nname is not allowed and causes a compilation error when used. For this\nreason, option D is correct. If the enum name DaysOff was removed, the\napplication would output 12, since the lack of any break statements causes\nmultiple blocks to be reached, and option C would have been the correct\nanswer."
      }
    },
    "20": {
      "nbr": 20,
      "value": "Which statements about instance keywords are correct? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "The that keyword can be used to read public members in the direct\nparent class."
      }, {
        "code": "B",
        "value": "The this keyword can be used to read all members declared within the\nclass."
      }, {
        "code": "C",
        "value": "The super keyword can be used to read all members declared in a\nparent class."
      }, {
        "code": "D",
        "value": "The that keyword can be used to read members of another class."
      }, {
        "code": "E",
        "value": "The this keyword can be used to read public members in the direct\nparent class."
      }, {
        "code": "F",
        "value": "The super keyword can be used in static methods."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "20. B,E. There is no that keyword, so options A and D are incorrect. Option\nB is correct, as this can access all members declared within the class.\nOption C is incorrect, as only inherited members can be accessed. For\nexample, private members declared in a parent class cannot be accessed\nusing super. Option E is correct, as this allows access to members\ndeclared in the class and those inherited from a parent. Finally, option F is\nincorrect, as static methods do not have access to this or super\nreferences."
      }
    },
    "21": {
      "nbr": 21,
      "value": "Fill in the blanks: A class ____________ an interface and ______________\nan abstract class. An interface ______________ another interface.",
      "responses": [{
        "code": "A",
        "value": "extends, extends, implements"
      }, {
        "code": "B",
        "value": "extends, implements, extends"
      }, {
        "code": "C",
        "value": "extends, implements, implements"
      }, {
        "code": "D",
        "value": "implements, extends, extends"
      }, {
        "code": "E",
        "value": "implements, extends, implements"
      }, {
        "code": "F",
        "value": "implements, implements, extends"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "21. D. A class can implement an interface, not extend it, ruling out options A,\nB, and C. Classes do extend an abstract class, ruling out option F. Finally,\nan interface can only extend another interface, making option D the correct\nanswer."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Suppose you have the following code. Which of the images best represents\nthe state of the references c1, c2, and c3, right before the end of the main()\nmethod, assuming garbage collection hasn't run? In the diagrams, each box\nrepresents a Chicken object with a number of eggs.\n1: public class Chicken {\n2: private Integer eggs = 2;\n3: { this.eggs = 3; }\n4: public Chicken(int eggs) {\n5: this.eggs = eggs;\n6: }\n7: public static void main(String[] r) {\n8: var c1 = new Chicken(1);\n9: var c2 = new Chicken(2);\n10: var c3 = new Chicken(3);\n11: c1.eggs = c2.eggs;\n12: c2 = c1;\n13: c3.eggs = null;\n14: } }",
      "responses": [{
        "code": "A",
        "value": "Option A."
      }, {
        "code": "B",
        "value": "Option B."
      }, {
        "code": "C",
        "value": "Option C."
      }, {
        "code": "D",
        "value": "Option D."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "22. B. Three instances of Chicken are created on lines 8–10. On line 11, the\nvalue of eggs in the first two instances is set to 2, while the third instance\nhas a value of 3. On line 12, the original instance that was pointed to by c1\n(with an eggs value of 2) is dereferenced and eligible for garbage\ncollection. The c1 and c2 variables now both point to the same instance\nwith an egg value of 2. Finally, on line 13, the eggs value for c3 is changed\nfrom 3 to null."
      }
    },
    "23": {
      "nbr": 23,
      "value": "What is the output of the following application?\npackage musical;\ninterface Speak { default int talk() { return 7; } }\ninterface Sing { default int talk() { return 5; } }\npublic class Performance implements Speak, Sing {\npublic int talk(String… x) {\nreturn x.length;\n}\npublic static void main(String[] notes) {\nSystem.out.print(new Performance().talk());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "7"
      }, {
        "code": "B",
        "value": "5"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles without issue, but the output cannot be determined\nuntil runtime."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "23. C. Java does not allow multiple inheritance, so having one class\nimplement two interfaces that both define the same default method\nsignature leads to a compiler error, unless the class overrides the method. In\nthis case, the talk(String…) method defined in the Performance class is an\noverloaded method, not an overridden one, because the signatures do not\nmatch. Therefore, the Performance class does not compile, making option\nC correct."
      }
    },
    "24": {
      "nbr": 24,
      "value": "What is the output of the following application?\npackage ai;\ninterface Pump {\nvoid pump(double psi);\n}\ninterface Bend extends Pump {\nvoid bend(double tensileStrength);\n}\npublic class Robot {\npublic static final void apply(\nBend instruction, double input) {\ninstruction.bend(input);\n}\npublic static void main(String… future) {\nfinal Robot r = new Robot();\nr.apply(x -> System.out.print(x+\" bent!\"), 5);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "5 bent!"
      }, {
        "code": "B",
        "value": "5.0 bent!"
      }, {
        "code": "C",
        "value": "The code does not compile because Bend is not a functional interface."
      }, {
        "code": "D",
        "value": "The code does not compile because of the apply() method\ndeclaration."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "24. C. A functional interface must contain exactly one abstract method. The\nBend interface contains two abstract methods, pump() and bend(), since it\nextends Pump and inherits pump(). For this reason, the Bend interface is not\na valid functional interface and therefore cannot be used as a lambda\nexpression, making option C the correct answer. The rest of the code\ncompiles without issue. Note that the usage of an instance variable to call a\nstatic method, r.apply() in the main() method, is permitted but\ndiscouraged."
      }
    },
    "25": {
      "nbr": 25,
      "value": "Which statement is true about encapsulation while providing the broadest\naccess allowed?",
      "responses": [{
        "code": "A",
        "value": "Variables are private, and methods are private."
      }, {
        "code": "B",
        "value": "Variables are private, and methods are public."
      }, {
        "code": "C",
        "value": "Variables are public, and methods are private."
      }, {
        "code": "D",
        "value": "Variables are public, and methods are public."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "25. B. If the variables are public, the class is not encapsulated because callers\nhave direct access to them. This rules out options C and D. Having private\nmethods doesn't allow the callers to use the data, making option A an\nundesirable answer. Option B is correct and the classic definition of\nencapsulation where the data is not exposed directly."
      }
    },
    "26": {
      "nbr": 26,
      "value": "Fill in the blanks: The ___________________ access modifier allows\naccess to everything the ___________________ access modifier does and\nmore.",
      "responses": [{
        "code": "A",
        "value": "package‐private, private"
      }, {
        "code": "B",
        "value": "private, protected"
      }, {
        "code": "C",
        "value": "protected, public"
      }, {
        "code": "D",
        "value": "private, package‐private"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "26. A. Package‐private allows access by code within the same package, while\nthe private modifier allows access only to members in the same class. This\nmakes option A the correct answer. Options B, C, and D are incorrect\nbecause the first term is a more restrictive access modifier than the second\nterm."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Which statement about the following interface is correct?\npublic interface Swimming {\nString DEFAULT = \"Diving!\"; // k1\nabstract int breath();\nprivate static void stroke() {\nif(breath()==1) { // k2\nSystem.out.print(\"Go!\");\n} else {\nSystem.out.print(dive()); // k3\n}\n}\nstatic String dive() {\nreturn DEFAULT; // k4\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code compiles without issue."
      }, {
        "code": "B",
        "value": "The code does not compile because of line k1."
      }, {
        "code": "C",
        "value": "The code does not compile because of line k2."
      }, {
        "code": "D",
        "value": "The code does not compile because of line k3."
      }, {
        "code": "E",
        "value": "The code does not compile because of line k4."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "27. C. The stroke() method is static, which means it cannot access the\ninstance method breath() on line k2, making option C correct."
      }
    },
    "28": {
      "nbr": 28,
      "value": "Which is the first line to fail to compile?\nclass Tool {\nprivate void repair() {} // r1\nvoid use() {} // r2\n}\nclass Hammer extends Tool {\nprivate int repair() { return 0; } // r3\nprivate void use() {} // r4\npublic void bang() {} // r5\n}",
      "responses": [{
        "code": "A",
        "value": "r1"
      }, {
        "code": "B",
        "value": "r2"
      }, {
        "code": "C",
        "value": "r3"
      }, {
        "code": "D",
        "value": "r4"
      }, {
        "code": "E",
        "value": "r5"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "28. D. The Hammer class is a subclass of the Tool class. The repair() method\ncan be declared in the Hammer subclass with a different return type because\nthe parent method is not inherited. For these reasons, options A and C are\nincorrect. On the other hand, the use() method is package‐private in Tool,\nwith the overridden version in Hammer reducing the visibility to private.\nThis is an invalid override, making option D correct. The rest of the lines\ncompile without issue."
      }
    },
    "29": {
      "nbr": 29,
      "value": "Which modifier can be applied to an abstract interface method?",
      "responses": [{
        "code": "A",
        "value": "final"
      }, {
        "code": "B",
        "value": "interface"
      }, {
        "code": "C",
        "value": "protected"
      }, {
        "code": "D",
        "value": "void"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "29. E. Methods cannot be both abstract and final, making option A\nincorrect. Abstract interface methods are always public, making option C\nincorrect. Finally, interface and void are not modifiers on a method,\nmaking options B and D incorrect. Therefore, option E is the answer."
      }
    },
    "30": {
      "nbr": 30,
      "value": "What is the output of the Plant program?\nclass Bush extends Plant {\nString type = \"bush\";\n}\npublic class Plant {\nString type = \"plant\";\npublic static void main(String[] args) {\nPlant w1 = new Bush();\nBush w2 = new Bush();\nPlant w3 = w2;\nSystem.out.print(w1.type+\",\"+w2.type+\",\"+w3.type);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "plant,bush,plant"
      }, {
        "code": "B",
        "value": "plant,bush,bush"
      }, {
        "code": "C",
        "value": "bush,plant,bush"
      }, {
        "code": "D",
        "value": "bush,bush,bush"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "30. A. While both objects are instances of Bush, we are not calling methods in\nthis example. Virtual method invocation works only for methods, not\ninstance variables. For instance variables, Java looks at the type of the\nreference and calls the appropriate variable based on the reference. Based\non the reference types of the three variables (Plant, Bush, Plant), option A\nis correct."
      }
    },
    "31": {
      "nbr": 31,
      "value": "Which statements can accurately fill in the blanks in this table? (Choose\ntwo.)\nVariable\nType\nCan Be Called Within the Class from What Type of\nMethod?\nInstance Blank 1: _____________\nstatic Blank 2: _____________",
      "responses": [{
        "code": "A",
        "value": "Blank 1: an instance method only"
      }, {
        "code": "B",
        "value": "Blank 1: a static method only"
      }, {
        "code": "C",
        "value": "Blank 1: an instance or static method"
      }, {
        "code": "D",
        "value": "Blank 2: an instance method only"
      }, {
        "code": "E",
        "value": "Blank 2: a static method only"
      }, {
        "code": "F",
        "value": "Blank 2: an instance or static method"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "F"
        ],
        "explanation": "31. A,F. An instance variable can be referenced only from instance methods in\nthe class, making option A correct. A static variable can be referenced\nfrom any method. Therefore, option F is correct."
      }
    },
    "32": {
      "nbr": 32,
      "value": "What is the correct order of statements for a Java class file?",
      "responses": [{
        "code": "A",
        "value": "import statements, package statement, class declaration"
      }, {
        "code": "B",
        "value": "package statement, class declaration, import statements"
      }, {
        "code": "C",
        "value": "class declaration, import statements, package statement"
      }, {
        "code": "D",
        "value": "package statement, import statements, class declaration"
      }, {
        "code": "E",
        "value": "import statements, class declaration, package statement"
      }, {
        "code": "F",
        "value": "class declaration, package statement, import statements"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "32. D. Java classes are defined in this order: package statement, import\nstatements, class declaration. That makes option D the only correct answer.\nNote that not all of these statements are required. For example, a class may\nnot have a package statement, but if it does, it must come first in the file."
      }
    },
    "33": {
      "nbr": 33,
      "value": "What is true of the following code? (Choose three.)\n1: class Penguin {\n2: enum Baby { EGG }\n3: static class Chick {\n4: enum Baby { EGG }\n5: }\n6: public static void main(String[] args) {\n7: boolean match = false;\n8: Baby egg = Baby.EGG;\n9: switch (egg) {\n10: case EGG:\n11: match = true;\n12: }\n13: }\n14: }",
      "responses": [{
        "code": "A",
        "value": "It compiles as is."
      }, {
        "code": "B",
        "value": "It does not compile as is."
      }, {
        "code": "C",
        "value": "Removing line 2 would create an additional compiler error."
      }, {
        "code": "D",
        "value": "Removing line 2 would not create an additional compiler error."
      }, {
        "code": "E",
        "value": "Removing the static modifier on line 3 would create an additional\ncompiler error."
      }, {
        "code": "F",
        "value": "Removing the static modifier on line 3 would not create an\nadditional compiler error."
      }
      ],
      "answer": {
        "codes": [
          "A",
          " C",
          " E"
        ],
        "explanation": "33. A, C, E. The code does compile as is, making option A correct. Removing\nline 2 would cause a compiler error in the main() method since the enum\ninside Chick is not referenced. This makes option C the next answer.\nFinally, option E is the final answer because an enum cannot be defined in a\nnon‐static inner class. Only top‐level types and static nested classes can\ndefine static members other than static constants, and enums are\nimplicitly static."
      }
    },
    "34": {
      "nbr": 34,
      "value": "Which are true of the following? (Choose two.)\npackage beach;\npublic class Sand {\nprivate static int numShovels;\nprivate int numRakes;\npublic static int getNumShovels() {\nreturn numShovels;\n}\npublic static int getNumRakes() {\nreturn numRakes;\n}\npublic Sand() {\nSystem.out.print(\"a\");\n}\npublic void Sand() {\nSystem.out.print(\"b\");\n}\npublic void run() {\nnew Sand();\nSand();\n}\npublic static void main(String… args) {\nnew Sand().run();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code compiles."
      }, {
        "code": "B",
        "value": "One line doesn't compile."
      }, {
        "code": "C",
        "value": "Two lines don't compile."
      }, {
        "code": "D",
        "value": "If any constructors and/or methods that do not compile are removed,\nthe remaining code prints a."
      }, {
        "code": "E",
        "value": "If the code compiles or if any constructors/methods that do not\ncompile are removed, the remaining code prints ab."
      }, {
        "code": "F",
        "value": "If the code compiles or if any constructors/methods that do not\ncompile are removed, the remaining code prints aab."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "34. B,F. A static method can access static variables, but not instance\nvariables. The getNumRakes() method does not compile, so option B is\ncorrect.\nThe main() method calls the constructor, which outputs a. Then the main\nmethod calls the run() method. The run() method calls the constructor\nagain, which outputs a again. Then the run() method calls the Sand()\nmethod, which happens to have the same name as the constructor. This\noutputs b. Therefore, option F is correct."
      }
    },
    "35": {
      "nbr": 35,
      "value": "Which of the following class types cannot be marked final or abstract?",
      "responses": [{
        "code": "A",
        "value": "static nested class."
      }, {
        "code": "B",
        "value": "Local class."
      }, {
        "code": "C",
        "value": "Anonymous class."
      }, {
        "code": "D",
        "value": "Member inner class."
      }, {
        "code": "E",
        "value": "All of the above can be marked final or abstract."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "35. C. While an anonymous class can extend another class or implement an\ninterface, it cannot be declared final or abstract since it has no class\ndefinition. For this reason, option C is correct. The other classes may be\ndeclared final or abstract since they have a class definition."
      }
    },
    "36": {
      "nbr": 36,
      "value": "Fill in the blanks: The ___________________ access modifier allows\naccess to everything the ___________________ access modifier does and\nmore. (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "package‐private, protected"
      }, {
        "code": "B",
        "value": "package‐private, public"
      }, {
        "code": "C",
        "value": "protected, package‐private"
      }, {
        "code": "D",
        "value": "protected, public"
      }, {
        "code": "E",
        "value": "public, package‐private"
      }, {
        "code": "F",
        "value": "public, protected"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E",
          "F"
        ],
        "explanation": "36. C,E,F. The public access modifier is the broadest, making options E and\nF correct. Package‐private access limits references to those in the same\npackage. The protected access modifier adds on subclass access, making\noption C correct."
      }
    },
    "37": {
      "nbr": 37,
      "value": "Which is the first line containing a compiler error?\nvar title = \"Weather\"; // line x1\nvar hot = 100, var cold = 20; // line x2\nvar f = 32, int c = 0; // line x3",
      "responses": [{
        "code": "A",
        "value": "x1"
      }, {
        "code": "B",
        "value": "x2"
      }, {
        "code": "C",
        "value": "x3"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "37. B. Java does not allow multiple variables to be declared in the same\nstatement using local variable type inference. Lines x2 and x3 both have\ncompiler errors. Since the question asks about the first line with a compiler\nerror, option B is the answer."
      }
    },
    "38": {
      "nbr": 38,
      "value": "How many of the following members of Telephone interface are public?\npublic interface Telephone {\nstatic int call() { return 1; }\ndefault void dial() {}\nlong answer();\nString home = \"555-555-5555\";\n}",
      "responses": [{
        "code": "A",
        "value": "Zero."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "38. E. All four members of the Telephone interface are implicitly public,\nmaking option E correct. Only private and private static interface\nmethods are not public, and they must be explicitly marked private."
      }
    },
    "39": {
      "nbr": 39,
      "value": "Which best describes what the new keyword does?",
      "responses": [{
        "code": "A",
        "value": "Creates a copy of an existing object and treats it as a new one."
      }, {
        "code": "B",
        "value": "Creates a new primitive."
      }, {
        "code": "C",
        "value": "Instantiates a new object."
      }, {
        "code": "D",
        "value": "Switches an object reference to a new one."
      }, {
        "code": "E",
        "value": "The behavior depends on the class implementation."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "39. C. The new keyword is used to call the constructor for a class and\ninstantiate an instance of the class, making option C correct. A primitive\ncannot be created using the new keyword, so option B is incorrect. Dealing\nwith references happens after the object created by new is returned. The\nother options are invalid."
      }
    },
    "40": {
      "nbr": 40,
      "value": "How many lines will not compile?\n12: public void printVarargs(String… names) {\n13: System.out.println(Arrays.toString(names));\n14: }\n15: public void printArray(String[] names) {\n16: System.out.println(Arrays.toString(names));\n17: }\n18: public void stormy() {\n19: printVarargs(\"Arlene\");\n20: printVarargs(new String[]{\"Bret\"});\n21: printVarargs(null);\n22: printArray (\"Cindy\");\n23: printArray (new String[]{\"Don\"});\n24: printArray (null);\n25: }",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "40. B. From within a method, an array or varargs parameter is treated the\nsame. However, there is a difference from the caller's point of view. A\nvarargs parameter can receive either an array or individual values, making\nline 19 and 20 compile. However, an array parameter can take only an\narray, which permits line 23 but prevents line 22 from compiling. Both lines\n21 and 24 compile because null can be passed to a method taking an array\nor a varargs. Since there is only one line that doesn't compile, option B is\nthe answer."
      }
    },
    "41": {
      "nbr": 41,
      "value": "Which of the following can include a static method in its definition?\n(Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Interface"
      }, {
        "code": "B",
        "value": "Anonymous class"
      }, {
        "code": "C",
        "value": "Abstract class"
      }, {
        "code": "D",
        "value": "Member inner class"
      }, {
        "code": "E",
        "value": "Local class"
      }, {
        "code": "F",
        "value": "static nested class"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "F"
        ],
        "explanation": "41. A,C,F. Both abstract classes and interfaces can include static methods,\nso options A and C are correct. Of all the nested class types, only static\nnested classes can include static methods, making option F correct, and\noptions B, D, and E incorrect."
      }
    },
    "42": {
      "nbr": 42,
      "value": "What is the minimum number of lines that need to be removed to make this\ncode compile?\n@FunctionalInterface\npublic interface Play {\npublic static void baseball() {}\nprivate static void soccer() {}\ndefault void play() {}\nvoid fun();\n}",
      "responses": [{
        "code": "A",
        "value": "1."
      }, {
        "code": "B",
        "value": "2."
      }, {
        "code": "C",
        "value": "3."
      }, {
        "code": "D",
        "value": "4."
      }, {
        "code": "E",
        "value": "The code compiles as is."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "42. E. This code is already a functional interface and compiles without any\nchanges. The Play interface has a single abstract method: fun(). The\nother methods have a method body, which shows they are not abstract."
      }
    },
    "43": {
      "nbr": 43,
      "value": "Fill in the blanks: A class that defines an instance variable with the same\nname as a variable in the parent class is referred to as\n___________________ a variable, while a class that defines a static\nmethod with the same signature as a static method in a parent class is\nreferred to as ___________________ a method.",
      "responses": [{
        "code": "A",
        "value": "hiding, overriding"
      }, {
        "code": "B",
        "value": "overriding, hiding"
      }, {
        "code": "C",
        "value": "masking, masking"
      }, {
        "code": "D",
        "value": "hiding, masking"
      }, {
        "code": "E",
        "value": "replacing, overriding"
      }, {
        "code": "F",
        "value": "hiding, hiding"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "43. F. Both of these descriptions refer to variable and static method hiding,\nrespectively, making option F correct. Only instance methods can be\noverridden, making options A and B incorrect. Options C, D, and E are also\nincorrect because replacing and masking are not real terms in this context."
      }
    },
    "44": {
      "nbr": 44,
      "value": "What change is needed to make Secret well encapsulated?\nimport java.util.*;\npublic class Secret {\nprivate int number = new Random().nextInt(10);\npublic boolean guess(int candidate) {\nreturn number == candidate;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Change number to use a protected access modifier."
      }, {
        "code": "B",
        "value": "Change number to use a public access modifier."
      }, {
        "code": "C",
        "value": "Declare a private constructor."
      }, {
        "code": "D",
        "value": "Declare a public constructor."
      }, {
        "code": "E",
        "value": "Remove the guess method."
      }, {
        "code": "F",
        "value": "None. It is already well encapsulated."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "44. F. This class is a good example of encapsulation. It has a private instance\nvariable and is accessed by a public method. No changes are needed to\nencapsulate it, and option F is correct."
      }
    },
    "45": {
      "nbr": 45,
      "value": "Which of the following are the best reasons for creating a public static\ninterface method? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Allow static methods to access instance methods."
      }, {
        "code": "B",
        "value": "Allow an interface to define a method at the class level."
      }, {
        "code": "C",
        "value": "Provide an implementation that a class implementing the interface can\noverride."
      }, {
        "code": "D",
        "value": "Improve code reuse within the interface."
      }, {
        "code": "E",
        "value": "Add backward compatibility to existing interfaces."
      }, {
        "code": "F",
        "value": "Improve encapsulation of the interface."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "45. B,D. Option A is incorrect because static methods cannot call instance\nmethods directly. Options B and D are correct and are the primary reasons\nto create a static interface method. Options C and E are incorrect and\ndescribe attributes of a default method. Option F applies only to private\nstatic interface methods, not public ones."
      }
    },
    "46": {
      "nbr": 46,
      "value": "What is the output of the following application?\npackage space;\npublic class Bottle {\npublic static class Ship {\nprivate enum Sail { // w1\nTALL {protected int getHeight() {return 100;}},\nSHORT {protected int getHeight() {return 2;}};\nprotected abstract int getHeight();\n}\npublic Sail getSail() {\nreturn Sail.TALL;\n}\n}\npublic static void main(String[] stars) {\nvar bottle = new Bottle();\nShip q = bottle.new Ship(); // w2\nSystem.out.print(q.getSail());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "TALL"
      }, {
        "code": "B",
        "value": "The code does not compile because of line w1."
      }, {
        "code": "C",
        "value": "The code does not compile because of line w2."
      }, {
        "code": "D",
        "value": "The code does not compile for another reason."
      }, {
        "code": "E",
        "value": "The code compiles, but the application does not produce any output at\nruntime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "46. C. The Bottle class includes a static nested class Ship that must be\ninstantiated in a static manner. Line w2 uses an instance of Bottle to\ninstantiate the Ship. Therefore, line w2 does not compile, and option C is\nthe correct answer. Note that if Ship were changed to be a member inner\nclass, the code would still not compile since a member inner class cannot\ninclude static members and enums are inherently static."
      }
    },
    "47": {
      "nbr": 47,
      "value": "Which of the following is not a valid order for elements within a class?",
      "responses": [{
        "code": "A",
        "value": "Constructor, instance variables, method declarations"
      }, {
        "code": "B",
        "value": "Instance variables, static initializer constructor, method declarations"
      }, {
        "code": "C",
        "value": "Method declarations, instance variables, constructor"
      }, {
        "code": "D",
        "value": "Instance initializer, constructor, instance variables, constructor"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "47. E. The instance variables, constructor, instance and static initializers,\nand method declarations can appear in any order within a class declaration."
      }
    },
    "48": {
      "nbr": 48,
      "value": "Which line of code, inserted at line p1, causes the application to print 5?\npackage games;\npublic class Jump {\nprivate int rope = 1;\nprotected boolean outside;\npublic Jump() {\n// line p1\noutside = true;\n}\npublic Jump(int rope) {\nthis.rope = outside ? rope : rope+1;\n}\npublic static void main(String[] bounce) {\nSystem.out.print(new Jump().rope);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "this(4);"
      }, {
        "code": "B",
        "value": "new Jump(4);"
      }, {
        "code": "C",
        "value": "this(5);"
      }, {
        "code": "D",
        "value": "rope = 4;"
      }, {
        "code": "E",
        "value": "super(4);"
      }, {
        "code": "F",
        "value": "super(5);"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "48. A. First, all of the lines compile, but they produce various different results.\nRemember that the default initialization of a boolean instance variable is\nfalse, so outside is false at line p1. Therefore, this(4) will cause rope\nto be set to 5, while this(5) will cause rope to be set to 6. Since 5 is the\nnumber we are looking for, option A is correct, and option C is incorrect.\nOption B is incorrect. While the statement does create a new instance of\nJump, with rope having a value of 5, that instance is nested, and the value of\nrope does not affect the surrounding instance of Jump that the constructor\nwas called in. Option D is also incorrect. The value assigned to rope is 4,\nnot the target 5. Options E and F do not compile because the superclass is\nObject, which does not have a constructor taking an int."
      }
    },
    "49": {
      "nbr": 49,
      "value": "Which of the following is not a reason to use encapsulation when designing\na class? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Improve security."
      }, {
        "code": "B",
        "value": "Increase concurrency and improve performance."
      }, {
        "code": "C",
        "value": "Maintain class data integrity of data elements."
      }, {
        "code": "D",
        "value": "Prevent users from modifying the internal attributes of a class."
      }, {
        "code": "E",
        "value": "Prevent variable state from changing."
      }, {
        "code": "F",
        "value": "Promote usability by other developers."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "49. B,E. Option A is true because encapsulation improves security because\ninstance variables cannot be accessed directly. Implementing encapsulation\nprevents internal attributes of a class from being modified directly, so\noption D is a true statement. By preventing access to internal attributes, we\ncan also maintain class data integrity between elements, making option C a\ntrue statement. Option F is also a true statement about encapsulation, since\nwell‐encapsulated classes are often easier to use. Option B is an incorrect\nstatement. Encapsulation makes no guarantees about performance and\nconcurrency. Option E is also an incorrect statement because it describes\nimmutability."
      }
    },
    "50": {
      "nbr": 50,
      "value": "Which statement about the following program is correct? (Choose two.)\npackage ballroom;\nclass Leader {}\nclass Follower {}\nabstract class Dancer {\npublic Leader getPartner() { return new Leader(); }\nabstract public Leader getPartner(int count); // u1\n}\npublic abstract class SwingDancer extends Dancer {\npublic Leader getPartner(int x) { return null; }\npublic Follower getPartner() { // u2\nreturn new Follower(); // u3\n}\npublic static void main(String[] args) {\nnew SwingDancer().getPartner(); // u4\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code does not compile because of line u1."
      }, {
        "code": "B",
        "value": "The code does not compile because of line u2."
      }, {
        "code": "C",
        "value": "The code does not compile because of line u3."
      }, {
        "code": "D",
        "value": "The code does not compile because of line u4."
      }, {
        "code": "E",
        "value": "At least three of the classes compile without issue."
      }, {
        "code": "F",
        "value": "All of the classes compile without issue."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "50. B,D. Line u2 does not compile because getPartner() is overridden with a\nreturn type that is not covariant, as Follower is not the same type nor a\nsubtype of the Leader class. Line u4 also does not compile because\nSwingDancer is marked abstract and cannot be instantiated directly. For\nthese reasons, options B and D are the correct answers. The rest of the code\ncompiles without issue."
      }
    },
    "51": {
      "nbr": 51,
      "value": "Which is not a true statement given this diagram? Assume all classes are\npublic.",
      "responses": [{
        "code": "A",
        "value": "Instance methods in the Blanket class can call the Flashlight class's\nturnOn()."
      }, {
        "code": "B",
        "value": "Instance methods in the Flashlight class can call the Flashlight\nclass's replaceBulb()."
      }, {
        "code": "C",
        "value": "Instance methods in the Phone class can call the Blanket class's\nwash()."
      }, {
        "code": "D",
        "value": "Instance methods in the Tent class can call the Tent class's pitch()."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "51. C. Option A is allowed because the turnOn() method is public and can\nbe called from anywhere. Options B and D are allowed since the method is\nin the same class, which is always allowed! Option C is not allowed\nbecause wash() is a package‐private method in another package. Option C\nis the correct answer."
      }
    },
    "52": {
      "nbr": 52,
      "value": "Given the diagram in the previous question, how many of the classes shown\nin the diagram can call the display() method?",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "52. C. The display() method has protected access. This means it can be\naccessed by instance methods in the same package and any subclasses.\nThere are no subclasses in this example, so we only need to count the\nclasses in the same package. Option C is correct because Flashlight and\nPhone are in the package."
      }
    },
    "53": {
      "nbr": 53,
      "value": "Which of the following statements are correct? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Java allows multiple inheritance using two abstract classes."
      }, {
        "code": "B",
        "value": "Java allows multiple inheritance using two interfaces."
      }, {
        "code": "C",
        "value": "Java does not allow multiple inheritance."
      }, {
        "code": "D",
        "value": "An interface can extend another interface."
      }, {
        "code": "E",
        "value": "An interface can implement another interface."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "53. B,D. While Java does not allow a class to extend more than one class, it\ndoes allow a class to implement any number of interfaces. Multiple\ninheritance is, therefore, only allowed via interfaces, making option B\ncorrect. Interfaces can extend other interfaces, making option D the other\nanswer."
      }
    },
    "54": {
      "nbr": 54,
      "value": "Which statement about the following code is correct?\npublic class Dress {\nint size = 10;\ndefault int getSize() {\ndisplay();\nreturn size;\n}\nstatic void display() {\nSystem.out.print(\"What a pretty outfit!\");\n}\nprivate int getLength() {\ndisplay();\nreturn 15;\n}\nprivate static void tryOn() {\ndisplay();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code contains an invalid constant."
      }, {
        "code": "B",
        "value": "The method getSize() does not compile."
      }, {
        "code": "C",
        "value": "The method getLength() does not compile."
      }, {
        "code": "D",
        "value": "The method tryOn() does not compile."
      }, {
        "code": "E",
        "value": "The code compiles."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "54. B. The Dress type is declared as a class, not an interface. For this\nreason, it cannot contain the default method getSize(), making option B\ncorrect. The rest of the methods compile within the class declaration\nwithout issue."
      }
    },
    "55": {
      "nbr": 55,
      "value": "What is the output of the following application?\npackage ocean;\nabstract interface CanSwim {\npublic void swim(final int distance);\n}\npublic class Turtle {\nfinal int distance = 2;\npublic static void main(String[] seaweed) {\nfinal int distance = 3;\nCanSwim seaTurtle = {\nfinal int distance = 5;\n@Override\npublic void swim(final int distance) {\nSystem.out.print(distance);\n}\n};\nseaTurtle.swim(7);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "2"
      }, {
        "code": "B",
        "value": "3"
      }, {
        "code": "C",
        "value": "5"
      }, {
        "code": "D",
        "value": "7"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "55. E. The main() method attempts to define an anonymous class instance but\nfails to provide the class or interface name, or use the new keyword. The\nright‐hand side of the assignment to the seaTurtle variable should start\nwith new CanSwim(). For this reason, option E is the correct answer. If the\ncode was corrected with the proper declaration, then the program would\noutput 7 at runtime."
      }
    },
    "56": {
      "nbr": 56,
      "value": "What is the output of the following application?\npackage pet;\npublic class Puppy {\npublic static int wag = 5; // q1\npublic void Puppy(int wag) { // q2\nthis.wag = wag;\n}\npublic static void main(String[] tail) {\nSystem.out.print(new Puppy(2).wag); // q3\n}\n}",
      "responses": [{
        "code": "A",
        "value": "2"
      }, {
        "code": "B",
        "value": "5"
      }, {
        "code": "C",
        "value": "The first line with a compiler error is line q1."
      }, {
        "code": "D",
        "value": "The first line with a compiler error is line q2."
      }, {
        "code": "E",
        "value": "The first line with a compiler error is line q3."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "56. E. The Puppy class does not declare a constructor, so the default noargument\nconstructor is automatically inserted by the compiler. What looks\nlike a constructor in the class is actually a method that has a return type of\nvoid. Therefore, the line in the main() method to create the new Puppy(2)\nobject does not compile, since there is no constructor capable of taking an\nint value, making option E the correct answer."
      }
    },
    "57": {
      "nbr": 57,
      "value": "Given the following method signature, which classes can call it?\nvoid run(String government)",
      "responses": [{
        "code": "A",
        "value": "Classes in other packages"
      }, {
        "code": "B",
        "value": "Classes in the same package"
      }, {
        "code": "C",
        "value": "Subclasses in a different package"
      }, {
        "code": "D",
        "value": "All classes"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "57. B. The method signature has package‐private, or default, access; therefore,\nit is accessible to classes in the same package, making option B the correct\nanswer."
      }
    },
    "58": {
      "nbr": 58,
      "value": "Which is the first declaration to not compile?\npackage desert;\ninterface CanBurrow {\npublic abstract void burrow();\n}\n@FunctionalInterface interface HasHardShell\nextends CanBurrow {}\nabstract class Tortoise implements HasHardShell {\npublic abstract int toughness();\n}\npublic class DesertTortoise extends Tortoise {\npublic int toughness() { return 11; }\n}",
      "responses": [{
        "code": "A",
        "value": "The CanBurrow interface does not compile."
      }, {
        "code": "B",
        "value": "The HasHardShell interface does not compile."
      }, {
        "code": "C",
        "value": "The Tortoise interface does not compile."
      }, {
        "code": "D",
        "value": "The DesertTortoise interface does not compile."
      }, {
        "code": "E",
        "value": "All of the interfaces compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "58. D. First, both CanBurrow and HasHardShell compile as functional\ninterfaces since they contain exactly one abstract method, although only\nthe latter uses the optional @FunctionalInterface annotation. The\ndeclarations of these two interfaces, along with the abstract class\nTortoise, compile without issue, making options A, B, and C incorrect.\nThe class DesertTortoise inherits two abstract methods, one from the\ninterface CanBurrow and the other from the abstract parent class\nTortoise. Since the class implements only one of them and the class is\nconcrete, the class declaration of DesertTortoise fails to compile, making\noption D the correct answer."
      }
    },
    "59": {
      "nbr": 59,
      "value": "Which is the first line to not compile?\ninterface Building {\ndefault Double getHeight() { return 1.0; } // m1\n}\ninterface Office {\npublic default String getHeight() { return null; } // m2\n}\nabstract class Tower implements Building, Office {} // m3\npublic class Restaurant extends Tower {} // m4",
      "responses": [{
        "code": "A",
        "value": "Line m1"
      }, {
        "code": "B",
        "value": "Line m2"
      }, {
        "code": "C",
        "value": "Line m3"
      }, {
        "code": "D",
        "value": "Line m4"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "59. C. The interface declarations compile without issue. When inheriting two\ndefault methods with the same signature, the Tower class is required to\noverride both methods even if the class is marked abstract. For this\nreason, line m3 is the first line that does not compile, and option C is correct.\nNote that there is no possible overridden method that can fulfill both\ninherited default methods since the return types are not covariant."
      }
    },
    "60": {
      "nbr": 60,
      "value": "What is the output of the following code snippet?\nString tree = \"pine\";\nint count = 0;\nif (tree.equals(\"pine\")) {\nint height = 55;\ncount = count + 1;\n}\nSystem.out.print(height + count);",
      "responses": [{
        "code": "A",
        "value": "1"
      }, {
        "code": "B",
        "value": "55"
      }, {
        "code": "C",
        "value": "56"
      }, {
        "code": "D",
        "value": "It does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "60. D. The height variable is declared within the if‐then statement block.\nTherefore, it cannot be referenced outside the if statement, and the code\ndoes not compile."
      }
    },
    "61": {
      "nbr": 61,
      "value": "Which of the following are valid comments in Java? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "/****** TODO */"
      }, {
        "code": "B",
        "value": "# Fix this bug later"
      }, {
        "code": "C",
        "value": "' Error closing pod bay doors"
      }, {
        "code": "D",
        "value": "/ Invalid record /"
      }, {
        "code": "E",
        "value": "/* Page not found */"
      }, {
        "code": "F",
        "value": "// IGNORE ME"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E",
          "F"
        ],
        "explanation": "61. A,E,F. Java supports three types of comments: single‐line (//), multiline\n(/* */), and Javadoc (/** **/), making options A, E, and F correct. The\nother options may be comments in other languages, but not in Java."
      }
    },
    "62": {
      "nbr": 62,
      "value": "Which of the following modifiers can both be applied to a method? (Choose\nthree.)",
      "responses": [{
        "code": "A",
        "value": "private and final"
      }, {
        "code": "B",
        "value": "abstract and final"
      }, {
        "code": "C",
        "value": "static and private"
      }, {
        "code": "D",
        "value": "private and abstract"
      }, {
        "code": "E",
        "value": "abstract and static"
      }, {
        "code": "F",
        "value": "static and protected"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "F"
        ],
        "explanation": "62. A,C,F. An abstract method is one that will be implemented by a\nsubclass. For this reason, it cannot be combined with final or private, as\nboth prevent a method from being overridden, making options B and D\nincorrect. An abstract method can also not be marked static, since\nstatic members belong to the class level, not an instance, making option E\nincorrect. Options A, C, and F are the correct answers. Note that marking a\nprivate method final has no practical implication, although it is allowed."
      }
    },
    "63": {
      "nbr": 63,
      "value": "Given the following class, what should be inserted into the two blanks to\nensure the class data is properly encapsulated?\npackage storage;\npublic class Box {\npublic String stuff;\n__________ String __________() {\nreturn stuff;\n}\npublic void setStuff(String stuff) {\nthis.stuff = stuff;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "private and getStuff"
      }, {
        "code": "B",
        "value": "private and isStuff"
      }, {
        "code": "C",
        "value": "public and getStuff"
      }, {
        "code": "D",
        "value": "public and isStuff"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "63. E. The class data, stuff, is declared public, allowing any class to modify\nthe stuff variable and making the implementation inherently unsafe for\nencapsulation. Therefore, there are no values that can be placed in the two\nblanks to ensure the class properly encapsulates its data, making option E\ncorrect. Note that if stuff were declared private, options A, B, C, and D\nwould all be correct. Encapsulation does not require any specific method\nnames, just that the internal attributes are protected from outside access,\nwhich all of these sets of values do achieve."
      }
    },
    "64": {
      "nbr": 64,
      "value": "How many rows of the following table contain an error?\nInterface member Membership type Requires method body?\nStatic method Class Yes\nPrivate non‐static method Class Yes\nAbstract method Instance No\nDefault method Instance No\nDefault method Instance No\nPrivate static method Class Yes",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "64. C. The second row is incorrect, as private methods belong to an instance,\nnot the class. The fourth row is also incorrect, as default methods require a\nmethod body. The rest of the rows are correct, making option C correct."
      }
    },
    "65": {
      "nbr": 65,
      "value": "Fill in the blanks: ___________________ is used to call a constructor in the\nparent class, while ___________________ is used to reference a member of\nthe parent class.",
      "responses": [{
        "code": "A",
        "value": "super and this()"
      }, {
        "code": "B",
        "value": "super and super()"
      }, {
        "code": "C",
        "value": "super() and this"
      }, {
        "code": "D",
        "value": "super() and super"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "65. D. The super() statement is used to call a constructor in the parent class,\nwhile super is used to reference a member of the parent class. The this()\nstatement is used to call a constructor in the current class, while this is\nused to reference a member of the current class. For these reasons, option D\nis the correct answer."
      }
    },
    "66": {
      "nbr": 66,
      "value": "What is the output of the Watch program?\n1: class SmartWatch extends Watch {\n2: private String getType() { return \"smart watch\"; }\n3: public String getName(String suffix) {\n4: return getType() + suffix;\n5: }\n6: }\n7: public class Watch {\n8: private String getType() { return \"watch\"; }\n9: public String getName(String suffix) {\n10: return getType() + suffix;\n11: }\n12: public static void main(String[] args) {\n13: var watch = new Watch();\n14: var smartWatch = new SmartWatch();\n15: System.out.print(watch.getName(\",\"));\n16: System.out.print(smartWatch.getName(\"\"));\n17: }\n18: }",
      "responses": [{
        "code": "A",
        "value": "smart watch,watch"
      }, {
        "code": "B",
        "value": "watch,smart watch"
      }, {
        "code": "C",
        "value": "watch,watch"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "An exception is printed at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "66. B. Line 15 calls the method on line 9 since it is a Watch object. That\nreturns watch, making option A incorrect. Line 16 calls the method on line\n3 since it is a SmartWatch object and the method is properly overridden.\nThat returns smart watch, so option B is the answer, and option C is\nincorrect."
      }
    },
    "67": {
      "nbr": 67,
      "value": "What is the output of the Movie program?\npackage theater;\nclass Cinema {\nprivate String name = \"Sequel\";\npublic Cinema(String name) {\nthis.name = name;\n}\n}\npublic class Movie extends Cinema {\nprivate String name = \"adaptation\";\npublic Movie(String movie) {\nthis.name = \"Remake\";\n}\npublic static void main(String[] showing) {\nSystem.out.print(new Movie(\"Trilogy\").name);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Sequel"
      }, {
        "code": "B",
        "value": "Trilogy"
      }, {
        "code": "C",
        "value": "Remake"
      }, {
        "code": "D",
        "value": "Adaptation"
      }, {
        "code": "E",
        "value": "null"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "67. F. The Cinema class defines a constructor that takes a String value, which\nmeans the compiler does not insert the default no‐argument constructor.\nTherefore, it is not available in the Movie constructor, and an explicit\nconstructor must be called with super(). Since this is not done, the Movie\nconstructor does not compile, making option F the correct answer. The rest\nof the code compiles without issue."
      }
    },
    "68": {
      "nbr": 68,
      "value": "Where can a final instance variable be assigned a value? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Instance initializer"
      }, {
        "code": "B",
        "value": "static initializer"
      }, {
        "code": "C",
        "value": "Instance method"
      }, {
        "code": "D",
        "value": "On the line it is declared"
      }, {
        "code": "E",
        "value": "Class constructor"
      }, {
        "code": "F",
        "value": "static method"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "E"
        ],
        "explanation": "68. A,D,E. A final instance must be assigned a value (exactly once) on the\nline it is declared, in an instance initializer, or in a constructor. This makes\noptions A, D, and E correct."
      }
    },
    "69": {
      "nbr": 69,
      "value": "What is the output of the following code?\npublic class Bunny {\nstatic interface Rabbit { }\nstatic class FlemishRabbit implements Rabbit { }\nprivate static void hop(Rabbit r) {\nSystem.out.print(\"hop\");\n}\nprivate static void hop(FlemishRabbit r) {\nSystem.out.print(\"HOP\");\n}\npublic static void main(String[] args) {\nRabbit r1 = new FlemishRabbit();\nFlemishRabbit r2 = new FlemishRabbit();\nhop(r1);\nhop(r2);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "hophop"
      }, {
        "code": "B",
        "value": "HOPhop"
      }, {
        "code": "C",
        "value": "hopHOP"
      }, {
        "code": "D",
        "value": "HOPHOP"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "69. C. This example deals with method signatures rather than polymorphism.\nSince the hop() methods are static, the precise method called depends on\nthe reference type rather than the actual type of the object. Since the first\nreference is Rabbit, the first value printed is hop. The second reference\nactually is FlemishRabbit, so HOP is printed, and option C is the answer."
      }
    },
    "70": {
      "nbr": 70,
      "value": "Which of the following results is not a possible output of this program?\npackage sea;\nenum Direction { north, south, east, west; };\npublic class Ship {\npublic static void main(String[] compass) {\nSystem.out.print(Direction.valueOf(compass[0]));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "WEST is printed."
      }, {
        "code": "B",
        "value": "south is printed."
      }, {
        "code": "C",
        "value": "An ArrayIndexOutOfBoundsException is thrown at runtime."
      }, {
        "code": "D",
        "value": "An IllegalArgumentException is thrown at runtime."
      }, {
        "code": "E",
        "value": "All of the above are possible."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "70. A. If the program is called with a single input south, then south would be\nprinted at runtime. If the program is called with no input, then the compass\narray would be of size zero and an ArrayIndexOutOfBoundsException\nwould be thrown at runtime. Finally, if the program is called with a string\nthat does not match one of the values in Direction, then an\nIllegalArgumentException would be thrown at runtime. The only result\nnot possible is WEST, since the enum value is in lowercase, making option A\nthe correct answer."
      }
    },
    "71": {
      "nbr": 71,
      "value": "Which statement about encapsulation is not true?",
      "responses": [{
        "code": "A",
        "value": "Encapsulation allows putting extra logic in the getter and setter\nmethods."
      }, {
        "code": "B",
        "value": "Encapsulation can use immutable instance variables in the\nimplementation."
      }, {
        "code": "C",
        "value": "Encapsulation causes two classes to be more tightly tied together."
      }, {
        "code": "D",
        "value": "Encapsulation makes it easier to change the instance variables in the\nfuture."
      }, {
        "code": "E",
        "value": "All of the above are true."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "71. C. Encapsulation doesn't allow callers access to the instance variables,\nwhich makes it easier to change the code. The instance variables can be any\ntype, which means they can be mutable or immutable. There are not\nconstraints on the implementation of methods. The purpose of\nencapsulation is to lessen how tightly tied or coupled the classes are. Option\nC is the opposite of this, making it the answer."
      }
    },
    "72": {
      "nbr": 72,
      "value": "What is the output of the following application?\npackage radio;\npublic class Song {\npublic void playMusic() {\nSystem.out.print(\"Play!\");\n}\nprivate static void playMusic() {\nSystem.out.print(\"Music!\");\n}\nprivate static void playMusic(String song) {\nSystem.out.print(song);\n}\npublic static void main(String[] tracks) {\nnew Song().playMusic();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Play!"
      }, {
        "code": "B",
        "value": "Music!"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles, but the answer cannot be determined until runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "72. C. A class cannot contain two methods with the same method signature,\neven if one is static and the other is not. Therefore, the code does not\ncompile because the two declarations of playMusic() conflict with one\nanother, making option C the correct answer."
      }
    },
    "73": {
      "nbr": 73,
      "value": "Which of the following statements about overriding a method are correct?\n(Choose three.)",
      "responses": [{
        "code": "A",
        "value": "The return types must be covariant."
      }, {
        "code": "B",
        "value": "The access modifier of the method in the child class must be the same\nor narrower than the method in the superclass."
      }, {
        "code": "C",
        "value": "The return types must be the same."
      }, {
        "code": "D",
        "value": "A checked exception thrown by the method in the parent class must be\nthrown by the method in the child class."
      }, {
        "code": "E",
        "value": "A checked exception thrown by a method in the child class must be the\nsame or narrower than the exception thrown by the method in the\nparent class."
      }, {
        "code": "F",
        "value": "The access modifier of the method in the child class must be the same\nor broader than the method in the superclass."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E",
          "F"
        ],
        "explanation": "73. A,E,F. First, the return types of an overridden method must be covariant,\nmaking option A correct. They can be the same, but it is not required,\nmaking option C incorrect. Next, the access modifier must be the same or\nbroader in the child method, making option B incorrect and option F\ncorrect. Option D is incorrect as an overridden method is not required to\nthrow a checked exception declared in the parent version of the method. If\nit does declare a checked exception, it cannot be new or broader than the\nones declared in the superclass, making option E correct."
      }
    },
    "74": {
      "nbr": 74,
      "value": "How lines of the following code do not compile?\n10: interface Flavor {\n11: public default void happy() {\n12: printFlavor(\"Rocky road\");\n13: }\n14: private static void excited() {\n15: printFlavor(\"Peanut butter\");\n16: }\n17: private void printFlavor(String f) {\n18: System.out.println(\"Favorite Flavor is: \"+f);\n19: }\n20: public static void sad() {\n21: printFlavor(\"Butter pecan\");\n22: }\n23: }\n24: public class IceCream implements Flavor {\n25: @Override public void happy() {\n26: printFlavor(\"Cherry chocolate chip\");\n27: } }",
      "responses": [{
        "code": "A",
        "value": "None, they all compile"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five or more"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "74. D. A private non‐static interface method may only be accessed from\nother private or default methods declared within the interface. Lines 15\nand 21 do not compile because the private method is called within static\nmethods. Line 26 does not compile because a private interface method\ncannot be called in a method outside the interface declaration. Since these\nthree lines do not compile, option D is correct."
      }
    },
    "75": {
      "nbr": 75,
      "value": "Of the following four modifiers, choose the one that is not implicitly\napplied to all interface variables.",
      "responses": [{
        "code": "A",
        "value": "final"
      }, {
        "code": "B",
        "value": "abstract"
      }, {
        "code": "C",
        "value": "static"
      }, {
        "code": "D",
        "value": "public"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "75. B. Interface variables are implicitly public, static, and final. Variables\ncannot be declared as abstract in interfaces, nor in classes. Therefore,\noption B is the answer."
      }
    },
    "76": {
      "nbr": 76,
      "value": "Given the following method, what is the first line that does not compile?\npublic static void main(String[] args) {\nint Integer = 0; // k1\nInteger int = 0; // k2\nInteger ++; // k3\nint++; // k4\nint var = null; // k5\n}",
      "responses": [{
        "code": "A",
        "value": "k1"
      }, {
        "code": "B",
        "value": "k2"
      }, {
        "code": "C",
        "value": "k3"
      }, {
        "code": "D",
        "value": "k4"
      }, {
        "code": "E",
        "value": "k5"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "76. B. Integer is the name of a class in Java. While it is bad practice to use\nthe name of a class as your local variable name, this is legal. Therefore, k1\ndoes compile. It is not legal to use a reserved word as a variable name. All\nof the primitives including int are reserved words. Therefore, k2 does not\ncompile, and option B is the answer. Lines k4 and k5 don't compile either,\nbut the question asks about the first line to not compile."
      }
    },
    "77": {
      "nbr": 77,
      "value": "What is the result of compiling and executing the following class?\npublic class Tolls {\nprivate static int yesterday = 1;\nint tomorrow = 10;\npublic static void main(String[] args) {\nvar tolls = new Tolls();\nint today = 20, tomorrow = 40; // line x\nSystem.out.print(\ntoday + tolls.tomorrow + tolls.yesterday); // line\ny\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code does not compile due to line x."
      }, {
        "code": "B",
        "value": "The code does not compile due to line y."
      }, {
        "code": "C",
        "value": "31"
      }, {
        "code": "D",
        "value": "61"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "77. C. The code compiles and runs without issue, so options A and B are\nincorrect. The question relies on your ability to understand variable scope.\nThe variable today has local scope to the method in which it is executed.\nThe variable tomorrow is re‐declared in the method, but the reference used\non line y is to the instance variable with a value of 10. Finally, the variable\nyesterday is static. While using an instance reference to access a static\nvariable is not recommended, it does not prevent the variable from being\nread. The result is line y evaluates and prints 31 (20 + 10 + 1), making\noption C the correct answer."
      }
    },
    "78": {
      "nbr": 78,
      "value": "What is the output of the following application?\npackage weather;\npublic class Forecast {\npublic enum Snow {\nBLIZZARD, SQUALL, FLURRY\n@Override public String toString() { return \"Sunny\";\n}\n}\npublic static void main(String[] modelData) {\nSystem.out.print(Snow.BLIZZARD.ordinal() + \" \");\nSystem.out.print(Snow.valueOf(\"flurry\".toUpperCase()));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "0 FLURRY"
      }, {
        "code": "B",
        "value": "1 FLURRY"
      }, {
        "code": "C",
        "value": "0 Sunny"
      }, {
        "code": "D",
        "value": "1 Sunny"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "78. E. If an enum contains anything other than a list of values, then a\nsemicolon (;) must follow the list of values. The Snow enum includes a\nmethod, so there must be a semicolon after the last value, FLURRY. For this\nreason, the code does not compile, and option E is correct. If the semicolon\nwas added, then the code would compile and print 0 Sunny at runtime, with\nthe overridden toString() replacing the default value of FLURRY."
      }
    },
    "79": {
      "nbr": 79,
      "value": "Which of the following is not a true statement?",
      "responses": [{
        "code": "A",
        "value": "The first line of every constructor is a call to the parent constructor via\nthe super() command."
      }, {
        "code": "B",
        "value": "A class is not required to have a constructor explicitly defined."
      }, {
        "code": "C",
        "value": "A constructor may pass arguments to the parent constructor."
      }, {
        "code": "D",
        "value": "A final instance variable whose value is not set when it is declared or\nin an initialization block should be set by the constructor."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "79. A. Option A is the correct answer because the first line of a constructor\ncould be this() or super(), making it an untrue statement. Option B is a\ntrue statement because the compiler will insert the default no‐argument\nconstructor if one is not defined. Option C is also a true statement, since\nzero or more arguments may be passed to the parent constructor, if the\nparent class defines such constructors. Option D is also true. The value of a\nfinal instance variable must be set when it is declared, in an initialization\nblock, or in a constructor."
      }
    },
    "80": {
      "nbr": 80,
      "value": "What can fill in the blank so the play() method can be called from all\nclasses in the com.mammal and com.mammal.eland package, but not the\ncom.mammal.gopher package?\npackage com.mammal;\npublic class Enrichment {\n______ void play() {}\n}",
      "responses": [{
        "code": "A",
        "value": "Leave it blank."
      }, {
        "code": "B",
        "value": "private"
      }, {
        "code": "C",
        "value": "protected"
      }, {
        "code": "D",
        "value": "public"
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "80. E. If only the com.mammal class needed access, option A would be correct.\nAccess modifiers cannot be used to grant access to a list of packages. The\nJava Platform Module Framework can do this, but it is not an option in this\nquestion. Therefore, option E is correct."
      }
    },
    "81": {
      "nbr": 81,
      "value": "What is the output of the Rocket program?\npackage transport;\nclass Ship {\nprotected int weight = 3;\nprivate int height = 5;\npublic int getWeight() { return weight; }\npublic int getHeight() { return height; }\n}\npublic class Rocket extends Ship {\npublic int weight = 2;\npublic int height = 4;\npublic void printDetails() {\nSystem.out.print(super.getWeight()+\",\"+super.height);\n}\npublic static final void main(String[] fuel) {\nnew Rocket().printDetails();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "2,5"
      }, {
        "code": "B",
        "value": "3,4"
      }, {
        "code": "C",
        "value": "5,2"
      }, {
        "code": "D",
        "value": "3,5"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "81. E. The code does not compile because super.height is not visible in the\nRocket class, making option E the correct answer. Even though the Rocket\nclass defines a height value, the super keyword looks for an inherited\nversion. Since there are none, the code does not compile. Note that\nsuper.getWeight() returns 3 from the variable in the parent class, as\npolymorphism and overriding do not apply to instance variables."
      }
    },
    "82": {
      "nbr": 82,
      "value": "Imagine you are working with another team to build an application. You are\ndeveloping code that uses a class that the other team has not finished\nwriting yet. You want to allow easy integration once the other team's code\nis complete. Which statements would meet this requirement? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "An abstract class is best."
      }, {
        "code": "B",
        "value": "An interface is best."
      }, {
        "code": "C",
        "value": "Either of an abstract class or interface would meet the requirement."
      }, {
        "code": "D",
        "value": "The methods should be protected."
      }, {
        "code": "E",
        "value": "The methods should be public."
      }, {
        "code": "F",
        "value": "The methods should be static."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "82. B,E. The key here is understanding which of these features of Java allow\none developer to build their application around another developer's code,\neven if that code is not ready yet. For this problem, an interface is the best\nchoice. If the two teams agree on a common interface, one developer can\nwrite code that uses the interface, while another developer writes code that\nimplements the interface. Assuming neither team changes the interface, the\ncode can be easily integrated once both teams are done. For these reasons,\noption B is correct. Interfaces expose methods using the public keyword,\nmaking option E the other answer."
      }
    },
    "83": {
      "nbr": 83,
      "value": "Fill in the blank with the line of code that allows the program to compile\nand print 10 at runtime.\ninterface Speak {\npublic default int getVolume() { return 20; }\n}\ninterface Whisper {\npublic default int getVolume() { return 10; }\n}\npublic class Debate implements Speak, Whisper {\npublic int getVolume() { return 30; }\npublic static void main(String[] a) {\nvar d = new Debate();\nSystem.out.println(______________);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Whisper.d.getVolume()"
      }, {
        "code": "B",
        "value": "d.Whisper.getVolume()"
      }, {
        "code": "C",
        "value": "Whisper.super.getVolume()"
      }, {
        "code": "D",
        "value": "d.Whisper.super.getVolume()"
      }, {
        "code": "E",
        "value": "The code does not compile regardless of what is inserted into the\nblank."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "83. F. The code compiles, even if the blank is replaced with a constant value,\nmaking option E incorrect. Note that the class correctly overrides both\ninherited default methods. While it is possible to call a specific inherited\ndefault method, even when it has been overridden, it requires calling\nsuper, which is not accessible from a static method. For these reasons,\noptions A, B, C, and D do not work, making option F correct."
      }
    },
    "84": {
      "nbr": 84,
      "value": "Which of the following properties of an enum can be marked abstract?",
      "responses": [{
        "code": "A",
        "value": "The enum type definition"
      }, {
        "code": "B",
        "value": "An enum method"
      }, {
        "code": "C",
        "value": "An enum value"
      }, {
        "code": "D",
        "value": "An enum constructor"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "84. B. An enum declaration itself cannot be marked abstract, nor can any of\nits values, but its methods can be marked abstract, making option B the\ncorrect answer. Note that if an enum contains an abstract method, then\nevery enum value must include an override of this abstract method."
      }
    },
    "85": {
      "nbr": 85,
      "value": "How many lines does the following code output?\npublic class Cars {\nstatic {\nSystem.out.println(\"static\");\n}\nprivate static void drive() {\nSystem.out.println(\"fast\");\n}\n{ System.out.println(\"faster\"); }\npublic static void main(String[] args) {\ndrive();\ndrive();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "Three."
      }, {
        "code": "D",
        "value": "Four."
      }, {
        "code": "E",
        "value": "Five."
      }, {
        "code": "F",
        "value": "None of the above. The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "85. C. The static initializer is run only once. The static method is run twice\nsince it is called twice. Therefore, three lines are printed, and option C is\ncorrect. The instance initializer block is never run because the Cars class is\nnever constructed."
      }
    },
    "86": {
      "nbr": 86,
      "value": "Suppose foo is a reference to an instance of a class Foo. Which of the\nfollowing is not possible about the variable reference foo.bar?",
      "responses": [{
        "code": "A",
        "value": "bar is an instance variable."
      }, {
        "code": "B",
        "value": "bar is a static variable."
      }, {
        "code": "C",
        "value": "bar is a local variable."
      }, {
        "code": "D",
        "value": "It can be used to read from bar."
      }, {
        "code": "E",
        "value": "It can be used to write to bar."
      }, {
        "code": "F",
        "value": "All of the above are possible."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "86. C. Dot notation is used for both reading and writing instance variables,\nassuming they are in scope. It cannot be used for referencing local\nvariables, making option C the correct answer. It is possible that bar is a\nstatic variable, although accessing it in this manner is not recommended."
      }
    },
    "87": {
      "nbr": 87,
      "value": "The following diagram shows two reference variables pointing to the same\nBunny object in memory. The reference variable myBunny is of type Bunny,\nwhile unknownBunny is a valid but unknown data type. Which statements\nabout the reference variables are true? Assume the instance methods and\nvariables shown in the diagram are marked public. (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "The reference type of unknownBunny must be Bunny or a supertype of\nBunny."
      }, {
        "code": "B",
        "value": "The reference type of unknownBunny cannot be cast to a reference type\nof Bunny."
      }, {
        "code": "C",
        "value": "The reference type of unknownBunny must be Bunny or a subclass of\nBunny."
      }, {
        "code": "D",
        "value": "If the reference type of unknownBunny is Bunny, it has access to all of\nthe same methods and variables as myBunny."
      }, {
        "code": "E",
        "value": "The reference type of unknownBunny could be an interface, class, or\nabstract class."
      }, {
        "code": "F",
        "value": "If the reference type of unknownBunny is Object, it has access to all of\nthe same methods and variables as myBunny without a cast."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "E"
        ],
        "explanation": "87. A,D,E. The reference type of unknownBunny must be Bunny or a supertype\nof Bunny, including any abstract classes, concrete classes, or interfaces that\nBunny inherits. For this reason, options A and E are correct, and option C is\nincorrect. Option B is incorrect. Since it already points to an instance of\nBunny, casting it to a Bunny reference is allowed. Option D is trivially true.\nIf the reference types of both are the same, then they can call the same\ninstance members. Option F is incorrect, as casting is required to access\nmembers declared in Bunny that are not defined in Object."
      }
    },
    "88": {
      "nbr": 88,
      "value": "Which of the following interface methods are inherited by classes that\nimplement the interface? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "private methods"
      }, {
        "code": "B",
        "value": "private static methods"
      }, {
        "code": "C",
        "value": "default methods"
      }, {
        "code": "D",
        "value": "static methods"
      }, {
        "code": "E",
        "value": "abstract methods"
      }, {
        "code": "F",
        "value": "final methods"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "88. C,E. Methods marked private or static are never inherited, so options\nA, B, and D are incorrect. Interface methods cannot be final, so option F is\nincorrect. That leaves default and abstract methods, which are both\ninherited by classes implementing the interface."
      }
    },
    "89": {
      "nbr": 89,
      "value": "Which of these are functional interfaces?\ninterface Lion {\npublic void roar();\ndefault void drink() {}\nString toString();\n}\ninterface Tiger {\npublic void roar();\ndefault void drink() {}\nint hashCode();\n}",
      "responses": [{
        "code": "A",
        "value": "Lion"
      }, {
        "code": "B",
        "value": "Tiger"
      }, {
        "code": "C",
        "value": "Both Lion and Tiger"
      }, {
        "code": "D",
        "value": "Neither is a functional interface."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "89. C. The code does compile, so option E is incorrect. A functional interface\nis required to have exactly one abstract method. In both interfaces, that is\nroar(). The toString() and hashCode() method signatures match those\nfrom Object. Since they are provided to all subclasses, they are not\nconsidered abstract. Since roar() is the only abstract method, both are\nfunctional interfaces, making option C the answer."
      }
    },
    "90": {
      "nbr": 90,
      "value": "Given the following code, which lines when placed independently in the\nblank allow the code to compile and print bounce? (Choose two.)\npublic class TennisBall {\npublic TennisBall() {\nSystem.out.println(\"bounce\");\n}\npublic static void main(String[] slam) {\n_________________________\n}\n}",
      "responses": [{
        "code": "A",
        "value": "var new = TennisBall;"
      }, {
        "code": "B",
        "value": "TennisBall();"
      }, {
        "code": "C",
        "value": "var var = new TennisBall();"
      }, {
        "code": "D",
        "value": "new TennisBall;"
      }, {
        "code": "E",
        "value": "new TennisBall();"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "90. C,E. To call a constructor, you must use the new keyword, making option\nE correct. It cannot be called as if it was a normal method. This rules out\noptions A and B. Further, option D is incorrect because the parentheses are\nrequired. Option C is also correct, as var may be used as a variable name."
      }
    },
    "91": {
      "nbr": 91,
      "value": "How many of these methods compile?\npublic class Singing {\nprivate void sing(String key) { }\npublic void sing_do(String key, String… harmonies) {\nthis.sing(key);\n}\npublic void sing_re(int note, String… sound, String key)\n{\nthis.sing(key);\n}\npublic void sing_me(String… keys, String… pitches) {\nthis.sing(key);\n}\npublic void sing_far(String key, String… harmonies) {\nthis.Singing.sing(key);\n}\npublic void sing_so(int note, String… sound,\nString key) {\nthis.Singing.sing(key);\n}\npublic void sing_la(String… keys, String… pitches) {\nthis.Singing.sing(key);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "91. C. To a call an instance method, you can use the this prefix. The class\nname is not included, ruling out the last three methods. A method may\ncontain at most one varargs parameter, and it must appear as the last\nargument in the list. For this reason, the sing_do() method is the only\nmethod using varargs that compiles. The sing() method also compiles\nwithout using varargs. Therefore, option C is the answer."
      }
    },
    "92": {
      "nbr": 92,
      "value": "What is the output of the following application?\npackage world;\npublic class Matrix {\nprivate int level = 1;\nclass Deep {\nprivate int level = 2;\nclass Deeper {\nprivate int level = 5;\npublic void printReality(int level) {\nSystem.out.print(this.level+\" \");\nSystem.out.print(Matrix.Deep.this.level+\" \");\nSystem.out.print(Deep.this.level);\n}\n}\n}\npublic static void main(String[] bots) {\nMatrix.Deep.Deeper simulation = new Matrix()\n.new Deep().new Deeper();\nsimulation.printReality(6);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "1 1 2"
      }, {
        "code": "B",
        "value": "5 2 2"
      }, {
        "code": "C",
        "value": "5 2 1"
      }, {
        "code": "D",
        "value": "6 2 2"
      }, {
        "code": "E",
        "value": "6 2 1"
      }, {
        "code": "F",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "92. B. The code compiles without issue. The first print() statement refers to\nlevel declared in the Deeper class, so 5 is printed. The second and third\nprint() statements actually refer to the same value in the Deep class, so 2 is\nprinted twice. The prefix Matrix. is unnecessary in the first of the two\nprint() statements and does not change the result. For these reasons,\noption B is the correct answer."
      }
    },
    "93": {
      "nbr": 93,
      "value": "Given that Integer and Long are direct subclasses of Number, what type can\nbe used to fill in the blank in the following class to allow it to compile?\npackage orchestra;\ninterface MusicCreator { public Number play(); }\nabstract class StringInstrument {\npublic Long play() {return 3L;}\n}\npublic class Violin extends StringInstrument\nimplements MusicCreator {\npublic _________ play() {\nreturn null;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Long"
      }, {
        "code": "B",
        "value": "Integer"
      }, {
        "code": "C",
        "value": "Long or Integer"
      }, {
        "code": "D",
        "value": "Long or Number"
      }, {
        "code": "E",
        "value": "Long, Integer, or Number"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "93. A. The play() method is overridden in Violin for both MusicCreator and\nStringInstrument, so the return type must be covariant with both. Long is\na subclass of Number, and therefore, it is covariant with the version in\nMusicCreator. Since it matches the type in StringInstrument, it can be\ninserted into the blank, and the code would compile.\nWhile Integer is a subclass of Number, meaning the override for\nMusicCreator is valid, it is not a subclass of Long used in\nStringInstrument. Therefore, using Integer would cause the code to not\ncompile.\nFinally, Number is compatible with the version of the method in\nMusicCreator but not with the version in StringInstrument, because\nNumber is a superclass of Long, not a subclass. For these reasons, Long is the\nonly class that allows the code to compile, making option A the correct\nanswer."
      }
    },
    "94": {
      "nbr": 94,
      "value": "What is the output of the RightTriangle program?\npackage shapes;\nabstract class Triangle {\nabstract String getDescription();\n}\nabstract class IsoRightTriangle extends RightTriangle { //\ng1\npublic String getDescription() { return \"irt\"; }\n}\npublic class RightTriangle extends Triangle {\nprotected String getDescription() { return \"rt\"; } //\ng2\npublic static void main(String[] edges) {\nfinal var shape = new IsoRightTriangle(); //\ng3\nSystem.out.print(shape.getDescription());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "rt"
      }, {
        "code": "B",
        "value": "irt"
      }, {
        "code": "C",
        "value": "The code does not compile due to line g1."
      }, {
        "code": "D",
        "value": "The code does not compile due to line g2."
      }, {
        "code": "E",
        "value": "The code does not compile due to line g3."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "94. E. The IsoRightTriangle class is abstract; therefore, it cannot be\ninstantiated on line g3. If the abstract modifier was removed from the\nIsoRightTraingle declaration, then the rest of the code would compile and\nprint irt at runtime."
      }
    },
    "95": {
      "nbr": 95,
      "value": "What is the output of the following program?\ninterface Dog {\nprivate void buryBone() { chaseTail(); }\nprivate static void wagTail() { chaseTail(); }\npublic default String chaseTail() { return \"So cute!\"; }\n}\npublic class Puppy implements Dog {\npublic String chaseTail() throws\nIllegalArgumentException {\nthrow new IllegalArgumentException(\"Too little!\");\n}\npublic static void main(String[] t) {\nvar p = new Puppy();\nSystem.out.print(p.chaseTail());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "So cute!"
      }, {
        "code": "B",
        "value": "An exception is thrown with a Too little! message."
      }, {
        "code": "C",
        "value": "A different exception is thrown."
      }, {
        "code": "D",
        "value": "The code does not compile because buryBone() is not used."
      }, {
        "code": "E",
        "value": "The code does not compile because chaseTail() cannot declare any\nexceptions in the Puppy class."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "95. F. The private static method wagTail()attempts to access an instancebased\ndefault method chaseTail(), which results in a compiler error,\nmaking option F correct. While buryBone() is not used, it does not result in\na compiler error, making option D incorrect. Overridden methods are\npermitted to declare new unchecked exceptions, and since\nIllegalArgumentException is unchecked, the override is allowed, making\noption E incorrect."
      }
    },
    "96": {
      "nbr": 96,
      "value": "Which of the following are advantages of using enumerated types in Java,\nrather than static constant values? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Improve performance."
      }, {
        "code": "B",
        "value": "Provide access to fixed set of constants whose values do not change\nduring the course of the application."
      }, {
        "code": "C",
        "value": "Provide a caller with a list of available values for a parameter within a\nmethod."
      }, {
        "code": "D",
        "value": "Ensure consistency of data across an application."
      }, {
        "code": "E",
        "value": "Add support for concurrency."
      }, {
        "code": "F",
        "value": "Offer ability to create new enumerated values at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "D"
        ],
        "explanation": "96. B,C,D. Enumerated types support creating a set of reusable values whose\nvalues are fixed and consistent across the entire application. For these\nreasons, options B and D are correct, and option F is incorrect. Option C is\nalso correct, as it provides callers of a method with a list of acceptable\nvalues. Finally, options A and E are incorrect. Using an enum does not, by\nitself, improve performance or support concurrency."
      }
    },
    "97": {
      "nbr": 97,
      "value": "How do you force garbage collection to occur at a certain point?",
      "responses": [{
        "code": "A",
        "value": "Calling System.forceGc()"
      }, {
        "code": "B",
        "value": "Calling System.gc()"
      }, {
        "code": "C",
        "value": "Calling System.requireGc()"
      }, {
        "code": "D",
        "value": "Calling GarbageCollection.clean()"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "97. E. While you can suggest to the JVM that it might want to run a garbage\ncollection cycle, the JVM is free to ignore your suggestion. Option B is\nhow to make this suggestion. Since garbage collection is not guaranteed to\nrun, option E is correct."
      }
    },
    "98": {
      "nbr": 98,
      "value": "Which changes made to the following class would help to properly\nencapsulate the data in the class?\npackage shield;\npublic class Protect {\nprivate String material;\nprotected int strength;\npublic int getStrength() {\nreturn strength;\n}\npublic void setStrength(int strength) {\nthis.strength = strength;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Add a getter method for material."
      }, {
        "code": "B",
        "value": "Add a setter method for material."
      }, {
        "code": "C",
        "value": "Change the access modifier of material to protected."
      }, {
        "code": "D",
        "value": "Change the access modifier of strength to private."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "98. D. The access modifier of strength is protected, meaning subclasses and\nclasses within the same package can modify it. Changing the value to\nprivate would improve encapsulation by making the Protect class the\nonly one capable of directly modifying it. For these reasons, option D is\ncorrect."
      }
    },
    "99": {
      "nbr": 99,
      "value": "Which are true statements about referencing variables from a lambda?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Instance and static variables can be used regardless of whether\neffectively final."
      }, {
        "code": "B",
        "value": "Instance and local variables can be used regardless of whether\neffectively final."
      }, {
        "code": "C",
        "value": "Instance variables and method parameters must be effectively final to\nbe used."
      }, {
        "code": "D",
        "value": "Local variables and method parameters must be effectively final to be\nused."
      }, {
        "code": "E",
        "value": "Local and static variables can be used regardless of whether\neffectively final."
      }, {
        "code": "F",
        "value": "Method parameters and static variables can be used regardless of\nwhether effectively final."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D"
        ],
        "explanation": "99. A,D. A lambda can reference any instance variable, static variable, or\nlambda parameter that is in scope, making option A correct. Lambdas\nrequire local variables and method parameters to be effectively final in\norder to use them, making option D the other correct answer."
      }
    },
    "100": {
      "nbr": 100,
      "value": "Given the following two classes, each in a different package, which line\ninserted into the code allows the second class to compile?\npackage commerce;\npublic class Bank {\npublic void withdrawal(int amountInCents) {}\npublic void deposit(int amountInCents) {}\n}\npackage employee;\n// INSERT CODE HERE\npublic class Teller {\npublic void processAccount(int deposit, int withdrawal)\n{\nwithdrawal(withdrawal);\ndeposit(deposit);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "import static commerce.Bank.*;"
      }, {
        "code": "B",
        "value": "import static commerce.Bank;"
      }, {
        "code": "C",
        "value": "static import commerce.Bank.*;"
      }, {
        "code": "D",
        "value": "static import commerce.Bank;"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "100. E. A static import is used to import static members of another class. In\nthis case, the withdrawal() and deposit() methods in the Bank class are\nnot marked static. They require an instance of Bank to be used and cannot\nbe imported as static methods. Therefore, option E is correct. If the two\nmethods in the Bank class were marked static, then option A would be the\ncorrect answer since wildcards can be used with static imports to import\nmore than one method. Options C and D reverse the keywords static and\nimport, while option B incorrectly imports a class, which cannot be\nimported via a static import."
      }
    },
    "101": {
      "nbr": 101,
      "value": "Given the following structure, which snippets of code return true? (Choose\nthree.)\ninterface Friendly {}\nabstract class Dolphin implements Friendly {}\nclass Animal implements Friendly {}\nclass Whale extends Object {}\npublic class Fish {}\nclass Coral extends Animal {}",
      "responses": [{
        "code": "A",
        "value": "new Coral() instanceof Friendly"
      }, {
        "code": "B",
        "value": "null instanceof Object"
      }, {
        "code": "C",
        "value": "new Coral() instanceof Object"
      }, {
        "code": "D",
        "value": "new Fish() instanceof Friendly"
      }, {
        "code": "E",
        "value": "new Whale() instanceof Object"
      }, {
        "code": "F",
        "value": "new Dolphin() instanceof Friendly"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "E"
        ],
        "explanation": "101. A,C,E. Option A returns true since Coral inherits Friendly from its\nsuperclass Animal. Option B is false, as using null with the instanceof\noperator always returns false. Options C and E both return true because\nall classes inherit Object, even those that don't explicitly extend it. Option\nD is false because Fish does not inherit the Friendly interface. Finally,\noption F does not compile as Dolphin is abstract and cannot be instantiated\ndirectly. If it was not marked abstract, then it would return true."
      }
    },
    "102": {
      "nbr": 102,
      "value": "What is true of the following code?\npublic class Eggs {\nenum Animal {\nCHICKEN(21), PENGUIN(75);\nprivate int numDays;\nprivate Animal(int numDays) {\nthis.numDays = numDays;\n}\npublic int getNumDays() {\nreturn numDays;\n}\npublic void setNumDays(int numDays) {\nthis.numDays = numDays;\n}\n}\npublic static void main(String[] args) {\nAnimal chicken = Animal.CHICKEN;\nchicken.setNumDays(20);\nSystem.out.print(chicken.getNumDays());\nSystem.out.print(\" \");\nSystem.out.print(Animal.CHICKEN.getNumDays());\nSystem.out.print(\" \");\nSystem.out.print(Animal.PENGUIN.getNumDays());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "It prints 20 20 20"
      }, {
        "code": "B",
        "value": "It prints 20 20 75"
      }, {
        "code": "C",
        "value": "It prints 20 21 75"
      }, {
        "code": "D",
        "value": "It prints 21 21 75"
      }, {
        "code": "E",
        "value": "It does not compile due to setNumDays()."
      }, {
        "code": "F",
        "value": "It does not compile for another reason."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "102. B. While it is not recommended to change the value of an enum after it is\ncreated, it is legal. Each enum value has its own copy of numDays. This\nmeans the setter changes it for CHICKEN, but not for PENGUIN. Therefore,\noption B is correct. Both calls on CHICKEN print the updated value of 20,\nwhile PENGUIN retains the original 75."
      }
    },
    "103": {
      "nbr": 103,
      "value": "What statement about the following interface is correct?\n1: public interface Thunderstorm {\n2: float rain = 1;\n3: char getSeason() { return 'W'; }\n4: boolean isWet();\n5: private static void hail() {}\n6: default String location() { return \"Home\"; }\n7: private static int getTemp() { return 35; }\n8: }",
      "responses": [{
        "code": "A",
        "value": "Line 2 does not compile."
      }, {
        "code": "B",
        "value": "Line 3 does not compile."
      }, {
        "code": "C",
        "value": "Line 4 does not compile."
      }, {
        "code": "D",
        "value": "Line 5 does not compile."
      }, {
        "code": "E",
        "value": "Line 6 does not compile."
      }, {
        "code": "F",
        "value": "Line 7 does not compile."
      }, {
        "code": "G",
        "value": "All of the lines compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "103. B. Line 3 does not compile, as a method with a body within an interface\nmust be explicitly marked static, default, or private, making option B\ncorrect. The rest of the lines compile without issue. For this question, it\nhelps to remember which implicit modifiers the compiler will insert, and\nwhich it will not. On line 2, the compiler will insert public static final\nautomatically, and on lines 4 and 6, the compiler will insert public\nautomatically. The compiler will also insert abstract on line 4 since the\nmethod does not declare a body."
      }
    },
    "104": {
      "nbr": 104,
      "value": "What is the output of the following application?\npackage finance;\nenum Currency {\nDOLLAR, YEN, EURO\n}\nabstract class Provider {\nprotected Currency c = Currency.EURO;\n}\npublic class Bank extends Provider {\nprotected Currency c = Currency.DOLLAR;\npublic static void main(String[] pennies) {\nint value = 0;\nswitch(new Bank().c) {\ncase 0:\nvalue--; break;\ncase 1:\nvalue++; break;\n}\nSystem.out.print(value);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "‐1"
      }, {
        "code": "B",
        "value": "0"
      }, {
        "code": "C",
        "value": "1"
      }, {
        "code": "D",
        "value": "The Provider class does not compile."
      }, {
        "code": "E",
        "value": "The Bank class does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "104. E. The type of the variable in the switch statement is the enum Currency,\nbut the case statements use int values. While the enum class hierarchy\ndoes support an ordinal() method, which returns an int value, the enum\nvalues cannot be compared directly with int values. For this reason, the\nBank class does not compile, making option E the correct answer."
      }
    },
    "105": {
      "nbr": 105,
      "value": "How many lines need to be removed for this code to compile?\n1: package figures;\n2: public class Dolls {\n3: public int num() { return 3.0; }\n4: public int size() { return 5L; }\n5:\n6: public void nested() { nested(2,true); }\n7: public int nested(int w, boolean h) { return 0; }\n8: public int nested(int level) { return level+1; }\n9:\n10: public static void main(String[] outOfTheBox) {\n11: System.out.print(new Dolls().nested());\n12: }\n13: }",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "105. D. Lines 3 and 4 do not compile because the returned values of double\nand long are not compatible with int. Lines 6 through 8 compile without\nissue, since each method takes a different set of input arguments. The first\nline of the main() method does not compile either, making option D\ncorrect. The no‐argument version of the nested() method does not return a\nvalue, and trying to output a void return type in the print() method doesn't\ncompile."
      }
    },
    "106": {
      "nbr": 106,
      "value": "Fill in the blanks: A class may be assigned to a(n) ___________________\nreference variable automatically but requires an explicit cast when assigned\nto a(n) ___________________ reference variable.",
      "responses": [{
        "code": "A",
        "value": "subclass, outer class"
      }, {
        "code": "B",
        "value": "superclass, subclass"
      }, {
        "code": "C",
        "value": "concrete class, subclass"
      }, {
        "code": "D",
        "value": "subclass, superclass"
      }, {
        "code": "E",
        "value": "abstract class, concrete class"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "106. B. A class can trivially be assigned to a superclass reference variable but\nrequires an explicit cast to be assigned to a subclass reference variable. For\nthese reasons, option B is correct."
      }
    },
    "107": {
      "nbr": 107,
      "value": "Which statement about functional interfaces is incorrect?",
      "responses": [{
        "code": "A",
        "value": "A functional interface can have any number of static methods."
      }, {
        "code": "B",
        "value": "A functional interface can have any number of default methods."
      }, {
        "code": "C",
        "value": "A functional interface can have any number of private static\nmethods."
      }, {
        "code": "D",
        "value": "A functional interface can have any number of abstract methods."
      }, {
        "code": "E",
        "value": "A functional interface can have any number of private methods."
      }, {
        "code": "F",
        "value": "All of the above are correct."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "107. D. A functional interface may have any number of static, default,\nprivate static, or private methods. It can have only one qualified\nabstract method, though, making option D correct."
      }
    },
    "108": {
      "nbr": 108,
      "value": "What are possible outputs of the following given that the comment on line X\ncan be replaced by code?\n// Mandrill.java\npublic class Mandrill {\npublic int age;\npublic Mandrill(int age) {\nthis.age = age;\n}\npublic String toString() {\nreturn \"\" + age;\n}\n}\n// PrintAge.java\npublic class PrintAge {\npublic static void main (String[] args) {\nvar mandrill = new Mandrill(5);\n// line X\nSystem.out.println(mandrill);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "5"
      }, {
        "code": "C",
        "value": "Either 0 or 5"
      }, {
        "code": "D",
        "value": "Any int value"
      }, {
        "code": "E",
        "value": "Does not compile"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "108. D. This class has poor encapsulation since the age variable is public. This\nmeans that a developer could modify the body of main() to change the\nvalue of mandrill.age to any integer value, and option D is correct."
      }
    },
    "109": {
      "nbr": 109,
      "value": "How many of the String objects are eligible for garbage collection right\nbefore the end of the main() method?\npublic static void main(String[] ohMy) {\nString animal1 = new String(\"lion\");\nString animal2 = new String(\"tiger\");\nString animal3 = new String(\"bear\");\nanimal3 = animal1;\nanimal2 = animal3;\nanimal1 = animal2;\n}",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "109. C. All three references point to the String object \"lion\". This makes the\nother two String objects eligible for garbage collection and makes option C\ncorrect."
      }
    },
    "110": {
      "nbr": 110,
      "value": "Suppose Panther and Cub are interfaces and neither contains any default\nmethods. Which statements are true? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "If Panther has a single abstract method, Cub is guaranteed to be a\nfunctional interface."
      }, {
        "code": "B",
        "value": "If Panther has a single abstract method, Cub may be a functional\ninterface."
      }, {
        "code": "C",
        "value": "If Panther has a single abstract method, Cub cannot be a functional\ninterface."
      }, {
        "code": "D",
        "value": "If Panther has two abstract methods, Cub is guaranteed to be a\nfunctional interface."
      }, {
        "code": "E",
        "value": "If Panther has two abstract methods, Cub may be a functional\ninterface."
      }, {
        "code": "F",
        "value": "If Panther has two abstract methods, Cub cannot be a functional\ninterface."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "110. B,F. A functional interface has exactly one abstract method. This\nincludes inherited methods. If Panther has a single abstract method, Cub\nis a functional interface if it does not add any more abstract methods. This\nmatches option B. However, if Panther has two abstract methods, there is\nno code in Cub that can make it a functional interface, and option F is the\nother answer."
      }
    },
    "111": {
      "nbr": 111,
      "value": "A local class can access which type of local variables? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "final"
      }, {
        "code": "B",
        "value": "private"
      }, {
        "code": "C",
        "value": "effectively final"
      }, {
        "code": "D",
        "value": "static"
      }, {
        "code": "E",
        "value": "default"
      }, {
        "code": "F",
        "value": "const"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "111. A,C. A local class can access final or effectively final local variables,\nmaking options A and C the correct answer. Local variables cannot be\nmarked private or static, making options B and D incorrect. Options E\nand F are also incorrect, as those are not valid variable modifiers."
      }
    },
    "112": {
      "nbr": 112,
      "value": "What does the following output?\n1: public class InitOrder {\n2: public String first = \"instance\";\n3: public InitOrder() {\n4: first = \"constructor\";\n5: }\n6: { first = \"block\"; }\n7: public void print() {\n8: System.out.println(first);\n9: }\n10: public static void main(String… args) {\n11: new InitOrder().print();\n12: }\n13: }",
      "responses": [{
        "code": "A",
        "value": "block"
      }, {
        "code": "B",
        "value": "constructor"
      }, {
        "code": "C",
        "value": "instance"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "112. B. When the main() method instantiates the object, line 2 first runs and\nsets the variable using the declaration. Then the instance initializer on line 6\nruns. Finally, the constructor runs. Since the constructor is the last to run of\nthe three, that is the value that is set when we print the result, so option B is\ncorrect."
      }
    },
    "113": {
      "nbr": 113,
      "value": "Which statement about the following interface is correct?\npublic interface Tree {\npublic static void produceSap() {\ngrowLeaves();\n}\npublic abstract int getNumberOfRings() {\nreturn getNumberOfRings();\n}\nprivate static void growLeaves() {\nproduceSap();\n}\npublic default int getHeight() {\nreturn getHeight ();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code compiles."
      }, {
        "code": "B",
        "value": "The method produceSap() does not compile."
      }, {
        "code": "C",
        "value": "The method getNumberOfRings() does not compile."
      }, {
        "code": "D",
        "value": "The method growLeaves() does not compile."
      }, {
        "code": "E",
        "value": "The method getHeight() does not compile."
      }, {
        "code": "F",
        "value": "The code does not compile because it contains a cycle."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "113. C. An abstract method cannot define a body, meaning the declaration of\ngetNumberOfRings() is invalid and option C is correct. The rest of the code\ncompiles without issue. While the compiler will prevent cycles within\noverloaded constructors, it does not do so for methods, meaning option F is\nincorrect."
      }
    },
    "114": {
      "nbr": 114,
      "value": "Which statements about a variable with a type of var are true? (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "The variable can be assigned null at any point in the program."
      }, {
        "code": "B",
        "value": "The variable can be assigned null only after initial initialization."
      }, {
        "code": "C",
        "value": "The variable can never be assigned null."
      }, {
        "code": "D",
        "value": "Only primitives can be used with the variable."
      }, {
        "code": "E",
        "value": "Only objects can be used with the variable."
      }, {
        "code": "F",
        "value": "Either a primitive or an object can be used with the variable."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "114. B,F. The type is determined based on the value at initialization. It cannot\nbe null at that point, but the variable can be assigned as null later, making\noption B correct. Both primitives and objects can be used with var, making\noption F correct."
      }
    },
    "115": {
      "nbr": 115,
      "value": "Assume there is a class Bouncer with a protected variable. Methods in\nwhich class can access this variable?",
      "responses": [{
        "code": "A",
        "value": "Any subclass of Bouncer or any class in the same package as Bouncer"
      }, {
        "code": "B",
        "value": "Any superclass of Bouncer"
      }, {
        "code": "C",
        "value": "Only subclasses of Bouncer"
      }, {
        "code": "D",
        "value": "Only classes in the same package as Bouncer"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "115. A. The protected modifier allows access by any subclass or class that is\nin the same package; therefore, option A is the correct answer."
      }
    },
    "116": {
      "nbr": 116,
      "value": "What is the output of the following application?\npackage forest;\npublic class Woods {\nstatic class Tree {}\npublic static void main(String[] leaves) {\nint heat = 2;\nint water = 10-heat;\nfinal class Oak extends Tree { // p1\npublic int getWater() {\nreturn water; // p2\n}\n}\nSystem.out.print(new Oak().getWater());\nwater = 0;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "8"
      }, {
        "code": "B",
        "value": "Line p1 contains a compiler error."
      }, {
        "code": "C",
        "value": "Line p2 contains a compiler error."
      }, {
        "code": "D",
        "value": "Another line of code contains a compiler error."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "116. C. The main() method defines a local class Oak that correctly extends\nTree, a static nested class. The method getWater() is not permitted to\nread the local variable water, though, since it is not final or effectively\nfinal, making option C correct. If the last line of the method was removed,\nthough, then the program would compile and print 8."
      }
    },
    "117": {
      "nbr": 117,
      "value": "Which can fill in the blank to make the code compile? (Choose two.)\ninterface Australian {}\ninterface Mammal {}\n________________ Australian, Mammal {}",
      "responses": [{
        "code": "A",
        "value": "class Quokka extends"
      }, {
        "code": "B",
        "value": "class Quokka implements"
      }, {
        "code": "C",
        "value": "Neither A nor B. Only one interface can be specified."
      }, {
        "code": "D",
        "value": "interface Quokka extends"
      }, {
        "code": "E",
        "value": "interface Quokka implements"
      }, {
        "code": "F",
        "value": "Neither D nor E. Only one interface can be specified."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "117. B,D. A class can implement multiple interfaces, making option B correct.\nAn interface can extend multiple interfaces, making option D correct as\nwell."
      }
    },
    "118": {
      "nbr": 118,
      "value": "What is true of the following method?\npublic void setColor(String color) {\ncolor = color;\n}",
      "responses": [{
        "code": "A",
        "value": "It is a correctly implemented accessor method."
      }, {
        "code": "B",
        "value": "It is a correctly implemented mutator method."
      }, {
        "code": "C",
        "value": "It is an incorrectly implemented accessor method."
      }, {
        "code": "D",
        "value": "It is an incorrectly implemented mutator method."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "118. D. The method looks like a setter or mutator method. However, it is\nincorrectly implemented since the method is missing a this reference and\ndoesn't actually change the value. Therefore, option D is correct."
      }
    },
    "119": {
      "nbr": 119,
      "value": "Which of the following statements about calling this() in a constructor are\ntrue? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "If arguments are provided to this(), then there must be a constructor\nin the class able to take those arguments."
      }, {
        "code": "B",
        "value": "If arguments are provided to this(), then there must be a constructor\nin the superclass able to take those arguments."
      }, {
        "code": "C",
        "value": "If the no‐argument this() is called, then the class must explicitly\nimplement the no‐argument constructor."
      }, {
        "code": "D",
        "value": "If super() and this() are both used in the same constructor, super()\nmust appear on the line immediately after this()."
      }, {
        "code": "E",
        "value": "If super() and this() are both used in the same constructor, this()\nmust appear on the line immediately after super()."
      }, {
        "code": "F",
        "value": "If this() is used, it must be the first line of the constructor."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "F"
        ],
        "explanation": "119. A,C,F. Option A is correct and option B is incorrect because this() calls\nanother constructor in the same class. Option C is correct because this()\nwithout parameters is the default constructor and is not inserted\nautomatically by the compiler if another constructor is present. Options D\nand E are both incorrect because only one of super() or this() can be\nused from the same constructor. Finally, option F is correct as super() or\nthis() must come first."
      }
    },
    "120": {
      "nbr": 120,
      "value": "What is the result of compiling and executing the following class?\npublic class RollerSkates {\nstatic int wheels = 1;\nint tracks = 5;\npublic static void main(String[] arguments) {\nRollerSkates s = new RollerSkates();\nint feet=4, tracks = 15;\nSystem.out.print(feet + tracks + s.wheels);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code does not compile."
      }, {
        "code": "B",
        "value": "4"
      }, {
        "code": "C",
        "value": "5"
      }, {
        "code": "D",
        "value": "10"
      }, {
        "code": "E",
        "value": "20"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "120. E. The code compiles and runs without issue, so option A is incorrect. The\nquestion involves understanding the value and scope of each variable at the\nprint() statement. The variables feet and tracks are locally scoped and\nset to 4 and 15, respectively, ignoring the value of tracks of 5 in the\ninstance of the class. Finally, the static variable s.wheels has a value of"
      }
    },
    "121": {
      "nbr": 121,
      "value": "Which statements about the following program are correct? (Choose two.)\npackage vessel;\nclass Problem extends Exception {}\nabstract class Danger {\nprotected abstract void isDanger() throws Problem; // m1\n}\npublic class SeriousDanger extends Danger { // m2\nprotected void isDanger() throws Exception { // m3\nthrow new RuntimeException(); // m4\n}\npublic static void main(String[] w) throws Throwable {\n// m5\nvar sd = new SeriousDanger().isDanger(); // m6\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code does not compile because of line m1."
      }, {
        "code": "B",
        "value": "The code does not compile because of line m2."
      }, {
        "code": "C",
        "value": "The code does not compile because of line m3."
      }, {
        "code": "D",
        "value": "The code does not compile because of line m4."
      }, {
        "code": "E",
        "value": "The code does not compile because of line m5."
      }, {
        "code": "F",
        "value": "The code does not compile because of line m6."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "121. C,F. Line m3 does not compile because isDanger() is an invalid method\noverride. An overridden method may not throw a broader checked\nexception than it inherits. Since Exception is a superclass of Problem, the\ncode does not compile, and option C is correct. Line m6 does not compile\nbecause the return type of isDanger() is void, which cannot be assigned to\na variable, making option F also correct."
      }
    },
    "122": {
      "nbr": 122,
      "value": "Which statements about top‐level and member inner classes are correct?\n(Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Both can be marked protected."
      }, {
        "code": "B",
        "value": "Only top‐level classes can be declared final."
      }, {
        "code": "C",
        "value": "Both can declare constructors."
      }, {
        "code": "D",
        "value": "Member inner classes cannot be marked private."
      }, {
        "code": "E",
        "value": "Member inner classes can access private variables of the top‐level\nclass in which it is defined."
      }, {
        "code": "F",
        "value": "Both can be marked abstract."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E",
          "F"
        ],
        "explanation": "122. C,E,F. Top‐level classes can be set only with public and package‐private\naccess, making option A incorrect. On the other hand, member inner classes\ncan be set with any of the four access levels, making option D incorrect.\nBoth types of classes can be declared with final or abstract modifier,\nmaking option B incorrect and option F correct. Both can also include\nconstructors, making option C correct. Finally, option E is correct and one\nof the primary features of inner classes."
      }
    },
    "123": {
      "nbr": 123,
      "value": "What is required to define a valid Java class file?",
      "responses": [{
        "code": "A",
        "value": "A class declaration"
      }, {
        "code": "B",
        "value": "A package statement"
      }, {
        "code": "C",
        "value": "An import statement"
      }, {
        "code": "D",
        "value": "A class declaration and package statement"
      }, {
        "code": "E",
        "value": "A class declaration and at least one import statement"
      }, {
        "code": "F",
        "value": "The public modifier"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "123. A. Option A is the only correct answer as a class declaration is the only\nrequired component in a Java class file. Note that we said a Java class file\nhere; Java also allows interfaces, annotations, modules, and enums to be\ndefined in a file. A class file may have a single package statement or any\nnumber of import statements. Neither is required."
      }
    },
    "124": {
      "nbr": 124,
      "value": "How many objects are eligible for garbage collection right before the end of\nthe main() method?\n1: public class Person {\n2: public Person youngestChild;\n3:\n4: public static void main(String… args) {\n5: Person elena = new Person();\n6: Person janeice = new Person();\n7: elena.youngestChild = janeice;\n8: janeice = null;\n9: Person zoe = new Person();\n10: elena.youngestChild = zoe;\n11: zoe = null;\n12: } }",
      "responses": [{
        "code": "A",
        "value": "None."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "124. B. On line 9, all three objects have references. The elena and zoe objects\nhave a direct reference. The janeice object is referenced through the elena\nobject. On line 10, the reference to the janeice object is replaced by a\nreference to the zoe object. Therefore, the janeice object is eligible to be\ngarbage collected, and option B is correct."
      }
    },
    "125": {
      "nbr": 125,
      "value": "What is the output of the following application?\npackage race;\ninterface Drive {\nint SPEED = 5;\ndefault int getSpeed() { return SPEED; }\n}\ninterface Hover {\nint MAX_SPEED = 10;\ndefault int getSpeed() { return MAX_SPEED; }\n}\npublic class Car implements Drive, Hover {\npublic static void main(String[] gears) {\nclass RaceCar extends Car {\n@Override public int getSpeed() { return 15; }\n};\nSystem.out.print(new RaceCar().getSpeed());\n} }",
      "responses": [{
        "code": "A",
        "value": "5"
      }, {
        "code": "B",
        "value": "10"
      }, {
        "code": "C",
        "value": "15"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The answer cannot be determined with the information given."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "125. D. Both the Drive and Hover interfaces define a default method\ngetSpeed() with the same signature. The class Car implements both\ninterfaces, which means it inherits both default methods. Since the\ncompiler does not know which one to choose, the Car class must override\nthe default method. Since it does not, the code does not compile, and\noption D is correct. Note that the RaceCar class does properly override the\ndefault method, the problem is with the Car class."
      }
    },
    "126": {
      "nbr": 126,
      "value": "What is the output of the following application? (Choose two.)\n1: public class ChooseWisely {\n2: public ChooseWisely() { super(); }\n3: public int choose(int choice) { return 5; }\n4: public int choose(short choice) { return 2; }\n5: public int choose(long choice) { return 11; }\n6: public int choose(double choice) { return 6; }\n7: public int choose(Float choice) { return 8; }\n8: public static void main(String[] path) {\n9: ChooseWisely c = new ChooseWisely();\n10: System.out.println(c.choose(2f));\n11: System.out.println(c.choose((byte)2+1));\n12: }\n13: }",
      "responses": [{
        "code": "A",
        "value": "2"
      }, {
        "code": "B",
        "value": "3"
      }, {
        "code": "C",
        "value": "5"
      }, {
        "code": "D",
        "value": "6"
      }, {
        "code": "E",
        "value": "8"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "126. C,D. On line 10, we are passing a float. Since there is no exact match,\nJava attempts promotion of the primitive type to double, before trying to\nwrap it as a Float, making option D correct. On line 11, the value 2 is first\ncast to a byte. It is then increased by one using the addition + operator. The\naddition + operator automatically promotes all byte and short values to\nint. Therefore, the value passed to choose() in the main() method is an\nint. The choose(int) method is called, returning 5 and making option C\nthe correct answer. Note that without the addition operation in the main()\nmethod, byte would have been used as the parameter to the choose()\nmethod, causing the choose(short) to be selected as the next closest type\nand outputting 2, making option A the correct answer."
      }
    },
    "127": {
      "nbr": 127,
      "value": "Fill in the blanks: It is possible to extend a(n) ______________ but not a(n)\n______________. (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "interface, abstract class"
      }, {
        "code": "B",
        "value": "anonymous class, static nested class"
      }, {
        "code": "C",
        "value": "abstract class, enum"
      }, {
        "code": "D",
        "value": "enum, interface"
      }, {
        "code": "E",
        "value": "abstract class, interface"
      }, {
        "code": "F",
        "value": "local class, anonymous class"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "127. C,F. An interface can be extended by another interface and a class can be\nextended by another class. This makes the second part of options A, D, and\nE incorrect. Among nested classes, all types can be extended except an\nanonymous class since it does not declare a class name, making option F\ncorrect and both parts of option B incorrect. Option C is correct because an\nenum cannot be extended."
      }
    },
    "128": {
      "nbr": 128,
      "value": "How many lines of the following program do not compile?\n1: public enum Color {\n2: RED(1,2) { void toSpectrum() {} },\n3: BLUE(2) { void toSpectrum() {} void printColor() {}\n},\n4: ORANGE() { void toSpectrum() {} },\n5: GREEN(4);\n6: public Color(int… color) {}\n7: abstract void toSpectrum();\n8: final void printColor() {}\n9: }",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "More than three"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "128. D. Line 3 does not compile because printColor() is marked final and\ncannot be overridden. Line 5 does not compile because the method\ntoSpectrum() is marked abstract and must be overridden by each enum\nvalue. Finally, line 6 does not compile because enum constructors are\nimplicitly private. For these three reasons, option D is correct."
      }
    },
    "129": {
      "nbr": 129,
      "value": "What is the output of the Square program?\npackage shapes;\nabstract class Trapezoid {\nprivate int getEqualSides() {return 0;}\n}\nabstract class Rectangle extends Trapezoid {\npublic static int getEqualSides() {return 2;} // x1\n}\npublic final class Square extends Rectangle {\npublic int getEqualSides() {return 4;} // x2\npublic static void main(String[] corners) {\nfinal Square myFigure = new Square(); // x3\nSystem.out.print(myFigure.getEqualSides());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "4"
      }, {
        "code": "D",
        "value": "The code does not compile due to line x1."
      }, {
        "code": "E",
        "value": "The code does not compile due to line x2."
      }, {
        "code": "F",
        "value": "The code does not compile due to line x3."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "129. E. The override of getEqualSides() in Square is invalid. A static\nmethod cannot override a non‐static method and vice versa. For this\nreason, option E is the correct answer. The rest of the lines compile without\nissue. If the static modifier were added to the method declaration on line\nx2, then the code would print 4 at runtime."
      }
    },
    "130": {
      "nbr": 130,
      "value": "What can fill in the blank so the play() method can be called from all\nclasses in the com.mammal package, but not the com.mammal.gopher\npackage?\npackage com.mammal;\npublic class Enrichment {\n______ void play() {}\n}",
      "responses": [{
        "code": "A",
        "value": "Leave it blank."
      }, {
        "code": "B",
        "value": "private"
      }, {
        "code": "C",
        "value": "protected"
      }, {
        "code": "D",
        "value": "public"
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "130. A. Since only one package needs access and it is the same package the\nclass is in, option A is correct."
      }
    },
    "131": {
      "nbr": 131,
      "value": "How many cells in the following table are incorrect?\nType Allows abstract\nmethods?\nAllows\nconstants?\nAllows\nconstructors?\nAbstract\nclass\nYes Yes No\nConcrete\nclass\nYes Yes Yes\nInterface Yes Yes Yes",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "131. D. A concrete class is not allowed to have abstract methods, but the\nother two types are. This makes the second row in the first column\nincorrect. All three types are allowed to have static final constants,\nmaking the whole second column correct. In the last column, there are two\nerrors. An abstract class can have a constructor, but an interface cannot.\nNote that an abstract class cannot be instantiated. Instead, it requires a\nsubclass. This gives us a total of three incorrect cells, making option D the\nanswer."
      }
    },
    "132": {
      "nbr": 132,
      "value": "Which statements are true about a functional interface? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "It may contain any number of abstract methods."
      }, {
        "code": "B",
        "value": "It must contain a single abstract method."
      }, {
        "code": "C",
        "value": "It may contain any number of private methods."
      }, {
        "code": "D",
        "value": "It must contain a single private method."
      }, {
        "code": "E",
        "value": "It may contain any number of static methods."
      }, {
        "code": "F",
        "value": "It must contain a single static method."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "E"
        ],
        "explanation": "132. B,C,E. A functional interface must have exactly one abstract method,\nwhich is option B. There are no restrictions on the number of private or\nstatic methods, which make options C and E also correct."
      }
    },
    "133": {
      "nbr": 133,
      "value": "Which variables have a scope limited to a method?",
      "responses": [{
        "code": "A",
        "value": "Interface variables"
      }, {
        "code": "B",
        "value": "Class variables"
      }, {
        "code": "C",
        "value": "Instance variables"
      }, {
        "code": "D",
        "value": "Local variables"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "133. D. Only local variables have such a small scope, making option D the\ncorrect answer."
      }
    },
    "134": {
      "nbr": 134,
      "value": "What is a possible output of the following application?\npackage wrap;\npublic class Gift {\nprivate final Object contents;\nprotected Object getContents() {\nreturn contents;\n}\nprotected void setContents(Object contents) {\nthis.contents = contents;\n}\npublic void showPresent() {\nSystem.out.print(\"Your gift: \"+contents);\n}\npublic static void main(String[] treats) {\nGift gift = new Gift();\ngift.setContents(gift);\ngift.showPresent();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Your gift: wrap.Gift@29ca2745"
      }, {
        "code": "B",
        "value": "Your gift: Your gift:"
      }, {
        "code": "C",
        "value": "It does not compile."
      }, {
        "code": "D",
        "value": "It compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "134. C. The code contains a compilation error in regard to the contents\ninstance variable. The contents instance variable is marked final, but\nthere is a setContents() instance method that can change the value of the\nvariable. Since these two are incompatible, the code does not compile, and\noption C is correct. If the final modifier were removed from the contents\nvariable declaration, then the expected output would be of the form shown\nin option A."
      }
    },
    "135": {
      "nbr": 135,
      "value": "Which of the following are the best reasons for creating a default interface\nmethod? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Allow interface methods to be overloaded."
      }, {
        "code": "B",
        "value": "Add backward compatibility to existing interfaces."
      }, {
        "code": "C",
        "value": "Give an interface the ability to create final methods."
      }, {
        "code": "D",
        "value": "Allow an interface to define a method at the class level."
      }, {
        "code": "E",
        "value": "Improve code reuse among classes that implement the interface."
      }, {
        "code": "F",
        "value": "Improve encapsulation of the interface."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "135. B,E. One of the motivations for adding default interface methods to Java\nwas for backward compatibility. These methods allow developers to update\nolder classes with a newer version of an interface without breaking\nfunctionality in the existing classes, making option B correct. Option E is\nalso correct, as classes implementing the interface can share common\nmethods. Option A is incorrect, as interface methods can already be\noverloaded. Option C is incorrect because methods in interfaces cannot be\nmarked final. Option D sounds plausible, but could be accomplished with\nstatic interface methods alone. Option F is incorrect as that statement only\napplies to private interface methods."
      }
    },
    "136": {
      "nbr": 136,
      "value": "How many compiler errors does the following code contain?\npackage animal;\ninterface CanFly {\npublic void fly() {}\n}\nfinal class Bird {\npublic int fly(int speed) {}\n}\npublic class Eagle extends Bird implements CanFly {\npublic void fly() {}\n}",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "136. D. The method fly() defined in CanFly defines an implementation, an\nempty {}, meaning it cannot be assumed to be abstract; therefore, the\ncode does not compile.\nNext, the implementation of fly(int speed) in the Bird class also does\nnot compile, but not because of the signature. The method body fails to\nreturn an int value.\nFinally, the Eagle class does not compile because it extends the Bird class,\nwhich is marked final and, therefore, cannot be extended. For these three\nreasons, option D is the correct answer."
      }
    },
    "137": {
      "nbr": 137,
      "value": "Which of the following statements is not true?",
      "responses": [{
        "code": "A",
        "value": "An instance of one class may access an instance of another class's\nattributes if it has a reference to the instance and the attributes are\ndeclared public."
      }, {
        "code": "B",
        "value": "An instance of one class may access package‐private attributes in a\nparent class, provided the parent class is not in the same package."
      }, {
        "code": "C",
        "value": "An instance of one class may access an instance of another class's\nattributes if both classes are located in the same package and marked\nprotected."
      }, {
        "code": "D",
        "value": "Two instances of the same class may access each other's private\nattributes."
      }, {
        "code": "E",
        "value": "All of the above are true."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "137. B. Options A, C, and D are true statements. Option A is correct because\npublic allows any class to access it. Option C is true because protected\naccess also provides package‐private access. Option D allows us to write\nthe equals() methods between two objects that compare private attributes\nof the class. Option B is false. Package‐private attributes are visible only if\nthe two classes are in the same package, regardless of whether one extends\nthe other."
      }
    },
    "138": {
      "nbr": 138,
      "value": "What is the output of the following code?\npublic class Bunny {\nstatic class Rabbit {\nvoid hop() {\nSystem.out.print(\"hop\");\n}\n}\nstatic class FlemishRabbit extends Rabbit {\nvoid hop() {\nSystem.out.print(\"HOP\");\n}\n}\npublic static void main(String[] args) {\nRabbit r1 = new FlemishRabbit();\nFlemishRabbit r2 = new FlemishRabbit();\nr1.hop();\nr2.hop();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "hophop"
      }, {
        "code": "B",
        "value": "HOPhop"
      }, {
        "code": "C",
        "value": "hopHOP"
      }, {
        "code": "D",
        "value": "HOPHOP"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "138. D. This example deals with polymorphism since the methods are being\ncalled on the object instance. Since both objects are of type FlemishRabbit,\nHOP is printed twice, and option D is the correct answer."
      }
    },
    "139": {
      "nbr": 139,
      "value": "Which of the following are valid class declarations? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "class _ {}"
      }, {
        "code": "B",
        "value": "class river {}"
      }, {
        "code": "C",
        "value": "class Str3@m {}"
      }, {
        "code": "D",
        "value": "class Pond2$ {}"
      }, {
        "code": "E",
        "value": "class _var_ {}"
      }, {
        "code": "F",
        "value": "class 5Ocean {}"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "E"
        ],
        "explanation": "139. B,D,E. Class names follow the same requirements as other identifiers.\nUnderscores (_) and dollar signs ($) are allowed, but no other symbols are\nallowed, making option C incorrect. Since Java 9, a single underscore is not\npermitted as an identifier, making option A incorrect. Numbers are allowed,\nbut not as the first character. Therefore, option F is incorrect. The rest of the\noptions are valid class names, making the answer options B, D, and E\ncorrect. Note that class names begin with an uppercase letter by convention,\nbut this is not a requirement."
      }
    },
    "140": {
      "nbr": 140,
      "value": "What is the output of the InfiniteMath program?\nclass Math {\npublic final double secret = 2;\n}\nclass ComplexMath extends Math {\npublic final double secret = 4;\n}\npublic class InfiniteMath extends ComplexMath {\npublic final double secret = 8;\npublic static void main(String[] numbers) {\nMath math = new InfiniteMath();\nSystem.out.print(math.secret);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "2.0"
      }, {
        "code": "B",
        "value": "4.0"
      }, {
        "code": "C",
        "value": "8.0"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but prints an exception at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "140. A. The code compiles without issue. Java allows methods to be\noverridden, but not variables. Therefore, marking them final does not\nprevent them from being reimplemented in a subclass. Furthermore,\npolymorphism does not apply in the same way it would to methods as it\ndoes to variables. In particular, the reference type determines the version of\nthe secret variable that is selected, making the output 2.0 and option A the\ncorrect answer."
      }
    },
    "141": {
      "nbr": 141,
      "value": "Given the following application, which diagram best represents the state of\nthe mySkier, mySpeed, and myName variables in the main() method after the\ncall to the slalom() method?\npackage slopes;\npublic class Ski {\nprivate int age = 18;\nprivate static void slalom(Ski racer,\nint[] speed, String name) {\nracer.age = 18;\nname = \"Wendy\";\nspeed = new int[1];\nspeed[0] = 11;\nracer = null;\n}\npublic static void main(String… mountain) {\nfinal var mySkier = new Ski();\nmySkier.age = 16;\nfinal int[] mySpeed = new int[1];\nfinal String myName = \"Rosie\";\nslalom(mySkier,mySpeed,myName);\n}\n}",
      "responses": [{
        "code": "A",
        "value": ""
      }, {
        "code": "B",
        "value": ""
      }, {
        "code": "C",
        "value": ""
      }, {
        "code": "D",
        "value": ""
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "141. C. To solve this problem, it helps to remember that Java is a pass‐by‐value\nlanguage in which copies of primitives and object references are sent to\nmethods. This also means that an object's data can be modified within a\nmethod and shared with the caller, but not the reference to the object. Any\nchanges to the object's reference within the method are not carried over to\nthe caller. In the slalom() method, the Ski object is updated with an age\nvalue of 18. Although the last line of the slalom() method changes the\nvariable value to null, it does not affect the mySkier object or reference in\nthe main() method. Therefore, the mySkier object is not null, and the age\nvariable is set to 18, making options A and D incorrect.\nNext, the name variable is reassigned to the Wendy object, but this does not\nchange the reference in the main() method, so myName remains Rosie.\nFinally, the speed array is assigned a new object and updated. Since the\narray is updated after the reference is reassigned, it does not affect the\nmySpeed array in the main() method. The result is that mySpeed continues to\nhave a single element with the default int value of 0. For these reasons,\noption B is incorrect, and option C is correct."
      }
    },
    "142": {
      "nbr": 142,
      "value": "What is the output of the following application?\npackage zoo;\npublic class Penguin {\nprivate int volume = 1;\nprivate class Chick {\nprivate static int volume = 3;\nvoid chick() {\nSystem.out.print(\"Honk(\"+Penguin.this.volume+\")!\");\n}\n}\npublic static void main(String… eggs) {\nPenguin pen = new Penguin();\nfinal Penguin.Chick littleOne = pen.new Chick();\nlittleOne.chick();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Honk(1)!"
      }, {
        "code": "B",
        "value": "Honk(3)!"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles, but the output cannot be determined until runtime."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "142. C. The Penguin class includes a member inner class Chick. Member inner\nclasses can only include static variables if they are marked final. Since\nthe variable volume is not marked final, the Chick does not compile,\nmaking option C correct. Note that the variable volume referenced in the\nchick() method is one defined in the Penguin outer class. If the final\nmodifier was added to the volume variable in the Chick class, then the rest\nof the code would compile, printing Honk(1)! at runtime."
      }
    },
    "143": {
      "nbr": 143,
      "value": "Which can implement a functional interface?",
      "responses": [{
        "code": "A",
        "value": "An anonymous class"
      }, {
        "code": "B",
        "value": "A top‐level class"
      }, {
        "code": "C",
        "value": "A lambda expression"
      }, {
        "code": "D",
        "value": "An anonymous class or a top‐level class"
      }, {
        "code": "E",
        "value": "A top‐level class or a lambda expression"
      }, {
        "code": "F",
        "value": "An anonymous class, a top‐level class, or a lambda expression"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "143. F. An anonymous class can implement a single interface, and a top‐level\nclass can implement any number of interfaces. Since a functional interface\nis an interface with additional rules, both anonymous class and top‐level\nclass are correct. Additionally, a lambda expression can also implement a\nfunctional interface. Since all three are correct, the answer is option F."
      }
    },
    "144": {
      "nbr": 144,
      "value": "Fill in the blank with the line of code that allows the program to compile\nand print E at runtime.\ninterface Fruit {\npublic default char getColor() { return 'F'; }\n}\ninterface Edible {\npublic default char getColor() { return 'E'; }\n}\npublic class Banana implements Fruit, Edible {\npublic char getColor() { return ____________; }\npublic static void main(String[] a) {\nvar d = new Banana();\nSystem.out.println(d.getColor());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Edible.getColor()"
      }, {
        "code": "B",
        "value": "Edible.super.getColor()"
      }, {
        "code": "C",
        "value": "super.Edible.getColor()"
      }, {
        "code": "D",
        "value": "super.getColor()"
      }, {
        "code": "E",
        "value": "The code does not compile regardless of what is inserted into the\nblank."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "144. B. The code compiles, even if the blank is replaced with a constant char\nvalue, making option E incorrect. Note that the class correctly overrides\nboth inherited default methods. It is possible to access a default method,\neven if it is overridden in the class, but requires using the super keyword\nproperly. Option B demonstrates the correct syntax. Note that option D\nwould not be correct even if there was only one inherited default method."
      }
    },
    "145": {
      "nbr": 145,
      "value": "Given the following two classes, each in a different package, which line\ninserted into the code allows the second class to compile?\npackage clothes;\npublic class Store {\npublic static String getClothes() { return \"dress\"; }\n}\npackage wardrobe;\n// INSERT CODE HERE\npublic class Closet {\npublic void borrow() {\nSystem.out.print(\"Borrowing clothes: \"+getClothes());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "static import clothes.Store.getClothes;"
      }, {
        "code": "B",
        "value": "import clothes.Store.*;"
      }, {
        "code": "C",
        "value": "import static clothes.Store.getClothes;"
      }, {
        "code": "D",
        "value": "import static clothes.Store;"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "145. C. Option A is incorrect because the keywords static and import are\nreversed. The Closet class uses the method getClothes() without a\nreference to the class name Store; therefore, a static import is required.\nFor this reason, option B is incorrect since it is missing the static\nkeyword. Option D is also incorrect since static imports are used with\nmembers of the class, not a class name. Finally, option C is the correct\nanswer since it properly imports the method into the class using a static\nimport."
      }
    },
    "146": {
      "nbr": 146,
      "value": "What is the output of the ElectricCar program?\npackage vehicles;\nclass Automobile {\nprivate final String drive() { return \"Driving vehicle\";\n}\n}\nclass Car extends Automobile {\nprotected String drive() { return \"Driving car\"; }\n}\npublic class ElectricCar extends Car {\npublic final String drive() { return \"Driving electric\ncar\"; }\npublic static void main(String[] wheels) {\nfinal Automobile car = new ElectricCar();\nvar v = (Car)car;\nSystem.out.print(v.drive());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Driving vehicle"
      }, {
        "code": "B",
        "value": "Driving electric car"
      }, {
        "code": "C",
        "value": "Driving car"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but produces a ClassCastException at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "146. B. The drive() method in the Car class does not override the private\nversion in the Automobile class since the method is not visible to the Car\nclass. Therefore, the final attribute in the Automobile class does not\nprevent the Car class from implementing a method with the same signature.\nThe drive() method in the ElectricCar class is a valid override of the\nmethod in the Car class, with the public access modifier expanding access\nin the subclass. In the main() method, the object created is an ElectricCar,\neven if it is assigned to a Car or Automobile reference. Due to\npolymorphism, the method from the ElectricCar will be invoked, making\noption B the correct answer."
      }
    },
    "147": {
      "nbr": 147,
      "value": "What is the output of the following program?\npublic class Music {\n{ System.out.print(\"do-\"); }\nstatic { System.out.print(\"re-\"); }\n{ System.out.print(\"mi-\"); }\nstatic { System.out.print(\"fa-\"); }\npublic Music() {\nSystem.out.print(\"so-\");\n}\npublic Music(int note) {\nSystem.out.print(\"la-\");\n}\npublic static void main(String[] sound) {\nSystem.out.print(\"ti-\");\nvar play = new Music();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "re‐fa‐ti‐do‐mi‐so‐"
      }, {
        "code": "B",
        "value": "do‐re‐mi‐fa‐ti‐so‐"
      }, {
        "code": "C",
        "value": "ti‐re‐fa‐do‐mi‐so‐"
      }, {
        "code": "D",
        "value": "re‐fa‐la‐mi‐ti‐do‐"
      }, {
        "code": "E",
        "value": "do‐re‐mi‐fa‐so‐ti"
      }, {
        "code": "F",
        "value": "The code does not compile."
      }, {
        "code": "G",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "147. A. The code compiles, so option F is incorrect. The Music class is loaded,\nand the static initializers are executed in order, with re‐fa‐ being printed\nfirst. Next, the first line of the main() method is executed, printing ti‐. The\nsecond line of the main() method creates a Music object, with the instance\ninitializers being called first, printing do‐mi‐. Finally, the no‐argument\nconstructor is executed, and so‐ is printed last."
      }
    },
    "148": {
      "nbr": 148,
      "value": "Given the following class declaration, which options correctly declare a\nlocal variable containing an instance of the class?\npublic class Earth {\nprivate abstract class Sky {\nvoid fall() {\nvar e = ____________\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "new Sunset() extends Sky {};"
      }, {
        "code": "B",
        "value": "new Sky();"
      }, {
        "code": "C",
        "value": "new Sky() {}"
      }, {
        "code": "D",
        "value": "new Sky() { final static int blue = 1; };"
      }, {
        "code": "E",
        "value": "The code does not compile regardless of what is placed in the blank."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "148. D. All of the options attempt to create an instance using an anonymous\nclass that extends Sky. Option A is incorrect because when you create an\nanonymous class, you do not specify a name. Even if there was a Sunset\nclass, the declaration of an anonymous class can only extend or implement\none type directly. Since it would already extend Sunset, it cannot specify\nSky at the same time. Option B is incorrect because Sky is abstract and\ncannot be instantiated directly. Option C is incorrect because it is missing a\nsemicolon (;) at the end. Option D is the correct answer. Remember that all\nnested classes can have static variables if they are marked final."
      }
    },
    "149": {
      "nbr": 149,
      "value": "What is the output of the Encyclopedia program?\npackage paper;\nabstract class Book {\nprotected static String material = \"papyrus\";\npublic Book() {}\nabstract String read() {}\npublic Book(String material) {this.material = material;}\n}\npublic class Encyclopedia extends Book {\npublic static String material = \"cellulose\";\npublic Encyclopedia() {super();}\npublic String read() { return \"Reading is fun!\"; }\npublic String getMaterial() {return super.material;}\npublic static void main(String[] pages) {\nSystem.out.print(new Encyclopedia().read());\nSystem.out.print(\"-\" + new\nEncyclopedia().getMaterial());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Reading is fun!‐papyrus"
      }, {
        "code": "B",
        "value": "Reading is fun!‐cellulose"
      }, {
        "code": "C",
        "value": "null‐papyrus"
      }, {
        "code": "D",
        "value": "null‐cellulose"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "149. E. The code may look complicated, but it does not compile for a simple\nreason. The abstract read() method defined in Book cannot have a\nmethod body. Since it does, the code does not compile, and option E is\ncorrect."
      }
    },
    "150": {
      "nbr": 150,
      "value": "What does the following print?\ninterface Vehicle {}\nclass Bus implements Vehicle {}\npublic class Transport {\npublic static void main(String[] args) {\nBus bus = new Bus();\nboolean n = null instanceof Bus;\nboolean v = bus instanceof Vehicle;\nboolean b = bus instanceof Bus;\nSystem.out.println(n + \" \" + v + \" \" + b);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "false false false"
      }, {
        "code": "B",
        "value": "false false true"
      }, {
        "code": "C",
        "value": "false true true"
      }, {
        "code": "D",
        "value": "true false true"
      }, {
        "code": "E",
        "value": "true true false"
      }, {
        "code": "F",
        "value": "true true true"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "150. C. While using null with instanceof compiles, it always returns false.\nThe other two instanceof calls show that instanceof can be used with\nboth classes and interfaces. They both return true since Bus implements\nVehicle, making option C correct."
      }
    },
    "151": {
      "nbr": 151,
      "value": "How many rows of the following table contain an error?\nInterface member Optional modifier(s) Required modifier(s)\nPrivate method private ‐\nDefault method public default\nStatic method public static ‐\nAbstract method public abstract",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "151. D. The first row is incorrect as the private modifier is required for\nprivate interface methods. The second row is correct. The third row is also\nincorrect because the static modifier is required, not optional, for static\ninterface methods. The public modifier is optional, though, as the static\nmethod is implicitly public without it. The last row is incorrect as the\nabstract modifier can be implied if the method does not declare a body.\nSince three rows contain an error, option D is correct."
      }
    },
    "152": {
      "nbr": 152,
      "value": "What is the output of the following program?\npublic class Dwarf {\nprivate final String name;\npublic Dwarf() {\nthis(\"Bashful\");\n}\npublic Dwarf(String name) {\nname = \"Sleepy\";\n}\npublic static void main(String[] sound) {\nvar d = new Dwarf(\"Doc\");\nSystem.out.println(d.name);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Sleepy"
      }, {
        "code": "B",
        "value": "Bashful"
      }, {
        "code": "C",
        "value": "Doc"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "152. D. A final instance variable must be assigned a value when it is declared,\nin an instance initializer, or by a constructor. The Dwarf(String)\nconstructor does not assign a value since it contains a local variable called\nname already. For this reason, this constructor does not compile, and option\nD is correct. If the assignment in the constructor was changed to this.name,\nthen the program would compile and print Sleepy."
      }
    },
    "153": {
      "nbr": 153,
      "value": "What is the output of the following application?\npackage pocketmath;\ninterface AddNumbers {\nint add(int x, int y);\nstatic int subtract(int x, int y) { return x-y; }\ndefault int multiply(int x, int y) { return x*y; }\n}\npublic class Calculator {\nprotected void calculate(AddNumbers n, int a, int b) {\nSystem.out.print(n.add(a, b));\n}\npublic static void main(String[] moreNumbers) {\nfinal var ti = new Calculator() {};\nti.calculate((k,p) -> p+k+1, 2, 5); // j1\n}\n}",
      "responses": [{
        "code": "A",
        "value": "8"
      }, {
        "code": "B",
        "value": "The code does not compile because AddNumbers is not a functional\ninterface."
      }, {
        "code": "C",
        "value": "The code does not compile because of line j1."
      }, {
        "code": "D",
        "value": "The code does not compile for a different reason."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "153. A. The AddNumbers interface is a valid functional interface. While it\nincludes both static and default methods, it includes only one abstract\nmethod, the precise requirement for it to be considered a functional\ninterface, making option B incorrect. The class compiles and prints 8 at\nruntime, making option A correct."
      }
    },
    "154": {
      "nbr": 154,
      "value": "Which of the following variables are always in scope for the entire program\nonce defined?",
      "responses": [{
        "code": "A",
        "value": "Package variables"
      }, {
        "code": "B",
        "value": "Class variables"
      }, {
        "code": "C",
        "value": "Instance variables"
      }, {
        "code": "D",
        "value": "Local variables"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "154. B. There is no such thing as package variables, so option A is incorrect.\nOption C is incorrect as the variable is only in scope within a specific\ninstance of the class. Option D is also incorrect as the variable is only in\nscope for a single method that it is defined in. Option B is the only correct\nanswer as class variables are in scope within the program."
      }
    },
    "155": {
      "nbr": 155,
      "value": "What is the command to call one constructor from another constructor in\nthe same class?",
      "responses": [{
        "code": "A",
        "value": "construct()"
      }, {
        "code": "B",
        "value": "parent()"
      }, {
        "code": "C",
        "value": "super()"
      }, {
        "code": "D",
        "value": "this()"
      }, {
        "code": "E",
        "value": "that()"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "155. D. The super() statement is used to call a constructor in a parent class,\nwhile the this() statement is used to call a constructor in the same class,\nmaking option D correct and option C incorrect. Options A, B, and E are\nincorrect because they are not built‐in functionality in Java."
      }
    },
    "156": {
      "nbr": 156,
      "value": "Which of the following statements about no‐argument constructors and\ninheritance are correct? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "The compiler cannot insert a no‐argument constructor into an abstract\nclass."
      }, {
        "code": "B",
        "value": "If a parent class does not include a no‐argument constructor, a child\nclass cannot declare one."
      }, {
        "code": "C",
        "value": "If a parent class declares constructors but each of them take at least\none parameter, then a child class must declare at least one constructor."
      }, {
        "code": "D",
        "value": "The no‐argument constructor is sometimes inserted by the compiler."
      }, {
        "code": "E",
        "value": "If a parent class declares a no‐argument constructor, a child class must\ndeclare a no‐argument constructor."
      }, {
        "code": "F",
        "value": "If a parent class declares a no‐argument constructor, a child class must\ndeclare at least one constructor."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "156. C,D. The default no‐argument instructor is inserted by the compiler\nwhenever a class, abstract or concrete, does not declare any constructors.\nFor this reason, option A is incorrect, and option D is correct. Even if a\nparent class does not declare a no‐argument constructor, the child class can\nstill declare one, making option B incorrect. If the parent class does not\ndeclare a no‐argument constructor (and none is inserted by the compiler),\nthen the child class must declare at least one constructor, making option C\ncorrect. Without a constructor call, inserting the default no‐argument\nconstructor into the child class would lead to a compiler error on the\nimplicit super() call. Finally, options E and F are incorrect, as a child class\nof a parent with a no‐argument constructor is free to declare or not declare\nany constructors."
      }
    },
    "157": {
      "nbr": 157,
      "value": "Fill in the blanks: ______________ allow Java to support multiple\ninheritance, and anonymous classes can ______________ of them.",
      "responses": [{
        "code": "A",
        "value": "Abstract classes, extend at most one"
      }, {
        "code": "B",
        "value": "Abstract classes, extend any number"
      }, {
        "code": "C",
        "value": "Interfaces, implement at most one"
      }, {
        "code": "D",
        "value": "Interfaces, implement any number"
      }, {
        "code": "E",
        "value": "Concrete classes, extend at most one"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "157. C. Interfaces allow Java to support multiple inheritance because a class\nmay implement any number of interfaces. On the other hand, an anonymous\nclass may implement or extend at most one interface or class, respectively,\nsince it does not have a class definition. For these reasons, option C is the\ncorrect answer."
      }
    },
    "158": {
      "nbr": 158,
      "value": "What is the result of executing the Grasshopper program?\n// Hopper.java\npackage com.animals;\npublic class Hopper {\nprotected void hop() {\nSystem.out.println(\"hop\");\n}\n}\n// Grasshopper.java\npackage com.insect;\nimport com.animals.Hopper;\npublic class Grasshopper extends Hopper {\npublic void move() {\nhop(); // p1\n}\npublic static void main(String[] args) {\nvar hopper = new Grasshopper();\nhopper.move(); // p2\nhopper.hop(); // p3\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code prints hop once."
      }, {
        "code": "B",
        "value": "The code prints hop twice."
      }, {
        "code": "C",
        "value": "The first compiler error is on line p1."
      }, {
        "code": "D",
        "value": "The first compiler error is on line p2."
      }, {
        "code": "E",
        "value": "The first compiler error is on line p3."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "158. B. The hop() method has protected access, which allows subclasses to\ncall it. Both the move() method and main() method are allowed to call\nhop() since Grasshopper is a subclass. The code runs without error and\nprints hop twice, making option B the answer."
      }
    },
    "159": {
      "nbr": 159,
      "value": "What is the minimum number of lines that need to be removed to make this\ncode compile?\n@FunctionalInterface\npublic interface Play {\npublic static void baseball() {}\nprivate static void soccer() {}\ndefault void play() {}\nvoid fun();\nvoid game();\nvoid toy();\n}",
      "responses": [{
        "code": "A",
        "value": "1"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "3"
      }, {
        "code": "D",
        "value": "4"
      }, {
        "code": "E",
        "value": "The code compiles as is."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "159. A. This code is not a functional interface because it has three abstract\nmethods: fun(), game(), and toy(). Removing two of these three methods\nwould cause the code to compile. However, there is no requirement that the\ncode be a functional interface. Since it only needs to compile, removing the\n@FunctionalInterface annotation would also cause the code to compile.\nOption A is correct since only the annotation needs to be removed."
      }
    },
    "160": {
      "nbr": 160,
      "value": "Which of the following are the best reasons for creating a private interface\nmethod? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Add backward compatibility to existing interfaces."
      }, {
        "code": "B",
        "value": "Provide an implementation that a class implementing the interface can\noverride."
      }, {
        "code": "C",
        "value": "Increase code reuse within the interface."
      }, {
        "code": "D",
        "value": "Allow interface methods to be inherited."
      }, {
        "code": "E",
        "value": "Improve encapsulation of the interface."
      }, {
        "code": "F",
        "value": "Allow static methods to access instance methods."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "160. C,E. Options A and B are incorrect and describe properties of default\ninterface methods. Option C is correct and one of the primary reasons to\nadd a private interface method. Option D is not a property of private\ninterface methods. Option E is also correct, as private interface methods\nare not exposed to classes implementing the interface. Option F is a\nnonsensical statement."
      }
    },
    "161": {
      "nbr": 161,
      "value": "What is the result of executing the Sounds program?\n// Sheep.java\npackage com.mammal;\npublic class Sheep {\nprivate void baa() {\nSystem.out.println(\"baa!\");\n}\nprivate void speak() {\nbaa();\n}\n}\n// Sounds.java\npackage com.animals;\nimport com.mammal.Sheep;\npublic class Sounds {\npublic static void main(String[] args) {\nvar sheep = new Sheep();\nsheep.speak();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code runs and prints baa!."
      }, {
        "code": "B",
        "value": "The Sheep class does not compile."
      }, {
        "code": "C",
        "value": "The Sounds class does not compile."
      }, {
        "code": "D",
        "value": "Neither class compiles."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "161. C. The speak() method has private access, which does not allow code\noutside the class to call it. Therefore, option C is the answer."
      }
    },
    "162": {
      "nbr": 162,
      "value": "What is the output of the following application?\npackage stocks;\npublic class Bond {\nprivate static int price = 5;\npublic boolean sell() {\nif(price<10) {\nprice++;\nreturn true;\n} else if(price>=10) {\nreturn false;\n}\n}\npublic static void main(String[] cash) {\nnew Bond().sell();\nnew Bond().sell();\nnew Bond().sell();\nSystem.out.print(price);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "5"
      }, {
        "code": "B",
        "value": "6"
      }, {
        "code": "C",
        "value": "8"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "162. D. The sell() method does not compile because it does not return a value\nif both of the if‐then statements’ conditional expressions evaluate to false.\nWhile logically it is true that price is either less than 10 or greater than or\nequal to 10, the compiler does not know that. It just knows that if both ifthen\nstatements evaluate to false, then it does not have a return value;\ntherefore, it does not compile."
      }
    },
    "163": {
      "nbr": 163,
      "value": "Given the following class declaration, what expression can be used to fill in\nthe blank so that 88 is printed at runtime?\nfinal public class Racecar {\nfinal private int speed = 88;\nfinal protected class Engine {\nprivate final int speed = 100;\npublic final int getSpeed() {\nreturn _____________________;\n}\n}\nfinal Engine engine = new Engine();\nfinal public static void main(String[] feed) {\nSystem.out.print(new Racecar().engine.getSpeed());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Racecar.speed"
      }, {
        "code": "B",
        "value": "this.speed"
      }, {
        "code": "C",
        "value": "this.Racecar.speed"
      }, {
        "code": "D",
        "value": "Racecar.Engine.this.speed"
      }, {
        "code": "E",
        "value": "Racecar.this.speed"
      }, {
        "code": "F",
        "value": "The code does not compile regardless of what is placed in the blank."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "163. E. Options A and C do not compile, as they are invalid ways of accessing\na member variable. Options B and D both compile but print 100 at runtime,\nsince they reference the speed variable defined in the Engine class. Option\nE is the correct answer, accessing the speed variable in the Racecar class\nand printing 88 at runtime."
      }
    },
    "164": {
      "nbr": 164,
      "value": "Which statements about static initializers are correct? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "They cannot be used to create instances of the class they are contained\nin."
      }, {
        "code": "B",
        "value": "They can assign a value to a static final variable."
      }, {
        "code": "C",
        "value": "They are executed at most once per program."
      }, {
        "code": "D",
        "value": "They are executed each time an instance of the class is created from a\nlocal cache of objects."
      }, {
        "code": "E",
        "value": "They are executed each time an instance of the class is created using\nthe new keyword."
      }, {
        "code": "F",
        "value": "They may never be executed."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "F"
        ],
        "explanation": "164. B,C,F. A static initializer can create instances of any class it has access\nto, so option A is incorrect. It can assign values to static final variables,\nspecifically ones that have not been assigned a value already, so option B is\ncorrect. A static initializer is executed when the class is first loaded, not\nwhen an object is created or loaded, making option C correct, and options D\nand E incorrect. If the class is never loaded, then they will not be executed,\nmaking option F correct."
      }
    },
    "165": {
      "nbr": 165,
      "value": "What is the output of the BlueCar program?\npackage race;\nabstract class Car {\nstatic { System.out.print(\"1\"); }\npublic Car(String name) {\nsuper();\nSystem.out.print(\"2\");\n}\n{ System.out.print(\"3\"); }\n}\npublic class BlueCar extends Car {\n{ System.out.print(\"4\"); }\npublic BlueCar() {\nsuper(\"blue\");\nSystem.out.print(\"5\");\n}\npublic static void main(String[] gears) {\nnew BlueCar();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "23451"
      }, {
        "code": "B",
        "value": "12345"
      }, {
        "code": "C",
        "value": "14523"
      }, {
        "code": "D",
        "value": "13245"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "165. D. The class is loaded first, with the static initialization block called and\n1 is printed. When the BlueCar is created in the main() method, the\nsuperclass initialization happens first. The instance initialization blocks are\nexecuted before the constructor, so 32 is outputted next. Finally, the object\nis created with the instance initialization blocks again being called before\nthe constructor, outputting 45. The result is that 13245 is printed, making\noption D the correct answer."
      }
    },
    "166": {
      "nbr": 166,
      "value": "Given the following class declaration, which value cannot be inserted into\nthe blank line that would allow the code to compile?\npackage mammal;\ninterface Pet {}\npublic class Canine implements Pet {\npublic ______ getDoggy() {\nreturn this;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Canine"
      }, {
        "code": "B",
        "value": "List"
      }, {
        "code": "C",
        "value": "Object"
      }, {
        "code": "D",
        "value": "Pet"
      }, {
        "code": "E",
        "value": "All of the above can be inserted."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "166. B. Recall that this refers to an instance of the current class. Therefore,\nany superclass of Canine can be used as a return type of the method,\nincluding Canine itself, making option A an incorrect answer. Option D is\nalso incorrect because Canine implements the Pet interface. An instance of\na class can be assigned to any interface reference that it inherits. Option C\nis incorrect because Object is the superclass of all instances in Java.\nFinally, option B is the correct answer. Canine cannot be returned as an\ninstance of List because Canine does not inherit List."
      }
    },
    "167": {
      "nbr": 167,
      "value": "Which statement about the following interface is correct?\npublic interface Movie {\nString pass = \"TICKET\";\nprivate void buyPopcorn() {\npurchaseTicket();\n}\npublic static int getDrink() {\nbuyPopcorn();\nreturn 32;\n}\nprivate static String purchaseTicket() {\ngetDrink();\nreturn pass;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code compiles."
      }, {
        "code": "B",
        "value": "The code contains an invalid constant."
      }, {
        "code": "C",
        "value": "The method buyPopcorn() does not compile."
      }, {
        "code": "D",
        "value": "The method getDrink() does not compile."
      }, {
        "code": "E",
        "value": "The method purchaseTicket() does not compile."
      }, {
        "code": "F",
        "value": "The code does not compile for a different reason."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "167. D. The static method getDrink() attempts to access an instance‐based\nprivate method buyPopcorn() that results in a compiler error, making\noption D correct. The rest of the code compiles without issue."
      }
    },
    "168": {
      "nbr": 168,
      "value": "Which methods compile?\nprivate static int numShovels;\nprivate int numRakes;\npublic int getNumShovels() {\nreturn numShovels;\n}\npublic int getNumRakes() {\nreturn numRakes;\n}",
      "responses": [{
        "code": "A",
        "value": "Just getNumRakes()"
      }, {
        "code": "B",
        "value": "Just getNumShovels()"
      }, {
        "code": "C",
        "value": "Both methods"
      }, {
        "code": "D",
        "value": "Neither method"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "168. C. An instance method can access both instance variables and static\nvariables. Both methods compile, and option C is correct."
      }
    },
    "169": {
      "nbr": 169,
      "value": "How many lines of the following class contain compilation errors?\n1: class Fly {\n2: public Fly Fly() { return Fly(); }\n3: public void Fly(int kite) {}\n4: public int Fly(long kite) { return 1; }\n5: public static void main(String[] a) {\n6: var f = new Fly();\n7: f.Fly();\n8: }\n9: }",
      "responses": [{
        "code": "A",
        "value": "None."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "The answer cannot be determined with the information given."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "169. A. As ugly as the class looks, it does compile, making option A correct.\nLines 2–4 each define an instance method since they each have a name and\nreturn type. There is no rule saying you cannot define a method with the\nsame name as the class, although it is considered bad style. The main()\nmethod calls the default no‐argument constructor on line 6, inserted by the\ncompiler. Finally, line 7 calls the method declared on line 2."
      }
    },
    "170": {
      "nbr": 170,
      "value": "How many of the classes in the figure can write code that references the\nsky() method?",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "170. C. This method has package‐private access, which means only classes in\nthe same package can access it. In our case, this is the Red and Blue classes,\nmaking option C correct."
      }
    },
    "171": {
      "nbr": 171,
      "value": "For the diagram in the previous question, how many classes can write code\nthat references the light variable?",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "171. D. This variable has protected access, which means code in the same\npackage can access it in addition to subclasses. There are two classes in the\ncom.color package and one class that subclasses it, making option D the\nanswer."
      }
    },
    "172": {
      "nbr": 172,
      "value": "Given the following method signature, which classes cannot call it?\nprotected void run(String government)",
      "responses": [{
        "code": "A",
        "value": "All classes in other packages"
      }, {
        "code": "B",
        "value": "All classes in the same package"
      }, {
        "code": "C",
        "value": "Subclasses in a different package"
      }, {
        "code": "D",
        "value": "Subclasses in the same package"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "172. A. The protected modifier allows access to the same package and\nsubclasses, which are options B, C, and D. Therefore, the correct answer is\noption A."
      }
    },
    "173": {
      "nbr": 173,
      "value": "What is the output of the following application?\ninterface Toy { String play(); }\npublic class Gift {\npublic static void main(String[] matrix) {\nabstract class Robot {}\nclass Transformer extends Robot implements Toy {\npublic String name = \"GiantRobot\";\npublic String play() {return \"DinosaurRobot\";} //\ny1\n}\nTransformer prime = new Transformer () {\npublic String play() {return name;} //\ny2\n};\nSystem.out.print(prime.play()+\" \"+name);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "GiantRobot GiantRobot"
      }, {
        "code": "B",
        "value": "GiantRobot DinosaurRobot"
      }, {
        "code": "C",
        "value": "DinosaurRobot DinosaurRobot"
      }, {
        "code": "D",
        "value": "The code does not compile because of line y1."
      }, {
        "code": "E",
        "value": "The code does not compile because of line y2."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "173. F. The declarations of the local classes Robot and Transformer compile\nwithout issue. The only compilation problem in this program is the last line\nof the main() method. The variable name is defined inside the local class\nand not accessible outside class declaration without a reference to the local\nclass. Due to scope, this last line of the main() method does not compile,\nmaking option F the correct answer. Note that the first part of the print()\nstatement in the main() method, if the code compiled, would print\nGiantRobot."
      }
    },
    "174": {
      "nbr": 174,
      "value": "What is the output of the HighSchool application?\npackage edu;\nimport java.io.FileNotFoundException;\nabstract class School {\nabstract Float getNumTeachers();\npublic int getNumStudents() {\nreturn 10;\n}\n}\npublic class HighSchool extends School {\nfinal Float getNumTeachers() { return 4f; }\npublic int getNumStudents() throws FileNotFoundException\n{\nreturn 20;\n}\npublic static void main(String[] s) throws Exception {\nvar school = new HighSchool();\nSystem.out.print(school.getNumStudents());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "10"
      }, {
        "code": "B",
        "value": "20"
      }, {
        "code": "C",
        "value": "4.0"
      }, {
        "code": "D",
        "value": "One line of the program does not compile."
      }, {
        "code": "E",
        "value": "Two lines of the program do not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "174. D. When overriding a method, a new or broader checked exception cannot\nbe declared. The getNumStudents() method in HighSchool is an invalid\noverride since it declares FileNotFoundException, which is not declared in\nthe parent method. Since this is the only line that does not compile, option\nD is correct. Note that an abstract method can be overridden with a final\nmethod, as shown with getNumTeachers()."
      }
    },
    "175": {
      "nbr": 175,
      "value": "What is the output of the following application?\npackage track;\ninterface Run {\ndefault CharSequence walk() {\nreturn \"Walking and running!\";\n}\n}\ninterface Jog {\ndefault String walk() {\nreturn \"Walking and jogging!\";\n}\n}\npublic class Sprint implements Run, Jog {\npublic String walk() {\nreturn \"Sprinting!\";\n}\npublic static void main(String[] args) {\nvar s = new Sprint();\nSystem.out.println(s.walk());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Walking and running!"
      }, {
        "code": "B",
        "value": "Walking and jogging!"
      }, {
        "code": "C",
        "value": "Sprinting!"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but prints an exception at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "175. C. Having one class implement two interfaces that both define the same\ndefault method signature leads to a compiler error unless the class\noverrides the default method. In this case, the Sprint class overrides both\nwalk() methods correctly; therefore, the code compiles without issue, and\noption C is correct. Note that the return types of the two default methods\nare different, but the overridden method uses a return type that is covariant\nwith both."
      }
    },
    "176": {
      "nbr": 176,
      "value": "What is true of these two interfaces?\ninterface Crawl {\nvoid wriggle();\n}\ninterface Dance {\npublic void wriggle();\n}",
      "responses": [{
        "code": "A",
        "value": "A concrete class can implement both, but must implement wriggle()."
      }, {
        "code": "B",
        "value": "A concrete class can implement both, but must not implement\nwriggle()."
      }, {
        "code": "C",
        "value": "A concrete class would only be able to implement both if the public\nmodifier were removed but must implement wriggle()."
      }, {
        "code": "D",
        "value": "If the public modifier were removed, a concrete class can implement\nboth, but must not implement wriggle()."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "176. A. Interface methods are implicitly public, giving both the same\nsignature. This means a class implementing them must implement a single\nwriggle() method, and option A is correct."
      }
    },
    "177": {
      "nbr": 177,
      "value": "Which of these are functional interfaces?\ninterface Lion {\npublic void roar();\ndefault void drink() {}\nboolean equals(Lion lion);\n}\ninterface Tiger {\npublic void roar();\ndefault void drink() {}\nString toString(String name);\n}",
      "responses": [{
        "code": "A",
        "value": "Lion"
      }, {
        "code": "B",
        "value": "Tiger"
      }, {
        "code": "C",
        "value": "Both Lion and Tiger"
      }, {
        "code": "D",
        "value": "Neither is a functional interface."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "177. D. The code does compile, so option E is incorrect. A functional interface\nis required to have exactly one abstract method. Both interfaces have two.\nIn both interfaces, roar() is abstract. The equals(Lion) method is\nsimilar to the equals(Object) in Object but is not an override of that\nmethod. Similarly, the toString() method in Tiger is also an abstract\nmethod. While there is a toString() method in Object, it does not take\nany parameters. Since each method has two abstract methods, neither is a\nfunctional interface, making option D the answer."
      }
    },
    "178": {
      "nbr": 178,
      "value": "How many lines of the following class contain a compiler error?\n1: public class Dragon {\n2: boolean scaly;\n3: static final int gold;\n4: Dragon protectTreasure(int value, boolean scaly) {\n5: scaly = true;\n6: return this;\n7: }\n8: static void fly(boolean scaly) {\n9: scaly = true;\n10: }\n11: int saveTheTreasure(boolean scaly) {\n12: return this.gold;\n13: }\n14: static void saveTheDay(boolean scaly) {\n15: this.gold = 0;\n16: }\n17: static { gold = 100; }\n18: }",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "More than three"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "178. B. The gold variable is marked final, which means it must be set either\nwhen it is declared or in a static initializer, as shown on line 17. It cannot\nbe modified by a method, though, so line 15 does not compile. Since this is\nthe only line that does not compile, option B is correct. Line 8 compiles\nbecause the static method is modifying the local variable scaly, not the\ninstance variable of the same name. Line 12 also compiles. While accessing\na static variable via an instance is not recommended, it is allowed."
      }
    },
    "179": {
      "nbr": 179,
      "value": "What is true of the following method?\npublic String getColor() {\nreturn color;\n}",
      "responses": [{
        "code": "A",
        "value": "It is a correctly implemented accessor method."
      }, {
        "code": "B",
        "value": "It is a correctly implemented mutator method."
      }, {
        "code": "C",
        "value": "It is an incorrectly implemented accessor method."
      }, {
        "code": "D",
        "value": "It is an incorrectly implemented mutator method."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "179. A. The method is a correct getter or accessor, making option A is correct."
      }
    },
    "180": {
      "nbr": 180,
      "value": "Which statement is true?",
      "responses": [{
        "code": "A",
        "value": "You can always change a method signature from call(String[] arg)\nto call(String… arg) without causing a compiler error in the calling\ncode."
      }, {
        "code": "B",
        "value": "You can always change a method signature from call(String… arg)\nto call(String[] arg) without causing a compiler error in the\nexisting code."
      }, {
        "code": "C",
        "value": "Both of the above."
      }, {
        "code": "D",
        "value": "Neither of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "180. A. From within a method, an array parameter and a varargs parameter are\ntreated the same. From the caller, an array parameter is more restrictive.\nBoth types can receive an array. However, only a varargs parameter is\nallowed to automatically turn individual parameters into an array.\nTherefore, the answer is option A."
      }
    },
    "181": {
      "nbr": 181,
      "value": "What are two motivations for marking a class final? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Guarantee behavior of a class"
      }, {
        "code": "B",
        "value": "Allow the class to be extended"
      }, {
        "code": "C",
        "value": "Improve security"
      }, {
        "code": "D",
        "value": "Support polymorphism"
      }, {
        "code": "E",
        "value": "Improve performance"
      }, {
        "code": "F",
        "value": "Ensure the contents of the class are immutable"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "181. A,C. Marking a class final tends to improve security by guaranteeing the\nbehavior of a class is not replaced by overridden methods at runtime. For\nthis reason, options A and C are correct. Option B is incorrect and is the\nopposite of what marking a class final does. Options D and E are incorrect\nand have nothing to do with marking a class final. Option F is incorrect as\nthe contents of the class can still be changed, even if the class is marked\nfinal."
      }
    },
    "182": {
      "nbr": 182,
      "value": "Which statement about the following interface is correct?\npublic interface Planet {\nint circumference;\npublic abstract void enterAtmosphere();\npublic default int getCircumference() {\nenterAtmosphere();\nreturn circumference;\n}\nprivate static void leaveOrbit() {\nvar earth = new Planet() {\npublic void enterAtmosphere() {}\n};\nearth.getCircumference();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code compiles."
      }, {
        "code": "B",
        "value": "The method enterAtmosphere() does not compile."
      }, {
        "code": "C",
        "value": "The method getCircumference() does not compile."
      }, {
        "code": "D",
        "value": "The method leaveOrbit() does not compile."
      }, {
        "code": "E",
        "value": "The code does not compile for a different reason."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "182. E. The code does not compile because the constant variable\ncircumference does not declare a value, making option E correct.\nRemember that all variables within interfaces are implicitly static and\nfinal. The rest of the lines of code compile without issue. Note that while\nthe static method leaveOrbit() cannot access the instance‐based\ndefault method getCircumference() directly, it can through the reference\nvariable earth."
      }
    },
    "183": {
      "nbr": 183,
      "value": "Fill in the blanks: ___________________ methods always have the same\nname but a different list of parameters, while ___________________\nmethods always have the same name and the same return type.",
      "responses": [{
        "code": "A",
        "value": "Overloaded, overridden"
      }, {
        "code": "B",
        "value": "Inherited, overridden"
      }, {
        "code": "C",
        "value": "Overridden, overloaded"
      }, {
        "code": "D",
        "value": "Hidden, overloaded"
      }, {
        "code": "E",
        "value": "Overridden, hidden"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "183. F. Trick question! Overloaded methods is correct in the first part of the\nsentence, but none of the answers is correct in the second part of the\nsentence. Remember, overridden methods can have covariant return types.\nThey do not need to be the same. For this reason, option F is the correct\nanswer."
      }
    },
    "184": {
      "nbr": 184,
      "value": "What is the output of the following program?\npublic class Husky {\n{ this.food = 10; }\n{ this.toy = 2; }\nprivate final int toy;\nprivate static int food;\npublic Husky(int friend) {\nthis.food += friend++;\nthis.toy -= friend--;\n}\npublic static void main(String… unused) {\nvar h = new Husky(2);\nSystem.out.println(h.food+\",\"+h.toy);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "12,‐1"
      }, {
        "code": "B",
        "value": "12,2"
      }, {
        "code": "C",
        "value": "13,‐1"
      }, {
        "code": "D",
        "value": "Exactly one line of this class does not compile."
      }, {
        "code": "E",
        "value": "Exactly two lines of this class do not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "184. D. This class creates a final instance toy variable, but it is assigned a\nvalue twice. First, it is assigned a value in an instance initializer and then in\na constructor. For this reason, the second line of the constructor does not\ncompile, and option D is correct. The first line of the constructor, in which\na static variable is referenced from an instance variable, is permitted but\ndiscouraged. Also, initializers may reference variables defined later in the\nclass declaration."
      }
    },
    "185": {
      "nbr": 185,
      "value": "Suppose you have the following code. Which of the images best represents\nthe state of the references right before the end of the main() method,\nassuming garbage collection hasn't run?\n1: public class Link {\n2: private String name;\n3: private Link next;\n4: public Link(String name, Link next) {\n5: this.name = name;\n6: this.next = next;\n7: }\n8: public void setNext(Link next) {\n9: this.next = next;\n10: }\n11: public Link getNext() {\n12: return next;\n13: }\n14: public static void main(String… args) {\n15: var apple = new Link(\"x\", null);\n16: var orange = new Link(\"y\", apple);\n17: var banana = new Link(\"z\", orange);\n18: orange.setNext(banana);\n19: banana.setNext(orange);\n20: apple = null;\n21: banana = null;\n22: }\n23: }",
      "responses": [{
        "code": "A",
        "value": "Option A."
      }, {
        "code": "B",
        "value": "Option B."
      }, {
        "code": "C",
        "value": "Option C."
      }, {
        "code": "D",
        "value": "Option D."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "185. C. Lines 15–17 create the three objects. Lines 18–19 change the\nreferences, so orange and banana point to each other. Lines 20–21 wipe out\ntwo of the original references. This means the object with name as x is\ninaccessible. Option C matches this scenario."
      }
    },
    "186": {
      "nbr": 186,
      "value": "Which statement about a no‐argument constructor is true?",
      "responses": [{
        "code": "A",
        "value": "The Java compiler will always insert a default no‐argument\nconstructor if you do not define a no‐argument constructor in your\nclass."
      }, {
        "code": "B",
        "value": "For a class to call super() in one of its constructors, its parent class\nmust explicitly implement a no‐argument constructor."
      }, {
        "code": "C",
        "value": "If a class extends another class that has only one constructor that takes\na value, then the child class must explicitly declare at least one\nconstructor."
      }, {
        "code": "D",
        "value": "A class may contain more than one no‐argument constructor."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "186. C. Option A is incorrect because Java inserts a no‐argument constructor\nonly if there are no other constructors in the class. Option B is incorrect\nbecause the parent can have a default no‐argument constructor, which is\ninserted by the compiler and accessible in the child class. Option D is\nincorrect. A class that contains two no‐argument constructors will not\ncompile because they would have the same signature. Finally, option C is\ncorrect. If a class extends a parent class that does not include a no‐argument\nconstructor, the default no‐argument constructor cannot be automatically\ninserted into the child class by the compiler. Instead, the developer must\nexplicitly declare at least one constructor and explicitly define how the call\nto the parent constructor is made."
      }
    },
    "187": {
      "nbr": 187,
      "value": "Which variable declaration is the first line not to compile?\npublic class Complex {\nclass Building {}\nclass House extends Building{}\npublic void convert() {\nBuilding b1 = new Building();\nHouse h1 = new House();\nBuilding b2 = new House();\nBuilding b3 = (House) b1;\nHouse h2 = (Building) h1;\nBuilding b4 = (Building) b2;\nHouse h3 = (House) b2;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "b3"
      }, {
        "code": "B",
        "value": "h2"
      }, {
        "code": "C",
        "value": "b4"
      }, {
        "code": "D",
        "value": "h3"
      }, {
        "code": "E",
        "value": "All of the lines compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "187. B. Building and House are both properly declared inner classes. Any\nHouse object can be stored in a Building reference, making the declarations\nfor b3 and b4 compile. The declaration for h3 is also correct. It so happens\nthat b2 is a House object, so the cast works. The declaration of h2 is a\nproblem, though. While the cast itself is fine, a Building cannot be stored\nin a House reference, which means the assignment fails to compile. Option\nB is correct and is the only line with a compiler error in this code. Note that\nif the declaration of h2 was removed, the declaration of b3 would produce a\nClassCastException at runtime."
      }
    },
    "188": {
      "nbr": 188,
      "value": "What is the output of the following application?\n1: interface Tasty {\n2: default void eat() {\n3: System.out.print(\"Spoiled!\");\n4: } }\n5: public class ApplePicking {\n6: public static void main(String[] food) {\n7: var apple = new Tasty() {\n8: @Override\n9: void eat() {\n10: System.out.print(\"Yummy!\");\n11: }\n12: }\n13: } }",
      "responses": [{
        "code": "A",
        "value": "Spoiled!"
      }, {
        "code": "B",
        "value": "Yummy!"
      }, {
        "code": "C",
        "value": "The application completes without printing anything."
      }, {
        "code": "D",
        "value": "One line of this application fails to compile."
      }, {
        "code": "E",
        "value": "Two lines of this application fail to compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "188. E. This main() method declares an anonymous class that implements the\nTasty interface. Interface methods are public, whereas the override in the\nanonymous class uses package‐private access. Since this reduces the\nvisibility of the method, the declaration of eat() on line 9 does not\ncompile. Next, the declaration of the apple object must end with a\nsemicolon (;) on line 12, and it does not. For these two reasons, the code\ndoes not compile, and option E is the correct answer. Note that if these two\nissues were corrected, with the public modifier and missing semicolon (;),\nthen the correct answer would be option C because the code does not\nactually call the eat() method; it just declares it."
      }
    },
    "189": {
      "nbr": 189,
      "value": "Which of the following statements about functional interfaces is true?",
      "responses": [{
        "code": "A",
        "value": "It is possible to define a functional interface that returns two data\ntypes."
      }, {
        "code": "B",
        "value": "It is possible to define a primitive functional interface that uses float,\nchar, or short."
      }, {
        "code": "C",
        "value": "All functional interfaces must take arguments or return a value."
      }, {
        "code": "D",
        "value": "None of the primitive functional interfaces includes generic\narguments."
      }, {
        "code": "E",
        "value": "None of these statements is true."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "189. B. Java supports only a single return data type or void. Therefore, it is not\npossible to define a functional interface that returns two data types, making\noption A incorrect. Although Java does not include built‐in support for\nprimitive functional interfaces that include float, char, or short, there is\nnothing to prevent a developer from creating them in their own project,\nmaking option B the true statement and the correct answer. Option C is\nincorrect because a functional interface that takes no values and returns\nvoid is possible. In fact, Runnable is one such example. Option D is also\nincorrect, since IntFunction<R> takes a primitive argument as input and a\ngeneric argument for the return type."
      }
    },
    "190": {
      "nbr": 190,
      "value": "What is the result of executing the Tortoise program?\n// Hare.java\npackage com.mammal;\npublic class Hare {\nvoid init() {\nSystem.out.print(\"init-\");\n}\nprotected void race() {\nSystem.out.print(\"hare-\");\n}\n}\n// Tortoise.java\npackage com.reptile;\nimport com.mammal.Hare;\npublic class Tortoise {\nprotected void race(Hare hare) {\nhare.init(); // x1\nhare.race(); // x2\nSystem.out.print(\"tortoise-\");\n}\npublic static void main(String[] args) {\nvar tortoise = new Tortoise();\nvar hare = new Hare();\ntortoise.race(hare);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "init‐hare‐tortoise"
      }, {
        "code": "B",
        "value": "init‐hare"
      }, {
        "code": "C",
        "value": "The first line with a compiler error is line x1."
      }, {
        "code": "D",
        "value": "The first line with a compiler error is line x2."
      }, {
        "code": "E",
        "value": "The code does not compile due to a different line."
      }, {
        "code": "F",
        "value": "The code throws an exception."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "190. C. The init() method is accessible only from the same package. Since\nTortoise is in a different package, the method is not available, and option\nC is correct. Line x2 does not compile either since Tortoise is in a different\npackage and not a subclass. However, the question asks about the first line."
      }
    },
    "191": {
      "nbr": 191,
      "value": "How many lines of the following program do not compile?\ninterface Tool {\nvoid use(int fun);\n}\nabstract class Childcare {\nabstract void use(int fun);\n}\nfinal public class Stroller extends Childcare implements\nTool {\nfinal public void use(int fun) {\nint width = 5;\nclass ParkVisit {\nint getValue() { return width + fun; }\n}\nSystem.out.print(new ParkVisit().getValue());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "More than three"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "191. A. The code does not contain any compilation errors. While an abstract\nclass cannot be marked final, a concrete class extending it can be.\nLikewise, a concrete method overriding an abstract one can also be\nmarked final. In the ParkVisit class, the getValue() method accesses the\neffectively final variables width and fun. Finally, a class can override a\nmethod that it inherits from both an interface and an abstract class, provided\nthe method signatures are compatible."
      }
    },
    "192": {
      "nbr": 192,
      "value": "What is the result of executing the Sounds program?\n// Sheep.java\npackage com.mammal;\npublic class Sheep {\ndefault void baa() {\nSystem.out.println(\"baa!\");\n}\ndefault void speak() {\nbaa();\n}\n}\n// Sounds.java\npackage com.animals;\nimport com.mammal.Sheep;\npublic class Sounds {\npublic static void main(String[] args) {\nvar sheep = new Sheep();\nsheep.speak();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code runs and prints baa!."
      }, {
        "code": "B",
        "value": "The Sheep class does not compile."
      }, {
        "code": "C",
        "value": "The Sounds class does not compile."
      }, {
        "code": "D",
        "value": "Neither class compiles."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "192. D. The Sheep class does not compile because there is no default access\nmodifier keyword. If the default keyword were omitted, the code would\nuse package‐private access. Since Sounds is in a different package, option C\nwould then be the answer. However, since both classes have problems,\nOption D the correct answer."
      }
    },
    "193": {
      "nbr": 193,
      "value": "What is the best reason for marking an existing static method private\nwithin in an interface?",
      "responses": [{
        "code": "A",
        "value": "It allows the method to be overridden in a subclass."
      }, {
        "code": "B",
        "value": "It hides the secret implementation details from another developer using\nthe interface."
      }, {
        "code": "C",
        "value": "It improves the visibility of the method."
      }, {
        "code": "D",
        "value": "It ensures the method is not replaced with an overridden\nimplementation at runtime."
      }, {
        "code": "E",
        "value": "It allows the method to be marked abstract."
      }, {
        "code": "F",
        "value": "Trick question! All static methods are implicitly private within an\ninterface."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "193. B. Marking an interface method private improves the encapsulation of\nthe class, making option B correct. Options A and D are incorrect as static\nmethods cannot be overridden, regardless if they are marked private.\nOption C is incorrect, as adding private to a method reduces the visibility\nof the method. Options E and F are flat out wrong."
      }
    },
    "194": {
      "nbr": 194,
      "value": "What is the output of the following application?\npackage jungle;\npublic class RainForest extends Forest {\npublic RainForest(long treeCount) {\nthis.treeCount = treeCount+1;\n}\npublic static void main(String[] birds) {\nSystem.out.print(new RainForest(5).treeCount);\n}\n}\nclass Forest {\npublic long treeCount;\npublic Forest(long treeCount) {\nthis.treeCount = treeCount+2;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "5"
      }, {
        "code": "B",
        "value": "6"
      }, {
        "code": "C",
        "value": "8"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "194. D. Since a constructor call is not the first line of the RainForest()\nconstructor, the compiler inserts the no‐argument super() call. Since the\nparent class, Forest, does not define a no‐argument super() constructor,\nthe RainForest() constructor does not compile, and option D is correct."
      }
    },
    "195": {
      "nbr": 195,
      "value": "What is the result of compiling and executing the following class?\npackage sports;\npublic class Bicycle {\nString color = \"red\";\nprivate void printColor(String color) {\ncolor = \"purple\";\nSystem.out.print(color);\n}\npublic static void main(String[] rider) {\nnew Bicycle().printColor(\"blue\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "red"
      }, {
        "code": "B",
        "value": "purple"
      }, {
        "code": "C",
        "value": "blue"
      }, {
        "code": "D",
        "value": "It does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "195. B. First, the color variable defined in the instance and set to red is\nignored in the method printColor(). Since local scope overrides instance\nscope, option A is incorrect. The value of color passed to the\nprintColor() method is blue, but that is lost by the assignment to purple,\nmaking option B the correct answer and option C incorrect. Option D is\nincorrect as the code compiles and runs without issue."
      }
    },
    "196": {
      "nbr": 196,
      "value": "Given that Short and Integer extend Number directly, what type can be\nused to fill in the blank in the following class to allow it to compile?\npackage band;\ninterface Horn {\npublic Integer play();\n}\nabstract class Woodwind {\npublic Short play() {\nreturn 3;\n}\n}\npublic final class Saxophone extends Woodwind implements\nHorn {\npublic _________ play() {\nreturn null;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Object"
      }, {
        "code": "B",
        "value": "Integer"
      }, {
        "code": "C",
        "value": "Short"
      }, {
        "code": "D",
        "value": "Number"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "196. E. The play() method is overridden in Saxophone for both Horn and\nWoodwind, so the return type must be covariant with both. Object and\nNumber do not work, because neither is a subclass of Integer or Short. As\nstated in the question text, both Integer and Short extend Number directly,\nso neither can be a subclass of the other. Therefore, nothing can fill in the\nblank that would allow this code to compile, and option E is correct."
      }
    },
    "197": {
      "nbr": 197,
      "value": "Which statements about abstract classes and methods are correct? (Choose\nthree.)",
      "responses": [{
        "code": "A",
        "value": "An abstract class can be extended by a final class."
      }, {
        "code": "B",
        "value": "An abstract method can be overridden by a final method."
      }, {
        "code": "C",
        "value": "An abstract class can be extended by multiple classes directly."
      }, {
        "code": "D",
        "value": "An abstract class can extend multiple classes directly."
      }, {
        "code": "E",
        "value": "An abstract class cannot implement an interface."
      }, {
        "code": "F",
        "value": "An abstract class can extend an interface."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "C"
        ],
        "explanation": "197. A,B,C. Options A, B, and C are correct statements about abstract classes.\nOption D is incorrect as Java allows a class to extend only one class\ndirectly, abstract or otherwise. Option E is incorrect, as a class can\nimplement or inherit an interface. Option F is also incorrect as classes can\nonly extend classes, and interfaces can only extend interfaces."
      }
    },
    "198": {
      "nbr": 198,
      "value": "Given the following enum declaration, how many lines contain compilation\nerrors?\npublic enum Proposition {\nTRUE(1) { String getNickName() { return \"RIGHT\"; }},\nFALSE(2) { public String getNickName() { return \"WRONG\";\n}},\nUNKNOWN(3) { public String getNickName() { return\n\"LOST\"; }}\npublic int value;\nProposition(int value) {\nthis.value = value;\n}\npublic int getValue() {\nreturn this.value;\n}\nprotected abstract String getNickName();\n}",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "More than three"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "198. C. The code does not compile. First, the enum list is not terminated with a\nsemicolon (;), which is required when an enum includes anything beyond\njust the list of values. Second, the access modifier of TRUE's implementation\nof getNickName() is package‐private, but the abstract method signature\nhas a protected modifier. Since package‐private is a more restrictive\naccess than protected, the override is invalid, and the code does not\ncompile. For these two reasons, option C is the correct answer. Note that\nthe value variable is not final nor properly encapsulated and can therefore\nbe modified by callers outside the enum. This is permitted but considered a\npoor practice."
      }
    },
    "199": {
      "nbr": 199,
      "value": "Which statements about Java classes are true? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "A Java class file may include more than one package statement."
      }, {
        "code": "B",
        "value": "A Java class file may include more than one import statement."
      }, {
        "code": "C",
        "value": "A Java class file may contain more than one comment."
      }, {
        "code": "D",
        "value": "Any instance fields within a class must be defined after the class name."
      }, {
        "code": "E",
        "value": "Any instance fields within a class must be defined before the class\nname."
      }, {
        "code": "F",
        "value": "Java supports macros, in which fragments of code within a class may\nbe defined inside a Java file, separate from any top‐level type\ndeclaration."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "D"
        ],
        "explanation": "199. B,C,D. A Java class file may have at most one package statement and any\nnumber of import statements and comments. For this reason, option A is\nincorrect, and options B and C are correct. When declaring a class, the\nname comes first, before instance declarations, making option D correct and\noption E incorrect. Finally, Java does not support fragments of code outside\nof a top‐level type, such as a class or interface, making option F incorrect."
      }
    },
    "200": {
      "nbr": 200,
      "value": "What is the result of executing the HopCounter program?\n// Hopper.java\npackage com.animals;\npublic class Hopper {\nprotected void hop() {\nSystem.out.println(\"hop\");\n}\n}\n// Grasshopper.java\npackage com.insect;\nimport com.animals.Hopper;\npublic class Grasshopper extends Hopper {\npublic void move() {\nhop(); // p1\n}\n}\n// HopCounter.java\npackage com.insect;\npublic class HopCounter {\npublic static void main(String[] args) {\nvar hopper = new Grasshopper();\nhopper.move(); // p2\nhopper.hop(); // p3\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code prints hop once."
      }, {
        "code": "B",
        "value": "The code prints hop twice."
      }, {
        "code": "C",
        "value": "The first compiler error is on line p1."
      }, {
        "code": "D",
        "value": "The first compiler error is on line p2."
      }, {
        "code": "E",
        "value": "The first compiler error is on line p3."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "200. E. The hop() method has protected access, which allows subclasses to\ncall it, making line p1 correct. The HopCounter class is allowed to call the\nmove() method because it is public. However, it is not allowed to call the\nhop() method since it is referencing a subclass, but not in one. Therefore,\noption E is the answer."
      }
    },
    "201": {
      "nbr": 201,
      "value": "Which of the following is not an attribute common to both abstract classes\nand interfaces?",
      "responses": [{
        "code": "A",
        "value": "They both can contain abstract methods."
      }, {
        "code": "B",
        "value": "They both can contain public methods."
      }, {
        "code": "C",
        "value": "They both can contain protected methods."
      }, {
        "code": "D",
        "value": "They both can contain static variables."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "201. C. Interfaces cannot contain protected methods, making option C the\nanswer."
      }
    },
    "202": {
      "nbr": 202,
      "value": "Given the following class, which method signature could be successfully\nadded to the class as an overloaded version of the findAverage() method?\npublic class Calculations {\npublic Integer findAverage(int sum) { return sum; }\n}",
      "responses": [{
        "code": "A",
        "value": "public Long findAverage(int sum)"
      }, {
        "code": "B",
        "value": "public Long findAverage(int sum, int divisor)"
      }, {
        "code": "C",
        "value": "public Integer average(int sum)"
      }, {
        "code": "D",
        "value": "private void findAverage(int sum)"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "202. B. Options A and D would not allow the class to compile because two\nmethods in the class cannot have the same name and arguments, but a\ndifferent return value. Option C would allow the class to compile, but it is\nnot a valid overloaded form of our findAverage() method since it uses a\ndifferent method name. Option B is a valid overloaded version of the\nfindAverage() method, since the name is the same but the argument list\ndiffers."
      }
    },
    "203": {
      "nbr": 203,
      "value": "Which of the following is a valid method name in Java? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Go_$Outside$2()"
      }, {
        "code": "B",
        "value": "have‐Fun()"
      }, {
        "code": "C",
        "value": "new()"
      }, {
        "code": "D",
        "value": "9enjoyTheWeather()"
      }, {
        "code": "E",
        "value": "$sprint()"
      }, {
        "code": "F",
        "value": "walk#()"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "203. A,E. Options A and E are correct since method names may include the\nunderscore (_) character as well as the dollar ($) symbol. Note that there is\nno rule that requires a method start with a lowercase character; it is just a\npractice adopted by the community. Options B and F are incorrect because\nthe hyphen (‐) and pound (#) characters may not be part of a method name.\nOption C is incorrect since new is a reserved word in Java. Finally, option D\nis incorrect. A method name must start with a letter, the dollar ($) symbol,\nor an underscore (_) character."
      }
    },
    "204": {
      "nbr": 204,
      "value": "Fill in the blanks: A functional interface must contain or inherit\n______________ and may optionally include ______________.",
      "responses": [{
        "code": "A",
        "value": "at least one abstract method, the @Override annotation"
      }, {
        "code": "B",
        "value": "exactly one method, static methods"
      }, {
        "code": "C",
        "value": "exactly one abstract method, the @FunctionalInterface annotation"
      }, {
        "code": "D",
        "value": "at least one static method, at most one default method"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "204. C. A functional interface must include exactly one abstract method,\neither by inheritance or declared directly. It may also have any number,\nincluding zero, of default or static methods. For this reason, both parts\nof option D are incorrect. The first part of option A is incorrect because\nmore than one abstract method disqualifies it as a functional interface.\nThe first part of option B is incorrect because the method must be\nabstract; that is to say, any method will not suffice. Finally, option C is\nthe correct answer. The first part of the sentence defines what it means to be\na functional interface. The second part refers to the optional\n@FunctionalInterface annotation. It is considered a good practice to add\nthis annotation to any functional interfaces you define because the compiler\nwill report a problem if you define an invalid interface that does not have\nexactly one abstract method."
      }
    },
    "205": {
      "nbr": 205,
      "value": "Fill in the blank with the line of code that allows the program to compile\nand print 15 at runtime.\npackage love;\ninterface Sport {\nprivate int play() { return 15; }\n}\ninterface Tennis extends Sport {\nprivate int play() { return 30; }\n}\npublic class Game implements Tennis {\npublic int play() { return ______________; }\npublic static void main(String… ace) {\nSystem.out.println(new Game().play());\n} }",
      "responses": [{
        "code": "A",
        "value": "Sport.play()"
      }, {
        "code": "B",
        "value": "Sport.super.play()"
      }, {
        "code": "C",
        "value": "Sport.Tennis.play()"
      }, {
        "code": "D",
        "value": "Tennis.Sport.super.play()"
      }, {
        "code": "E",
        "value": "The code does not compile regardless of what is inserted into the\nblank."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "205. F. The code compiles, even if the blank is replaced with a constant int\nvalue, making option E incorrect. The private method play() declared in\nthe Sport interface is not accessible in the Game class. For this reason,\noption F is correct."
      }
    },
    "206": {
      "nbr": 206,
      "value": "What is the output of the following program?\npublic class MoreMusic {\n{\nSystem.out.print(\"do-\");\nSystem.out.print(\"re-\");\n}\npublic MoreMusic() {\nSystem.out.print(\"mi-\");\n}\npublic MoreMusic(int note) {\nthis(null);\nSystem.out.print(\"fa-\");\n}\npublic MoreMusic(String song) {\nthis(9);\nSystem.out.print(\"so-\");\n}\npublic static void main(String[] sound) {\nSystem.out.print(\"la-\");\nvar play = new MoreMusic(1);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "la‐do‐re‐mi‐so‐fa‐"
      }, {
        "code": "B",
        "value": "la‐do‐re‐mi‐fa‐"
      }, {
        "code": "C",
        "value": "do‐re‐mi‐fa‐so‐la‐"
      }, {
        "code": "D",
        "value": "fa‐re‐do‐mi‐so‐"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "206. E. The code does not compile because two of the constructors contain a\ncyclic reference to each other. The MoreMusic(int) constructor calls\nthis(null), which only matches the MoreMusic(String) constructor.\nThen, the MoreMusic(String) constructor calls this(9), which only\nmatches the MoreMusic(int) constructor. The compiler notices this circular\ndependency and does not allow the code to compile."
      }
    },
    "207": {
      "nbr": 207,
      "value": "Given the following two classes in the same package, what is the result of\nexecuting the Hug program?\npublic class Kitten {\n/** private **/ float cuteness;\n/* public */ String name;\n// default double age;\nvoid meow() { System.out.println(name + \" - \"+cuteness);\n}\n}\npublic class Hug {\npublic static void main(String… friends) {\nvar k = new Kitten();\nk.cuteness = 5;\nk.name = \"kitty\";\nk.meow();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "kitty ‐ 5.0"
      }, {
        "code": "B",
        "value": "The Kitten class does not compile."
      }, {
        "code": "C",
        "value": "The Hug class does not compile."
      }, {
        "code": "D",
        "value": "The Kitten and Hug classes do not compile."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "207. A. Both classes compile without issue, and the Hug program prints kitty\n‐ 5.0, making option A the answer. In the Kitten class, all of the variables\nhave package‐private access as the access modifiers are commented out.\nAlso, there is no age variable since the entire line is commented out. If the\ncomment syntax was removed around private, then the Hug class would\nnot compile on the line that accesses the cuteness variable."
      }
    },
    "208": {
      "nbr": 208,
      "value": "Which expressions about enums used in switch statements are correct?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "The name of the enum type must not be used in each case statement."
      }, {
        "code": "B",
        "value": "A switch statement that takes a enum value may not use ordinal()\nnumbers as case statement matching values."
      }, {
        "code": "C",
        "value": "The name of the enum type must be used in each case statement."
      }, {
        "code": "D",
        "value": "Every value of the enum must be present in a case statement."
      }, {
        "code": "E",
        "value": "A switch statement that takes a enum value can use ordinal()\nnumbers as case statement matching values."
      }, {
        "code": "F",
        "value": "Every value of the enum must be present in a case statement unless a\ndefault branch is provided."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B"
        ],
        "explanation": "208. A,B. A switch statement that uses an enum must include case statements\nthat reference the value of the enum, without the enum type. For this\nreason, option A is correct and option C is incorrect. The ordinal() value\nor position cannot be used in case statements when the switch statement\ntakes an enum value, making option B correct and option E incorrect.\nFinally, not every value in enum must be present in the case statement,\nregardless of whether a default branch is present, making options D and F\nincorrect."
      }
    },
    "209": {
      "nbr": 209,
      "value": "What is the output of the following application?\npackage prepare;\ninterface Ready {\nstatic int first = 2;\nfinal short DEFAULT_VALUE = 10;\nGetSet go = new GetSet(); // n1\n}\npublic class GetSet implements Ready {\nint first = 5;\nstatic int second = DEFAULT_VALUE; // n2\npublic static void main(String[] begin) {\nvar r = new Ready() {};\nSystem.out.print(r.first); // n3\nSystem.out.print(\" \" + second); // n4\n}\n}",
      "responses": [{
        "code": "A",
        "value": "2 10"
      }, {
        "code": "B",
        "value": "5 10"
      }, {
        "code": "C",
        "value": "The code does not compile because of line n1."
      }, {
        "code": "D",
        "value": "The code does not compile because of line n2."
      }, {
        "code": "E",
        "value": "The code does not compile because of line n3."
      }, {
        "code": "F",
        "value": "The code does not compile because of line n4."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "209. A. The code compiles without issue. The main() method creates an\ninstance of an anonymous class of Ready. Calling r.first retrieves the\nstatic variable within Ready, printing 2 on line n3. On line n2, there is no\nreference so the static variable of GetSet is called, printing 10. For these\nreasons, option A is correct."
      }
    },
    "210": {
      "nbr": 210,
      "value": "What is the result of executing the Tortoise program?\n// Hare.java\npackage com.mammal;\npublic class Hare {\npublic void init() {\nSystem.out.print(\"init-\");\n}\nprivate void race() {\nSystem.out.print(\"hare-\");\n}\n}\n// Tortoise.java\npackage com.reptile;\nimport com.mammal.Hare;\npublic class Tortoise {\nprotected void race(Hare hare) {\nhare.init(); // x1\nhare.race(); // x2\nSystem.out.print(\"tortoise-\");\n}\npublic static void main(String[] args) {\nvar tortoise = new Tortoise();\nvar hare = new Hare();\ntortoise.race(hare);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "init‐hare‐tortoise"
      }, {
        "code": "B",
        "value": "init‐hare"
      }, {
        "code": "C",
        "value": "The first line with a compiler error is line x1."
      }, {
        "code": "D",
        "value": "The first line with a compiler error is line x2."
      }, {
        "code": "E",
        "value": "The code does not compile due to a different line."
      }, {
        "code": "F",
        "value": "The code throws an exception."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "210. D. The init() method is accessible from any code. However, the race()\nmethod is available only within the Hare class. Since Tortoise is a\ndifferent class, the method is not available, and option D is correct."
      }
    },
    "211": {
      "nbr": 211,
      "value": "What is the result of executing the Sounds program?\n// Sheep.java\npackage com.mammal;\npublic class Sheep {\nprivate void baa() {\nSystem.out.println(\"baa!\");\n}\nprivate static void speak() {\nbaa();\n}\n}\n// Sounds.java\npackage com.animals;\nimport com.mammal.Sheep;\npublic class Sounds {\npublic static void main(String[] args) {\nvar sheep = new Sheep();\nsheep.speak();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code runs and prints baa!."
      }, {
        "code": "B",
        "value": "The Sheep class does not compile."
      }, {
        "code": "C",
        "value": "The Sounds class does not compile."
      }, {
        "code": "D",
        "value": "Neither class compiles."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "211. D. The Sheep class does not compile since a static method cannot call an\ninstance method. The Sounds class does not compile because it does not\nhave access to the speak() method. Since neither class compiles, option D\nis correct."
      }
    },
    "212": {
      "nbr": 212,
      "value": "What is the output of the Helicopter program?\npackage flying;\nclass Rotorcraft {\nprotected final int height = 5;\nabstract int fly();\n}\ninterface CanFly {}\npublic class Helicopter extends Rotorcraft implements\nCanFly {\nprivate int height = 10;\nprotected int fly() {\nreturn super.height;\n}\npublic static void main(String[] unused) {\nHelicopter h = (Helicopter)new Rotorcraft();\nSystem.out.print(h.fly());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "5"
      }, {
        "code": "B",
        "value": "10"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but produces a ClassCastException at runtime."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "212. C. The Rotorcraft class includes an abstract method, but the class itself\nis not marked abstract. Only interfaces and abstract classes can include\nabstract methods. Since the code does not compile, option C is the correct\nanswer."
      }
    },
    "213": {
      "nbr": 213,
      "value": "Which statements about the following Twins class are true? (Choose three.)\npackage clone;\ninterface Alex {\ndefault void write() { System.out.print(\"1\"); }\nstatic void publish() {}\nvoid think();\nprivate int process() { return 80; }\n}\ninterface Michael {\ndefault void write() { System.out.print(\"2\"); }\nstatic void publish() {}\nvoid think();\nprivate int study() { return 100; }\n}\npublic class Twins implements Alex, Michael {\nvoid write() { System.out.print(\"3\"); }\nstatic void publish() {}\nvoid think() {\nSystem.out.print(\"Thinking…\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The class fails to compile because of the write() method."
      }, {
        "code": "B",
        "value": "The class fails to compile because of the publish() method."
      }, {
        "code": "C",
        "value": "The class fails to compile because of the think() method."
      }, {
        "code": "D",
        "value": "All of the methods defined in the Alex interface are accessible in the\nTwins class."
      }, {
        "code": "E",
        "value": "All of the methods defined in the Michael interface are accessible in\nthe Twins class."
      }, {
        "code": "F",
        "value": "The Twins class cannot be marked abstract."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "E"
        ],
        "explanation": "213. A,C,E. All of the interface methods without a private modifier are\nimplicitly public. In a class, though, a method without a modifier is\npackage‐private by default. For this reason, the write() and think()\nmethods do not compile because they are missing the public modifier,\nmaking options A and C correct. These are the only compiler errors,\nmaking option B incorrect. Option D is incorrect because the process()\nmethod is not accessible with Twins because it is private. Option E is\ncorrect, as all methods are accessible. Even the overridden default method\ncan be accessed in the Twins class by calling Michael.super.write().\nFinally, option F is incorrect as the class still compiles if it is marked\nabstract."
      }
    },
    "214": {
      "nbr": 214,
      "value": "Given the following program, what is the first line to fail to compile?\n1: public class Electricity {\n2: interface Power {}\n3: public static void main(String[] light) {\n4: class Source implements Power {};\n5: final class Super extends Source {};\n6: var start = new Super() {};\n7: var end = new Source() { static boolean t = true;\n};\n8: }\n9: }",
      "responses": [{
        "code": "A",
        "value": "Line 2"
      }, {
        "code": "B",
        "value": "Line 4"
      }, {
        "code": "C",
        "value": "Line 5"
      }, {
        "code": "D",
        "value": "Line 6"
      }, {
        "code": "E",
        "value": "Line 7"
      }, {
        "code": "F",
        "value": "All of the lines compile"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "214. D. The Super class is marked final, which mean its cannot be used as the\nsupertype of an anonymous class. For this reason, line 6 does not compile,\nand option D is correct. Line 7 also does not compile as a local class can\nonly contain static variables that are marked final."
      }
    },
    "215": {
      "nbr": 215,
      "value": "What is the output of the following application?\npackage prepare;\npublic class Ready {\nprotected static int first = 2;\nprivate final short DEFAULT_VALUE = 10;\nprivate static class GetSet {\nint first = 5;\nstatic int second = DEFAULT_VALUE;\n}\nprivate GetSet go = new GetSet();\npublic static void main(String[] begin) {\nReady r = new Ready();\nSystem.out.print(r.go.first);\nSystem.out.print(\", \"+r.go.second);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "2, 5"
      }, {
        "code": "B",
        "value": "5, 10"
      }, {
        "code": "C",
        "value": "2, 10"
      }, {
        "code": "D",
        "value": "The code does not compile because of the GetSet class declaration."
      }, {
        "code": "E",
        "value": "The code does not compile for another reason."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "215. D. The final variable DEFAULT_VALUE is not a static variable; therefore,\nthe static nested class GetSet cannot access it without a reference to the\nclass. For this reason, the declaration of the static nested class GetSet\ndoes not compile, and option D is the correct answer. The rest of the code\ncompiles without issue. If the DEFAULT_VALUE variable was modified to be\nstatic, then the code would compile and print 5, 10 at runtime."
      }
    },
    "216": {
      "nbr": 216,
      "value": "Which of the following are true about the following code? (Choose two.)\npublic class Values {\nstatic ____ defaultValue = 8;\nstatic ____ DEFAULT_VALUE;\npublic static void main(String[] args) {\nSystem.out.println(defaultValue + DEFAULT_VALUE);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "When you fill in both blanks with double, it prints 8.00.0"
      }, {
        "code": "B",
        "value": "When you fill in both blanks with double, it prints 8.0"
      }, {
        "code": "C",
        "value": "When you fill in both blanks with int, it prints 8"
      }, {
        "code": "D",
        "value": "When you fill in both blanks with int, it prints 80"
      }, {
        "code": "E",
        "value": "When you fill in both blanks with var, it prints 8"
      }, {
        "code": "F",
        "value": "When you fill in both blanks with var, it prints 80"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C"
        ],
        "explanation": "216. B,C. The static class variables cannot be used with var since they are not\nlocal variables. Therefore, options E and F are incorrect. Options B and C\nare correct because numeric addition is used here instead of concatenation."
      }
    },
    "217": {
      "nbr": 217,
      "value": "How many Gems objects are eligible for garbage collection right before the\nend of the main() method?\npublic class Gems {\npublic String name;\npublic Gems(String name) {\nthis.name = name;\n}\npublic static void main(String… args) {\nvar g1 = Gems(\"Garnet\");\nvar g2 = Gems(\"Amethyst\");\nvar g3 = Gems(\"Pearl\");\nvar g4 = Gems(\"Steven\");\ng2 = g3;\ng3 = g2;\ng1 = g2;\ng4 = null;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "The code does not compile"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "217. F. The code does not compile, as the constructor calls on the first four\nlines of the main() method are missing the new keyword. If the missing new\nkeywords were added to each line, then the code would compile, and three\nGems objects would be available for garbage collection."
      }
    },
    "218": {
      "nbr": 218,
      "value": "How many lines of the following program contain compilation errors?\npackage sky;\npublic class Stars {\nprivate int inThe = 4;\npublic void Stars() {\nsuper();\n}\npublic Stars(int inThe) {\nthis.inThe = this.inThe;\n}\npublic static void main(String[] endless) {\nSystem.out.print(new sky.Stars(2).inThe);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "218. B. The code does not compile, so option A is incorrect. The class contains\ntwo methods and one constructor. The first method, Stars(), looks a lot\nlike a no‐argument constructor, but since it has a return value of void, it is a\nmethod, not a constructor. Since only constructors can call super(), the\ncode does not compile due to this line. The only constructor in this class,\nwhich takes an int value as input, performs a pointless assignment,\nassigning a variable to itself. While this assignment has no effect, it does\nnot prevent the code from compiling. Finally, the main() method compiles\nwithout issue since we just inserted the full package name into the class\nconstructor call. This is how a class that does not use an import statement\ncould call the constructor. Since the method is in the same class, and\ntherefore the same package, it is redundant to include the package name but\nnot disallowed. Because only one line causes the class to fail to compile,\noption B is correct."
      }
    },
    "219": {
      "nbr": 219,
      "value": "What is the output of the following application?\npackage sports;\nabstract class Ball {\nprotected final int size;\npublic Ball(int size) {\nthis.size = size;\n}\n}\ninterface Equipment {}\npublic class SoccerBall extends Ball implements Equipment {\npublic SoccerBall() {\nsuper(5);\n}\npublic Ball get() { return this; }\npublic static void main(String[] passes) {\nvar equipment = (Equipment)(Ball)new\nSoccerBall().get();\nSystem.out.print(((SoccerBall)equipment).size);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "5"
      }, {
        "code": "B",
        "value": "The code does not compile due to an invalid cast."
      }, {
        "code": "C",
        "value": "The code does not compile for a different reason."
      }, {
        "code": "D",
        "value": "The code compiles but throws a ClassCastException at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "219. A. Although the casting is a bit much, the object in question is a\nSoccerBall. Since SoccerBall extends Ball and implements Equipment, it\ncan be explicitly cast to any of those types, so no compilation error occurs.\nAt runtime, the object is passed around and, due to polymorphism, can be\nread using any of those references since the underlying object is a\nSoccerBall. In other words, casting it to a different reference variable does\nnot modify the object or cause it to lose its underlying SoccerBall\ninformation. Therefore, the code compiles without issue, and option A is\ncorrect."
      }
    },
    "220": {
      "nbr": 220,
      "value": "Which statement about the Elephant program is correct?\npackage stampede;\ninterface Long {\nNumber length();\n}\npublic class Elephant {\npublic class Trunk implements Long {\npublic Number length() { return 6; } // k1\n}\npublic class MyTrunk extends Trunk { // k2\npublic Integer length() { return 9; } // k3\n}\npublic static void charge() {\nSystem.out.print(new MyTrunk().length());\n}\npublic static void main(String[] cute) {\nnew Elephant().charge(); // k4\n}\n}",
      "responses": [{
        "code": "A",
        "value": "It compiles and prints 6."
      }, {
        "code": "B",
        "value": "The code does not compile because of line k1."
      }, {
        "code": "C",
        "value": "The code does not compile because of line k2."
      }, {
        "code": "D",
        "value": "The code does not compile because of line k3."
      }, {
        "code": "E",
        "value": "The code does not compile because of line k4."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "220. F. The question may appear to be about method overriding, but it is in fact\nabout member inner classes. In fact, all of the method overrides are valid in\nthis class. The code does not compile because the charge() method is\nstatic (even though it is called on an instance), which means it requires an\ninstance to instantiate a member of the member inner class MyTrunk. For\nthis reason, the call to new MyTrunk() does not compile, and option F is\ncorrect."
      }
    }
  }
}, {
  "name": "Exception Handling",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "Fill in the blanks: The ___________________ keyword is used in method\ndeclarations, while the ___________________ keyword is used to send an\nexception to the surrounding process.",
      "responses": [{
        "code": "A",
        "value": "throwing, catch"
      }, {
        "code": "B",
        "value": "throws, throw"
      }, {
        "code": "C",
        "value": "catch, throw"
      }, {
        "code": "D",
        "value": "throws, catch"
      }, {
        "code": "E",
        "value": "throw, throws"
      }, {
        "code": "F",
        "value": "catch, throwing"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "1. B. The throws keyword is used in method declarations, while the throw\nkeyword is used to send an exception to the surrounding process, making\noption B the correct answer. The catch keyword is used to handle\nexceptions. There is no throwing keyword in Java."
      }
    },
    "2": {
      "nbr": 2,
      "value": "What is the result of compiling and executing the following application?\npackage mind;\nimport java.io.*;\npublic class Remember {\npublic static void think() throws IOException { // k1\ntry {\nthrow Exception();\n} catch (RuntimeException r) {} // k2\n}\npublic static void main(String… ideas) throws Exception\n{\nthink();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code compiles and runs without printing anything."
      }, {
        "code": "B",
        "value": "The code compiles, but a stack trace is printed at runtime."
      }, {
        "code": "C",
        "value": "The code does not compile because of line k1."
      }, {
        "code": "D",
        "value": "The code does not compile because of line k2."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "2. E. To throw an exception with the throw keyword, an existing or new\nexception must be provided. In this case, the new keyword is missing in\nfront of Exception() in the think() method. It is treated as a method call\nthat does not exist, and this line does not compile, making option E correct.\nIf the new keyword were added, though, the line would still not compile as\nthe checked exception is not handled or declared within the think()\nmethod."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Given the following keywords, in which order could they be used? (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "try, finally"
      }, {
        "code": "B",
        "value": "catch, try, finally"
      }, {
        "code": "C",
        "value": "try, catch, catch, finally"
      }, {
        "code": "D",
        "value": "finally, catch, try"
      }, {
        "code": "E",
        "value": "try, finally, catch"
      }, {
        "code": "F",
        "value": "try, catch, finally, finally"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "3. A,C. The correct order of blocks is try, catch, and finally. For a\ntraditional try/catch block at least one catch or finally must be used. In\naddition, multiple catch blocks are allowed, although at most one finally\nblock is allowed. For these reasons, options A and C are correct, and the\nrest are incorrect."
      }
    },
    "4": {
      "nbr": 4,
      "value": "Fill in the blanks: A try statement ______________ a catch or a finally\nblock, while a try‐with‐resources statement ______________.",
      "responses": [{
        "code": "A",
        "value": "is not required to contain, is not required to contain either"
      }, {
        "code": "B",
        "value": "is not required to contain, must contain one of them"
      }, {
        "code": "C",
        "value": "must contain, is not required to contain either"
      }, {
        "code": "D",
        "value": "must contain, must contain a catch block"
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "4. C. Unlike a try‐with‐resources statement, in which the catch and finally\nblocks are optional, a traditional try statement requires a catch or finally\nblock to be used, or both. For this reason, option C is correct."
      }
    },
    "5": {
      "nbr": 5,
      "value": "What is the output of the following application?\npackage park;\nclass LostBallException extends Exception {}\npublic class Ball {\npublic void toss() throw LostBallException {\nvar windUp = new int[0];\nSystem.out.println(windUp[0]);\n}\npublic static void main(String[] bouncy) {\ntry {\nnew Ball().toss();\n} catch (Throwable e) {\nSystem.out.print(\"Caught!\");\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "Caught!"
      }, {
        "code": "C",
        "value": "The code does not compile because LostBallException is not handled\nor declared in the main() method."
      }, {
        "code": "D",
        "value": "The code does not compile because\nArrayIndexOutOfBoundsException is not handled or declared in the\ntoss() method."
      }, {
        "code": "E",
        "value": "The code does not compile for a different reason."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "5. E. The code does not compile because the throw keyword is incorrectly\nused in the toss() method declaration. The keyword throws should have\nbeen used instead. For this reason, option E is the correct answer. If the\ncorrect keyword was used, then the code would compile and Caught! at\nruntime."
      }
    },
    "6": {
      "nbr": 6,
      "value": "Assuming Scanner is a valid class that implements AutoCloseable, what is\nthe expected output of the following code?\ntry (Scanner s = new Scanner(System.in)) {\nSystem.out.print(1);\ns.nextLine();\nSystem.out.print(2);\ns = null;\n} catch (IllegalArgumentException | NullPointerException x)\n{\ns.nextLine();\nSystem.out.print(3);\n} finally {\ns.nextLine();\nSystem.out.print(4);\n}\nSystem.out.print(5);",
      "responses": [{
        "code": "A",
        "value": "1245"
      }, {
        "code": "B",
        "value": "125"
      }, {
        "code": "C",
        "value": "1234 followed by a stack trace"
      }, {
        "code": "D",
        "value": "124 followed by a stack trace"
      }, {
        "code": "E",
        "value": "Does not compile"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "6. E. The code does not compile because s is defined within the try‐withresources\nblock. It is out of scope by the time it reaches the catch and\nfinally blocks, making option E correct."
      }
    },
    "7": {
      "nbr": 7,
      "value": "How many constructors in WhaleSharkException compile in the following\nclass?\npackage friendly;\npublic class WhaleSharkException extends Exception {\npublic WhaleSharkException() {\nsuper(\"Friendly shark!\");\n}\npublic WhaleSharkException(String message) {\nsuper(new Exception(new WhaleSharkException()));\n}\npublic WhaleSharkException(Exception cause) {}\n}",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "7. D. The Exception class contains multiple constructors, including one that\ntakes Throwable, one that takes String, and a no‐argument constructor.\nThe first WhaleSharkException constructor compiles, using the Exception\nconstructor that takes a String. The second WhaleSharkException\nconstructor also compiles. The two statements, super() and new\nException(), actually call the same constructor in the Exception class, one\nafter another. The last WhaleSharkException compiles with the compiler\ninserting the default no‐argument constructor super(), because it exists in\nthe Exception class. For these reasons, all of the constructors compile, and\noption D is the correct answer."
      }
    },
    "8": {
      "nbr": 8,
      "value": "What is the output of the following application?\npackage game;\npublic class Football {\npublic static void main(String officials[]) {\ntry {\nSystem.out.print('A');\nthrow new ArrayIndexOutOfBoundsException();\n} catch (RuntimeException r) {\nSystem.out.print('B');\nthrow r;\n} catch (Exception e) {\nSystem.out.print('C');\n} finally {\nSystem.out.print('D');\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "ABC"
      }, {
        "code": "B",
        "value": "ABD"
      }, {
        "code": "C",
        "value": "ABC followed by a stack trace"
      }, {
        "code": "D",
        "value": "ABD followed by a stack trace"
      }, {
        "code": "E",
        "value": "AD followed by a stack trace"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "8. D. The application first enters the try block and prints A. It then throws an\nArrayIndexOutOfBoundsException, which is caught by the first catch\nblock since ArrayIndexOutOfBoundsException is a subclass of\nRuntimeException, printing B. The exception is then rethrown, but since\nthere isn't a separate try/catch block around it, it does not get caught by\nthe second catch block. Before printing the stack trace, the finally block\nis called, and D is printed. For these reasons, option D is correct."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Which of the following types are not recommended to catch in your\napplication? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Exception"
      }, {
        "code": "B",
        "value": "CheckedException"
      }, {
        "code": "C",
        "value": "Throwable"
      }, {
        "code": "D",
        "value": "RuntimeException"
      }, {
        "code": "E",
        "value": "UncheckedException"
      }, {
        "code": "F",
        "value": "Error"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "9. C,F. While Exception and RuntimeException are commonly caught in\nJava applications, it is not recommended that Error and Throwable (which\nincludes Error) be caught. An Error often indicates a failure of the JVM,\nwhich cannot be recovered from. For these reasons, options C and F are\ncorrect, and options A and D are incorrect. Options B and E are class names\nthat are not part of the standard Java API."
      }
    },
    "10": {
      "nbr": 10,
      "value": "What is the output of the following program?\npackage buffet;\nclass Garden implements AutoCloseable {\nprivate final int g;\nGarden(int g) { this.g = g; }\npublic void close() throws Exception {\nSystem.out.print(g);\n}\n}\npublic class Salad {\npublic static void main(String[] u) throws Exception {\nvar g = new Garden(5);\ntry (g;\nvar h = new Garden(4);\nvar i = new Garden(2)) {\n} finally {\nSystem.out.println(9);\n}\ng = null;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "2459"
      }, {
        "code": "B",
        "value": "9245"
      }, {
        "code": "C",
        "value": "5429"
      }, {
        "code": "D",
        "value": "9542"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "10. E. A variable declared before the start of a try‐with‐resources statement\nmay be used if it is final or effectively final. Since g is modified after it is\nset, it is neither; therefore, the class does not compile, and option E is\ncorrect. If the last line of the main() method were removed, then the code\nwould compile and print 2459 at runtime."
      }
    },
    "11": {
      "nbr": 11,
      "value": "What is the output of the following application?\npackage paper;\nimport java.io.Closeable;\npublic class PrintCompany {\nclass Printer implements Closeable { // r1\npublic void print() {\nSystem.out.println(\"This just in!\");\n}\npublic void close() {}\n}\npublic void printHeadlines() {\ntry {Printer p = new Printer()} { // r2\np.print();\n}\n}\npublic static void main(String[] headlines) {\nnew PrintCompany().printHeadlines(); // r3\n}\n}",
      "responses": [{
        "code": "A",
        "value": "This just in!"
      }, {
        "code": "B",
        "value": "The code does not compile because of line r1."
      }, {
        "code": "C",
        "value": "The code does not compile because of line r2."
      }, {
        "code": "D",
        "value": "The code does not compile because of line r3."
      }, {
        "code": "E",
        "value": "The code does not compile for a different reason."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "11. C. The class does not compile because in line r2, curly braces, {}, are\nused instead of parentheses, (), in the try‐with‐resources statement, making\noption C the correct answer. If this line was fixed to use parentheses, (),\nthen the rest of the class would compile without issue and print This just\nin! at runtime."
      }
    },
    "12": {
      "nbr": 12,
      "value": "How many of these custom exceptions are unchecked exceptions?\nclass ColoringException extends IOException {}\nclass CursiveException extends WritingException {}\nclass DrawingException extends IllegalStateException {}\nclass SketchingException extends DrawingException {}\nclass WritingException extends Exception {}",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "12. C. Since IOException and Exception are checked exceptions,\nColoringException and WritingException are checked exceptions.\nFurther, CursiveException is also checked since it extends a checked\nexception. By contrast, IllegalStateException is an unchecked\nexception. This means that DrawingException and SketchingException\nare also unchecked, and option C is the answer."
      }
    },
    "13": {
      "nbr": 13,
      "value": "How many lines of text does the following program print?\npackage lighting;\nimport java.io.IOException;\npublic class Light {\npublic static void main(String[] v) throws Exception {\ntry {\nnew Light().turnOn();\n} catch (RuntimeException v) { // y1\nSystem.out.println(v);\nthrow new IOException(); // y2\n} finally {\nSystem.out.println(\"complete\");\n}\n}\npublic void turnOn() throws IOException {\nnew IOException(\"Not ready\"); // y3\n}\n}",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "The code does not compile because of line y1."
      }, {
        "code": "D",
        "value": "The code does not compile because of line y2."
      }, {
        "code": "E",
        "value": "The code does not compile because of line y3."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "13. C. The code does not compile because the variable v is used twice in the\nmain() method, both in the method declaration and in the catch block,\nmaking option C the correct answer. If a different variable name were used\nin one of the locations, the program would print one line, complete, making\noption A the correct answer. Note that while an exception is created inside\nthe turnOn() method, it is not thrown."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Which statements about try‐with‐resources are false? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "If more than one resource is used, the resources are closed in the order\nthey were created."
      }, {
        "code": "B",
        "value": "Parentheses are used for the resource declaration section, even if more\nthan one resource is used."
      }, {
        "code": "C",
        "value": "If the try block and close() method both throw an exception, then the\none thrown by the close() method is suppressed."
      }, {
        "code": "D",
        "value": "A resource may be declared before it is used in a try‐with‐resources\nstatement."
      }, {
        "code": "E",
        "value": "Resources declarations are separated by commas."
      }, {
        "code": "F",
        "value": "A catch block is not required."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "14. A,E. When more than one resource is used in a try‐with‐resources\nstatement, they are closed in the reverse order in which they are declared,\nmaking option A the first false statement. In addition, resources are\nseparated by semicolons, not commas, making option E the other false\nstatement. The rest of the statements are true. Note that ability to declare\nresources before they are used in a try‐with‐resources statement is new\nsince Java 9."
      }
    },
    "15": {
      "nbr": 15,
      "value": "How many lines of text does the following program print?\npackage bee;\nclass SpellingException extends RuntimeException {}\npublic class SpellChecker {\npublic final static void main(String… participants) {\ntry {\nif(!\"cat\".equals(\"kat\")) {\nnew SpellingException();\n}\n} catch (SpellingException | NullPointerException e)\n{\nSystem.out.println(\"Spelling problem!\");\n} catch (Exception e) {\nSystem.out.println(\"Unknown Problem!\");\n} finally {\nSystem.out.println(\"Done!\");\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "Three."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "15. A. The program compiles without issue, so option D is incorrect. The\nnarrower SpellingException and NullPointerException, which inherit\nfrom Exception, are correctly presented in the first catch block, with the\nbroader Exception being in the second catch block. The if‐then statement\nevaluates to true, and a new SpellingException instance is created, but it\nis not thrown because it is missing the throw keyword. For this reason, the\ntry block ends without any of the catch blocks being executed. The\nfinally block is then called, making it the only section of code in the\nprogram that prints a line of text. For this reason, option A is the correct\nanswer."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Which of the following exception types must be handled or declared by the\nmethod in which they are thrown? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "FileNotFoundException"
      }, {
        "code": "B",
        "value": "ClassCastException"
      }, {
        "code": "C",
        "value": "Error"
      }, {
        "code": "D",
        "value": "IOException"
      }, {
        "code": "E",
        "value": "NullPointerException"
      }, {
        "code": "F",
        "value": "Exception"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "F"
        ],
        "explanation": "16. A,D,F. Any class that inherits Exception but not RuntimeException is a\nchecked exception and must be handled or declared. For this reason, option\nF is trivially correct. Options A and D are also checked exceptions. Options\nB and E are incorrect since they inherit RuntimeException. Finally, option\nC is incorrect as Error inherits Throwable but not Exception."
      }
    },
    "17": {
      "nbr": 17,
      "value": "What is the output of the following application?\npackage bed;\npublic class Sleep {\npublic static void snore() {\ntry {\nString sheep[] = new String[3];\nSystem.out.print(sheep[3]);\n} catch (RuntimeException | Error e) {\nSystem.out.print(\"Awake!\");\n} finally {\nthrow new Exception(); // x1\n}\n}\npublic static void main(String… sheep) { // x2\nnew Sleep().snore(); // x3\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Awake!"
      }, {
        "code": "B",
        "value": "Awake! followed by a stack trace"
      }, {
        "code": "C",
        "value": "Does not compile because of line x1"
      }, {
        "code": "D",
        "value": "Does not compile because of line x2"
      }, {
        "code": "E",
        "value": "Does not compile because of line x3"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "17. C. The finally block of the snore() method throws a new checked\nexception on line x1, but there is no try‐catch block around it to handle it,\nnor does the snore() method declare any checked exceptions. For these\nreasons, line x1 does not compile, and option C is the correct answer. The\nrest of the lines of code compile without issue. Note that the code inside the\ntry block, if it ran, would produce an ArrayIndexOutOfBoundsException,\nwhich would be caught by the RuntimeException catch block, printing\nAwake!."
      }
    },
    "18": {
      "nbr": 18,
      "value": "What is the output of the following code?\nclass ProblemException extends Exception {\nProblemException(Exception e) { super(e); }\n}\nclass MajorProblemException extends ProblemException {\nMajorProblemException(String message) { super(message);\n}\n}\npublic class Unfortunate {\npublic static void main(String[] args) throws Exception\n{\ntry {\nSystem.out.print(1);\nthrow new MajorProblemException(\"Uh oh\");\n} catch (ProblemException | RuntimeException e) {\nSystem.out.print(2);\ntry {\nthrow new MajorProblemException(\"yikes\");\n} finally {\nSystem.out.print(3);\n}\n} finally {\nSystem.out.print(4);\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "123"
      }, {
        "code": "B",
        "value": "123 followed by an exception stack trace."
      }, {
        "code": "C",
        "value": "1234"
      }, {
        "code": "D",
        "value": "1234 followed by an exception stack trace."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "18. E. The ProblemException class compiles without error. However, the\nMajorProblemException class has, well, a major problem. The constructor\nattempts to call a superclass constructor with a String parameter, but the\nProblemException class only has a constructor with an Exception\nparameter. This causes a compiler error, which is option E."
      }
    },
    "19": {
      "nbr": 19,
      "value": "Which statement best describes how a class that implements the\nAutoCloseable interface should be written? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "The close() method is optional since the AutoCloseable interface\ndefines a default implementation."
      }, {
        "code": "B",
        "value": "The close() method should avoid modifying data after it has been run\nonce."
      }, {
        "code": "C",
        "value": "The close() method should not throw any exceptions."
      }, {
        "code": "D",
        "value": "The close() method should throw an exception if there is a problem\nclosing the resource."
      }, {
        "code": "E",
        "value": "The close() method should return a status code."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "19. B,D. First, option A is an incorrect statement, because the AutoCloseable\ninterface does not define a default implementation of close(). Next, the\nclose() method should be idempotent, which means it is able to be run\nmultiple times without triggering any side effects. For this reason, option B\nis correct. After being run once, future calls to close() should not change\nany data. Option D is correct, and option C is incorrect because the close()\nmethod is fully capable of throwing exceptions if there is a problem. In fact,\nthe signature of the method in AutoCloseable throws a checked Exception.\nOption E is incorrect because the return type of close() is void, which\nmeans no return value can be returned."
      }
    },
    "20": {
      "nbr": 20,
      "value": "Which of the following diagrams of java.lang classes shows the\ninheritance model properly?",
      "responses": [{
        "code": "A",
        "value": ""
      }, {
        "code": "B",
        "value": ""
      }, {
        "code": "C",
        "value": ""
      }, {
        "code": "D",
        "value": ""
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "20. D. Option D is the correct model. The class RuntimeException extends\nException, and both Exception and Error extend Throwable. Finally, like\nall Java classes, they all inherit from Object. Notice that Error does not\nextend Exception, even though we often refer to these generally as\nexceptions."
      }
    },
    "21": {
      "nbr": 21,
      "value": "Which exception classes, when inserted into the blank in the Problems\nclass, allow the code to compile?\nclass MissingMoneyException {}\nclass MissingFoodException {}\npublic class Problems {\npublic void doIHaveAProblem()\nthrows MissingMoneyException, MissingFoodException\n{\nSystem.out.println(\"No problems\");\n}\npublic static void main(String[] s) throws\n______________ {\ntry {\nfinal Problems p = new Problems();\np.doIHaveAProblem();\n} catch (Exception e) {\nthrow e;\n} } }",
      "responses": [{
        "code": "A",
        "value": "Exception"
      }, {
        "code": "B",
        "value": "RuntimeException"
      }, {
        "code": "C",
        "value": "MissingFoodException"
      }, {
        "code": "D",
        "value": "MissingMoneyException, MissingFoodException"
      }, {
        "code": "E",
        "value": "MissingMoneyException"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "21. F. The classes MissingMoneyException and MissingFoodException do\nnot extend any exception classes; therefore, they cannot be used in a\nmethod declaration. The code does not compile regardless of what is placed\nin the blank, making option F correct."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Which statements about Closeable and AutoCloseable are true? (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "AutoCloseable extends Closeable."
      }, {
        "code": "B",
        "value": "Closeable extends AutoCloseable."
      }, {
        "code": "C",
        "value": "The close() method in a class that implements AutoCloseable cannot\nthrow an IOException."
      }, {
        "code": "D",
        "value": "The close() method in a class that implements Closeable cannot\nthrow an Exception."
      }, {
        "code": "E",
        "value": "There is no difference; one was added for backward compatibility."
      }, {
        "code": "F",
        "value": "Both have a generic return type."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "22. B,D. Closeable extends AutoCloseable, making option B correct and\noption A incorrect. The close() method in AutoCloseable throws\nException, while the close() method in Closeable throws IOException,\nmaking option E incorrect. Since IOException is a subclass of Exception,\nboth close() methods can throw an IOException, making option C\nincorrect. On the other hand, Exception is not a subclass of IOException.\nFor this reason, the close() method in a class that implements Closeable\ncannot throw an instance of the Exception class, because it is an invalid\noverride using a broader exception type, making option D the correct\nanswer. Finally, the return type for both is void, making option F incorrect."
      }
    },
    "23": {
      "nbr": 23,
      "value": "Which expressions, when inserted into the blank in the following class,\nallow the code to compile? (Choose two.)\npackage sun;\nimport java.io.*;\npublic class Beach {\nclass TideException extends Exception {}\npublic void surf() throws RuntimeException {\ntry {\nthrow new TideException();\n} catch (_______________) {}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Exception a | RuntimeException f"
      }, {
        "code": "B",
        "value": "IllegalStateException | TideException t"
      }, {
        "code": "C",
        "value": "TideException | IOException i"
      }, {
        "code": "D",
        "value": "TideException | Exception x"
      }, {
        "code": "E",
        "value": "Error e"
      }, {
        "code": "F",
        "value": "Exception z"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "23. B,F. Option A does not compile because a multi‐catch expression uses a\nsingle variable, not two variables. Since the TideException is handled and\nneither exception class is a subtype of the other, option B is correct. Option\nC does not compile because the compiler notices that it is not possible to\nthrow a checked IOException in this try block. Option D does not compile\nbecause multi‐catch blocks cannot contain two exceptions in which one is a\nsubclass of the other. If it did, one of the two exceptions would be\nredundant. Option E does not compile because the checked TideException\nis not handled or declared by the surf() method. Remember, Error and\nException are not subclasses of each other, although they both inherit\nThrowable. Option F is correct because TideException is a subclass of\nException, so both are handled by Exception."
      }
    },
    "24": {
      "nbr": 24,
      "value": "Which of the following are the best scenarios in which to use and catch an\nexception? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "The computer caught fire."
      }, {
        "code": "B",
        "value": "A network connection goes down."
      }, {
        "code": "C",
        "value": "A caller passes invalid data to a method."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "A method finishes sooner than expected."
      }, {
        "code": "F",
        "value": "The program runs out of memory."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C"
        ],
        "explanation": "24. B,C. Option A is incorrect. You should probably seek help if the computer\nis on fire! Options B and C are correct answers, as invalid or missing\ndata/resources should be expected of most programs. Option D is incorrect\nbecause code that does not compile cannot run and therefore cannot throw\nany exceptions. Option E is incorrect; finishing sooner is rarely considered\na problem. Option F is incorrect because an Error is thrown in this\nsituation, and it should not be caught, as the JVM cannot usually recover\nfrom this scenario."
      }
    },
    "25": {
      "nbr": 25,
      "value": "Which statement about the following program is correct?\n1: package dogpark;\n2: public class Fetch {\n3: public int play(String name) throws RuntimeException\n{\n4: try {\n5: throw new RuntimeException(name);\n6: } catch (Throwable e) {\n7: throw new RuntimeException(e);\n8: }\n9: }\n10: public static final void main(String[] ball)\n11: throws RuntimeException {\n12: new Fetch().play(\"Webby\");\n13: new Fetch().play(\"Georgette\");\n14: }\n15: }",
      "responses": [{
        "code": "A",
        "value": "One exception is thrown to the caller at runtime."
      }, {
        "code": "B",
        "value": "Two exceptions are thrown to the caller at runtime."
      }, {
        "code": "C",
        "value": "More than two exceptions are thrown to the caller at runtime."
      }, {
        "code": "D",
        "value": "The class does not compile because of the play() method."
      }, {
        "code": "E",
        "value": "The class does not compile because of the main() method."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "25. A. The program compiles, making options D and E incorrect. At runtime,\nline 12 is executed, calling the play() method. Line 5 then throws an\nexception that is immediately caught on line 6. Line 7 throws a new\nunchecked exception that is not caught by the program, with this exception\nbeing thrown to the caller, and making option A correct. In this case, line\n13 is never executed. Even though the stack trace for the exception may\ninclude information about the cause, only one exception is actually thrown\nto the caller."
      }
    },
    "26": {
      "nbr": 26,
      "value": "What is the output of the following application?\npackage body;\nimport java.io.IOException;\nclass Organ {\npublic void operate() throws IOException {\nthrow new RuntimeException(\"Not supported\");\n}\n}\npublic class Heart extends Organ {\npublic void operate() throws Exception {\nSystem.out.print(\"beat\");\n}\npublic static void main(String… c) throws Exception {\ntry {\nnew Heart().operate();\n} finally {\nSystem.out.print(\"!\");\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "beat"
      }, {
        "code": "B",
        "value": "beat!"
      }, {
        "code": "C",
        "value": "Not supported"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles, but a stack trace is printed at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "26. D. The code does not compile due to an invalid override of the operate()\nmethod. An overridden method must not throw any new or broader checked\nexceptions than the method it inherits. While both IOException and\nException are checked exceptions, Exception is broader than\nIOException. For this reason, the declaration of operate() in Heart does\nnot compile, and option D is correct."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Which of the following are not true of using a try‐with‐resources statement?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "It shortens the amount of code a developer must write."
      }, {
        "code": "B",
        "value": "It is possible to close a resource before the end of the try block."
      }, {
        "code": "C",
        "value": "Associated catch blocks are run before the declared resources have\nbeen closed."
      }, {
        "code": "D",
        "value": "It is compatible with all classes that implement the Closeable\ninterface."
      }, {
        "code": "E",
        "value": "It is compatible with all classes that implement the AutoCloseable\ninterface."
      }, {
        "code": "F",
        "value": "It cannot be used with a finally block."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "27. C,F. Option A is a true statement and one of the primary motivations for\nusing a try‐with‐resources statement. Option B is also true, although it is\nrecommended you let the try‐with‐resources statement automatically close\nthe resource. The catch blocks are run after the declared resources have\nbeen closed, making option C the first answer. Options D and E are both\ntrue, since Closeable extends AutoCloseable and the requirement for trywith‐\nresources is that they must be of type AutoCloseable. A try‐withresources\nstatement can be used with a finally block, making option F the\nother answer."
      }
    },
    "28": {
      "nbr": 28,
      "value": "What is the result of compiling and executing the following class?\npackage wind;\npublic class Storm {\npublic static void main(String… rain) throws Exception {\nvar weatherTracker = new AutoCloseable() {\npublic void close() throws RuntimeException {\nSystem.out.println(\"Thunder\");\n}\n};\ntry (weatherTracker) {\nSystem.out.println(\"Tracking\");\n} catch (Exception e) {\nSystem.out.println(\"Lightning\");\n} finally {\nSystem.out.println(\"Storm gone\");\nweatherTracker.close();\n}\n} }",
      "responses": [{
        "code": "A",
        "value": "It prints one line."
      }, {
        "code": "B",
        "value": "It prints two lines."
      }, {
        "code": "C",
        "value": "It prints three lines."
      }, {
        "code": "D",
        "value": "It prints four lines."
      }, {
        "code": "E",
        "value": "It does not compile due to an error in the declaration of the\nweatherTracker resource."
      }, {
        "code": "F",
        "value": "It does not compile for a different reason."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "28. D. The code compiles without issue. It first prints Tracking from the try\nblock. Upon the completion of the try block, the close() method is called,\nand Thunder is printed. No exception is thrown so the catch block is\nskipped. In the finally block, Storm gone is printed, followed by Thunder.\nSince four lines were printed, option D is correct. While it is not\nrecommended to close a resource twice, it is allowed."
      }
    },
    "29": {
      "nbr": 29,
      "value": "How many of the following are valid exception declarations?\nclass Error extends Exception {}\nclass _X extends IllegalArgumentException {}\nclass 2BeOrNot2Be extends RuntimeException {}\nclass NumberException<Integer> extends\nNumberFormatException {}\ninterface Worry implements NumberFormatException {}",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "29. C. Error is a terrible name for an exception since it is a built‐in class.\nHowever, it is legal. Next, _X is also a bad choice, but it is valid exception\nas Java identifiers can begin with underscores. By contrast, 2BeOrNot2Be\ndoes not compile because identifiers are not allowed to begin with a\nnumber. NumberException is not a valid exception, because it uses\ngenerics, and the parent class does not. Finally, Worry is not an exception,\nbecause it is an interface. Since only two are valid exceptions, option C is\nthe answer."
      }
    },
    "30": {
      "nbr": 30,
      "value": "If a try statement has catch blocks for both ClassCastException and\nRuntimeException, then which of the following statements is correct?",
      "responses": [{
        "code": "A",
        "value": "The catch blocks for these two exception types can be declared in any\norder."
      }, {
        "code": "B",
        "value": "A try statement cannot be declared with these two catch block types\nbecause they are incompatible."
      }, {
        "code": "C",
        "value": "The catch block for ClassCastException must appear before the\ncatch block for RuntimeException."
      }, {
        "code": "D",
        "value": "The catch block for RuntimeException must appear before the catch\nblock for ClassCastException."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "30. C. ClassCastException is a subclass of RuntimeException, so it must\nappear first in any related catch blocks. For this reason, option C is correct."
      }
    },
    "31": {
      "nbr": 31,
      "value": "Assuming Scanner is a valid class that implements AutoCloseable, what is\nthe expected output of the following application?\npackage castles;\nimport java.util.Scanner;\npublic class Fortress {\npublic void openDrawbridge() throws Exception { // p1\ntry {\nthrow new Exception(\"Circle\"); // p2\n} catch (Exception | Error e) {\nSystem.out.print(\"Opening!\");\n} finally {\nSystem.out.print(\"Walls\");\n}\n}\npublic static void main(String[] moat) {\ntry (var e = new Scanner(System.in)) {\nnew Fortress().openDrawbridge(); // p3\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Opening!Walls"
      }, {
        "code": "B",
        "value": "The code does not compile because of line p1."
      }, {
        "code": "C",
        "value": "The code does not compile because of line p2."
      }, {
        "code": "D",
        "value": "The code does not compile because of line p3."
      }, {
        "code": "E",
        "value": "The code compiles, but a stack trace is printed at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "31. D. The openDrawbridge() method declares a checked exception that is\nnot handled or declared in the main() method where it is called. For this\nreason, line p3 does not compile, and option D is correct. The rest of the\nlines do not contain any compiler errors. If the main() method were\nchanged to declare Exception, then the class would compile and print\nOpening!Walls at runtime."
      }
    },
    "32": {
      "nbr": 32,
      "value": "What is the output of the following application?\npackage game;\npublic class BasketBall {\npublic static void main(String[] dribble) {\ntry {\nSystem.out.print(1);\nthrow new ClassCastException();\n} catch (ArrayIndexOutOfBoundsException ex) {\nSystem.out.print(2);\n} catch (Throwable ex) {\nSystem.out.print(3);\n} finally {\nSystem.out.print(4);\n}\nSystem.out.print(5);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "145"
      }, {
        "code": "B",
        "value": "1345"
      }, {
        "code": "C",
        "value": "1235"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "32. B. The code compiles and runs without issues. The try block throws a\nClassCastException. Since ClassCastException is not a subclass of\nArrayIndexOutOfBoundsException, the first catch block is skipped. For\nthe second catch block, ClassCastException is a subclass of Throwable so\nthat block is executed. Afterward, the finally block is executed, and then\ncontrol returns to the main() method with no exception being thrown. The\nresult is that 1345 is printed, making option B the correct answer."
      }
    },
    "33": {
      "nbr": 33,
      "value": "Which of the following statements about finally blocks are true? (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "Every line of the finally block is guaranteed to be executed."
      }, {
        "code": "B",
        "value": "The finally block is executed only if the related catch block is also\nexecuted."
      }, {
        "code": "C",
        "value": "The finally statement requires curly braces, {}."
      }, {
        "code": "D",
        "value": "A finally block cannot throw an exception."
      }, {
        "code": "E",
        "value": "The first line of a finally block is guaranteed to be executed."
      }, {
        "code": "F",
        "value": "A finally block can only throw unchecked exceptions."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "33. C,E. A finally block requires curly braces, making option C correct. A\nfinally block can throw an exception in which case not every line of the\nfinally block will be executed. For this reason, option E is correct, and\noptions A and D are incorrect. Option B is incorrect because a finally\nblock is called regardless of whether the related catch block is executed. A\nfinally block can throw both checked and unchecked exceptions, making\noption F incorrect. If the exception is checked, then it must be handled or\ndeclared in the method in which the finally block is used."
      }
    },
    "34": {
      "nbr": 34,
      "value": "What is the output of the following application?\npackage signlanguage;\nimport java.io.Closeable;\nclass ReadSign implements Closeable {\npublic void close() {}\npublic String get() {return \"Hello\";}\n}\nclass MakeSign implements AutoCloseable {\npublic void close() {}\npublic void send(String message) {\nSystem.out.print(message);\n}\n}\npublic class Translate {\npublic static void main(String… hands) {\ntry (ReadSign r = new ReadSign();\nMakeSign w = new MakeSign();) {\nw.send(r.get());\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Hello"
      }, {
        "code": "B",
        "value": "The code does not compile because of the ReadSign class."
      }, {
        "code": "C",
        "value": "The code does not compile because of the MakeSign class."
      }, {
        "code": "D",
        "value": "The code does not compile because of the Translate class."
      }, {
        "code": "E",
        "value": "The code does not compile because of the try‐with‐resources\nstatement."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "34. A. The application compiles without issue and prints Hello, making\noption A the correct answer. The ReadSign and MakeSign classes are both\ncorrectly implemented, with both overridden versions of close() dropping\nthe checked exceptions. The try‐with‐resources statement is also correctly\nimplemented for two resources and does not cause any compilation errors\nor runtime exceptions. Note that the semicolon (;) after the second resource\ndeclaration is optional."
      }
    },
    "35": {
      "nbr": 35,
      "value": "What is the output of the following application?\npackage what;\nclass FunEvent implements AutoCloseable {\nprivate final int value;\nFunEvent(int value) { this.value = value; }\npublic void close() {\nSystem.out.print(value);\n}\n}\npublic class Happening {\npublic static void main(String… lots) {\nFunEvent e = new FunEvent(1);\ntry (e; var f = new FunEvent(8)) {\nSystem.out.print(\"2\");\nthrow new ArithmeticException();\n} catch (Exception x) {\nSystem.out.print(\"3\");\n} finally {\nSystem.out.print(\"4\");\n}\n} }",
      "responses": [{
        "code": "A",
        "value": "24"
      }, {
        "code": "B",
        "value": "21834"
      }, {
        "code": "C",
        "value": "23418"
      }, {
        "code": "D",
        "value": "23481"
      }, {
        "code": "E",
        "value": "28134"
      }, {
        "code": "F",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "35. E. The try block is entered and 2 is printed, followed by an exception.\nUpon completion of the try block, the resources are closed in the reverse\norder in which they are declared, printing 8 followed by 1. Next, the catch\nblock executes, printing 3, followed by the finally block printing 4. For\nthese reasons, option E is correct."
      }
    },
    "36": {
      "nbr": 36,
      "value": "What is the output of the following application?\npackage office;\nimport java.io.*;\npublic class Printer {\npublic void print() {\ntry {\nthrow new FileNotFoundException();\n} catch (Exception | RuntimeException e) {\nSystem.out.print(\"Z\");\n} catch (Throwable f) {\nSystem.out.print(\"X\");\n} finally {\nSystem.out.print(\"Y\");\n}\n}\npublic static void main(String… ink) {\nnew Printer().print();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Y"
      }, {
        "code": "B",
        "value": "XY"
      }, {
        "code": "C",
        "value": "ZY"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles, but a stack trace is printed at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "36. D. A multi‐catch block cannot contain two exception types in which one\ninherits from the other. Since RuntimeException inherits Exception,\nRuntimeException is redundant. For this reason, the code does not compile,\nand option D is correct."
      }
    },
    "37": {
      "nbr": 37,
      "value": "What is the output of the following code?\nclass ProblemException extends Exception {\nProblemException(Exception e) { super(e); }\n}\nclass MajorProblemException extends ProblemException {\nMajorProblemException(Exception e) { super(e); }\n}\npublic class Unfortunate {\npublic static void main(String[] args) throws Exception\n{\ntry {\nSystem.out.print(1);\nthrow new MajorProblemException(\nnew IllegalStateException());\n} catch (ProblemException | RuntimeException e) {\nSystem.out.print(2);\ntry {\nthrow new MajorProblemException(e);\n} finally {\nSystem.out.print(3);\n}\n} finally {\nSystem.out.print(4);\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "123"
      }, {
        "code": "B",
        "value": "123 followed by an exception stack trace"
      }, {
        "code": "C",
        "value": "1234"
      }, {
        "code": "D",
        "value": "1234 followed by an exception stack trace"
      }, {
        "code": "E",
        "value": "Does not compile"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "37. D. In the try block, the code prints 1 and throws an exception. The catch\nblock successfully handles it by printing 2 and throwing another exception.\nBoth the inner and outer finally blocks run printing 3 and 4, respectively.\nThen the stack trace for the exception thrown by the inner try block is\nprinted."
      }
    },
    "38": {
      "nbr": 38,
      "value": "What is the output of the following application?\n1: package robot;\n2: public class Computer {\n3: public void compute() throws Exception {\n4: throw new NullPointerException(\"Does not\ncompute!\");\n5: }\n6: public static void main(String[] b) throws Exception\n{\n7: try {\n8: new Computer().compute();\n9: } catch (RuntimeException e) {\n10: System.out.print(\"zero\");\n11: throw e;\n12: } catch (Exception e) {\n13: System.out.print(\"one\");\n14: throw e;\n15: }\n16: }\n17: }",
      "responses": [{
        "code": "A",
        "value": "zero"
      }, {
        "code": "B",
        "value": "one"
      }, {
        "code": "C",
        "value": "zero followed by a stack trace"
      }, {
        "code": "D",
        "value": "one followed by a stack trace"
      }, {
        "code": "E",
        "value": "Does not compile"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "38. C. The code compiles without issue. Line 8 calls the compute() method,\nwhich throws a NullPointerException on line 4. This is caught in the\nmain() method on line 9, since NullPointerException is a subclass of\nRuntimeException, printing zero followed by a stack trace to the caller and\nmaking option C correct."
      }
    },
    "39": {
      "nbr": 39,
      "value": "Given the following class diagram, which two classes are missing in the\nhierarchy at positions 1 and 2?",
      "responses": [{
        "code": "A",
        "value": "IOException at position 1, Exception at position 2"
      }, {
        "code": "B",
        "value": "Exception at position 1, RuntimeException at position 2"
      }, {
        "code": "C",
        "value": "IllegalArgumentException at position 1, RuntimeException at\nposition 2"
      }, {
        "code": "D",
        "value": "IllegalStateException at position 1, RuntimeException at position\n2"
      }, {
        "code": "E",
        "value": "Exception at position 1, FileNotFoundException at position 2"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "39. F. The UnsupportedOperationException class is an unchecked exception\nthat is a direct child of RuntimeException. For this reason, we can\neliminate any answer that does not inherit from RuntimeException\nincluding options A and E. Options C and D are close, but\nUnsupportedOperationException is a direct subclass of\nRuntimeException. Option B is incorrect because RuntimeException is a\nsubclass, not a superclass, of Exception. The correct diagram would be to\nreverse option B and put RuntimeException at position 1, and Exception at\nposition 2. Since this is not available, option F is correct."
      }
    },
    "40": {
      "nbr": 40,
      "value": "What is the output of the following application?\npackage vortex;\nclass TimeException extends Exception {}\nclass TimeMachine implements AutoCloseable {\nint v;\npublic TimeMachine(int v) {this.v = v;}\npublic void close() throws Exception {\nSystem.out.print(v);\n} }\npublic class TimeTraveler {\npublic static void main(String[] twelve) {\ntry (var timeSled = new TimeMachine(1);\nvar delorean = new TimeMachine(2);\nvar tardis = new TimeMachine(3)) {\n} catch (TimeException e) {\nSystem.out.print(4);\n} finally {\nSystem.out.print(5);\n}\n} }",
      "responses": [{
        "code": "A",
        "value": "1235"
      }, {
        "code": "B",
        "value": "3215"
      }, {
        "code": "C",
        "value": "5123"
      }, {
        "code": "D",
        "value": "5321"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "40. E. The close() method in each of the resources throws an Exception,\nwhich must be handled or declared in the main() method. The catch block\nsupports TimeException, but it is too narrow to catch Exception. Since\nthere are no other catch blocks present and the main() method does not\ndeclare Exception, the try‐with‐resources statement does not compile, and\noption E is the correct answer. If the catch block were modified to handle\nException instead of TimeException, the code would compile without\nissue and print 3215 at runtime, closing the resources in the reverse order in\nwhich they were declared."
      }
    },
    "41": {
      "nbr": 41,
      "value": "Which of the following are common reasons to add a checked exception to\na method signature? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "To alert developers that the state of the JVM has been corrupted"
      }, {
        "code": "B",
        "value": "To force a caller to handle or declare potential problems"
      }, {
        "code": "C",
        "value": "To ensure that exceptions never cause the application to terminate"
      }, {
        "code": "D",
        "value": "To notify the caller of potential types of problems"
      }, {
        "code": "E",
        "value": "To give the caller a chance to recover from a problem"
      }, {
        "code": "F",
        "value": "To annoy other developers"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "E"
        ],
        "explanation": "41. B,D,E. Checked exceptions are commonly used to notify or force a caller\nto deal with an expected type of problem, such as the inability to write a file\nto the file system, and give them the opportunity to recover without\nterminating the program. For these reasons, options B, D, and E are correct.\nOption A is incorrect as a corrupted JVM is likely an Error that cannot be\nrecovered from. Option C is also incorrect, as some problems should result\nin the application terminating. Finally, option F is incorrect and is ideally\nnever the motivation for adding a checked exception to a method signature!"
      }
    },
    "42": {
      "nbr": 42,
      "value": "Which statement about the following application is correct?\npackage highway;\nimport java.io.*;\nclass CarCrash extends RuntimeException {\nCarCrash(Exception e) {}\n// w1\n}\npublic class Car {\npublic static void main(String[] s) throws Exception {\n// w2\ntry {\nthrow new IOException(\"Auto-pilot error\");\n} catch (Exception | CarCrash e) {\n// w3\nthrow e;\n} catch (Exception a) {\n// w4\nthrow a;\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code does not compile because of line w1."
      }, {
        "code": "B",
        "value": "The code does not compile because of line w2."
      }, {
        "code": "C",
        "value": "The code does not compile because of line w3."
      }, {
        "code": "D",
        "value": "The code does not compile because of line w4."
      }, {
        "code": "E",
        "value": "The code compiles and prints a stack trace at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "42. C. A multi‐catch block cannot contain two exceptions in which one is a\nsubtype of the other, since it is a redundant expression. Since CarCrash is a\nsubclass of RuntimeException and RuntimeException is a subclass of\nException, line w3 contains a compilation error, making option C the\ncorrect answer. The rest of the lines of code do not contain any compilation\nerrors."
      }
    },
    "43": {
      "nbr": 43,
      "value": "Which of the following exception classes must be handled or declared in\nthe method in which they are thrown? (Choose three.)\npublic class Happy extends IOException {}\npublic class Dopey extends Grumpy {}\npublic class Sleepy extends IllegalStateException {}\npublic class Sneezy extends UnsupportedOperationException\n{}\npublic class Doc extends AssertionError {}\npublic class Grumpy extends SQLException {}",
      "responses": [{
        "code": "A",
        "value": "Happy"
      }, {
        "code": "B",
        "value": "Dopey"
      }, {
        "code": "C",
        "value": "Sleepy"
      }, {
        "code": "D",
        "value": "Sneezy"
      }, {
        "code": "E",
        "value": "Doc"
      }, {
        "code": "F",
        "value": "Grumpy"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "F"
        ],
        "explanation": "43. A,B,F. Since IOException and SQLException are checked exceptions,\nHappy and Grumpy are checked exceptions, respectively, making options A\nand F correct. Since Dopey inherits Grumpy, option B is also a checked\nexception. Options C and D are unchecked exceptions because those classes\ninherit RuntimeException. Option E is also an unchecked exception\nbecause all Error classes are unchecked."
      }
    },
    "44": {
      "nbr": 44,
      "value": "What is the output of the following application?\npackage pond;\nabstract class Duck {\nprotected int count;\npublic abstract int getDuckies();\n}\npublic class Ducklings extends Duck {\nprivate int age;\npublic Ducklings(int age) { this.age = age; }\npublic int getDuckies() { return this.age/count; }\npublic static void main(String[] pondInfo) {\nDuck itQuacks = new Ducklings(5);\nSystem.out.print(itQuacks.getDuckies());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "5"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "44. E. The code compiles without issue, so option D is incorrect. The key here\nis noticing that count, an instance variable, is initialized with a value of 0.\nThe getDuckies() method ends up computing 5/0, which leads to an\nunchecked ArithmeticException at runtime, making option E the correct\nanswer."
      }
    },
    "45": {
      "nbr": 45,
      "value": "Which statements about the following line of code are correct? (Choose\nthree.)\nthrow new IllegalArgumentException ();",
      "responses": [{
        "code": "A",
        "value": "The method where this is called must declare a compatible exception."
      }, {
        "code": "B",
        "value": "The code where this is called can include a try‐with‐resources block\nthat handles this exception."
      }, {
        "code": "C",
        "value": "This exception should not be handled or declared."
      }, {
        "code": "D",
        "value": "The code where this is called can include a try/catch block that\nhandles this exception."
      }, {
        "code": "E",
        "value": "This exception should be thrown only at the start of a method."
      }, {
        "code": "F",
        "value": "This exception does not need to be handled by the method in which it\nis called."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "F"
        ],
        "explanation": "45. B,D,F. An IllegalArgumentException is an unchecked exception. It can\nbe handled or declared in the method in which it is defined, although it is\noptional and not required. For this reason, options B, D, and F are correct,\nand options A and C are incorrect. Option E is incorrect, as there is no\nrequirement where in a method this exception can be thrown."
      }
    },
    "46": {
      "nbr": 46,
      "value": "What is the output of the following application?\npackage storage;\nimport java.io.*;\npublic class Backup {\npublic void performBackup() {\ntry {\nthrow new IOException(\"Disk not found\"); // z1\n} catch (Exception e) {\ntry {\nthrow new FileNotFoundException(\"File not\nfound\");\n} catch (FileNotFoundException e) { // z2\nSystem.out.print(\"Failed\");\n}\n}\n}\npublic static void main(String… files) {\nnew Backup().performBackup(); // z2\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Failed"
      }, {
        "code": "B",
        "value": "The application compiles, but a stack trace is printed at runtime."
      }, {
        "code": "C",
        "value": "The code does not compile because of line z1."
      }, {
        "code": "D",
        "value": "The code does not compile because of line z2."
      }, {
        "code": "E",
        "value": "The code does not compile because of line z3."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "46. D. While a catch block is permitted to include an embedded try‐catch\nblock, the issue here is that the variable name e is already used by the first\ncatch block. In the second catch block, it is equivalent to declaring a\nvariable e twice. For this reason, line z2 does not compile, and option D is\nthe correct answer. If a different variable name was used for either catch\nblock, then the code would compile without issue, printing Failed at\nruntime."
      }
    },
    "47": {
      "nbr": 47,
      "value": "What is the output of the following?\npackage com.tps;\nimport java.io.IOException;\npublic class IncidentReportException extends\nRuntimeException {\npublic static void main(String[] args) throws Exception\n{\ntry {\nthrow new IncidentReportException(new\nIOException());\n} catch (RuntimeException e) {\nSystem.out.println(e.getCause());\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "com.tps.IncidentReportException"
      }, {
        "code": "B",
        "value": "java.lang.IOException"
      }, {
        "code": "C",
        "value": "The code does not compile because IOException is a checked\nexception."
      }, {
        "code": "D",
        "value": "The code does not compile due to the declaration of\nIncidentReportException."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "47. D. The declaration of IncidentReportException does not provide any\nconstructors, which means only the default constructor is available. Since\nthe code attempts to pass an IOException as a parameter, the main()\nmethod does not compile, so the correct answer is option D."
      }
    },
    "48": {
      "nbr": 48,
      "value": "Which expression, when inserted into the blank in the following class,\nallows the code to compile?\npackage music;\nimport java.sql.*;\npublic class Bells {\nclass Player implements AutoCloseable {\n@Override public void close() throws RingException {}\n}\nclass RingException extends Exception {\npublic RingException(String message) {}\n}\npublic static void main(String[] notes) throws Throwable\n{\ntry (Player p = null) {\nthrow new Exception();\n} catch (Exception e) {\n} catch (_______________) {\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Error r"
      }, {
        "code": "B",
        "value": "IllegalStateException b"
      }, {
        "code": "C",
        "value": "RingException q"
      }, {
        "code": "D",
        "value": "SQLException p"
      }, {
        "code": "E",
        "value": "RuntimeException r"
      }, {
        "code": "F",
        "value": "The code does not compile regardless of the expression used."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "48. A. The try‐catch block already catches Exception, so the correct answer\nwould be the one that is not a subtype of Exception. In this case, Error\nextends Throwable and is the only choice that allows the code to compile,\nmaking option A correct."
      }
    },
    "49": {
      "nbr": 49,
      "value": "What is the output of the following application?\npackage zoo;\nclass BigCat {\nvoid roar(int level) throw RuntimeException {\nif(level<3) throw new IllegalArgumentException();\nSystem.out.print(\"Roar!\");\n}\n}\npublic class Lion extends BigCat {\npublic void roar() {\nSystem.out.print(\"Roar!!!\");\n}\nvoid roar(int sound) {\nSystem.out.print(\"Meow\");\n}\npublic static void main(String[] cubs) {\nfinal BigCat kitty = new Lion();\nkitty.roar(2);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Meow"
      }, {
        "code": "B",
        "value": "Roar!"
      }, {
        "code": "C",
        "value": "Roar!!!"
      }, {
        "code": "D",
        "value": "MeowRoar!"
      }, {
        "code": "E",
        "value": "A stack trace is printed at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "49. F. The application does not compile because the roar() method in the\nBigCat class uses throw instead of throws, making option F correct. Note\nthat if the correct keyword was used, then the code would compile and print\nMeow at runtime."
      }
    },
    "50": {
      "nbr": 50,
      "value": "Which statement about the following program is true?\npackage tag;\nclass MissedCallException extends Exception {}\npublic class Phone {\nstatic void makeCall() throws RuntimeException {\nthrow new ArrayIndexOutOfBoundsException(\"Call\");\n}\npublic static void main(String[] messages) {\ntry {\nmakeCall();\n} catch (MissedCallException e) {\nthrow new RuntimeException(\"Voicemail\");\n} finally {\nthrow new RuntimeException(\"Text\");\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "An exception is printed at runtime with Call in the message."
      }, {
        "code": "B",
        "value": "An exception is printed at runtime with Voicemail in the message."
      }, {
        "code": "C",
        "value": "An exception is printed at runtime with Text in the message."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "50. D. The MissedCallException is a checked exception since it extends\nException and does not inherit RuntimeException. For this reason, the first\ncatch block fails to compile, since the compiler detects that it is not\npossible to throw this checked exception inside the try block, making\noption D the correct answer. Note that if MissedCallException was\nchanged to extend the unchecked RuntimeException class, then the code\nwould compile and the RuntimeException from the finally block would\nreplace the ArrayIndexOutOfBoundsException from the try block and\nText would be in the message to the caller."
      }
    },
    "51": {
      "nbr": 51,
      "value": "If a try statement has catch blocks for both IllegalArgumentException\nand NullPointerException, then which of the following statements is\ncorrect?",
      "responses": [{
        "code": "A",
        "value": "The catch blocks for these two exception types can be declared in any\norder."
      }, {
        "code": "B",
        "value": "A try statement cannot be declared with these two catch block types\nbecause they are incompatible."
      }, {
        "code": "C",
        "value": "The catch block for IllegalArgumentException must appear before\nthe catch block for NullPointerException."
      }, {
        "code": "D",
        "value": "The catch block for NullPointerException must appear before the\ncatch block for IllegalArgumentException."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "51. A. Both IllegalArgumentException and NullPointerException inherit\nRuntimeException, but neither inherits from each other. For this reason,\nthey can be listed in catch blocks in either order, making option A the\ncorrect statement."
      }
    },
    "52": {
      "nbr": 52,
      "value": "What is the output of the following application?\npackage furniture;\nclass Chair {\npublic void sit() throws IllegalArgumentException {\nSystem.out.print(\"creek\");\nthrow new RuntimeException();\n}\n}\npublic class Stool extends Chair {\npublic void sit() throws RuntimeException {\nSystem.out.print(\"thud\");\n}\npublic static void main(String… c) throws Exception {\ntry {\nnew Stool().sit();\n} finally {\nSystem.out.print(\"?\");\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "creek"
      }, {
        "code": "B",
        "value": "thud"
      }, {
        "code": "C",
        "value": "thud?"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles, but a stack trace is printed at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "52. C. While RuntimeException is broader than IllegalArgumentException,\nthe restriction on overriding methods applies only to checked exceptions,\nnot unchecked exceptions. In other words, the code would not compile if\nboth of the exceptions were checked. Since they are unchecked, though, the\nmethod override is valid. The program compiles and prints thud? at\nruntime, making option C correct."
      }
    },
    "53": {
      "nbr": 53,
      "value": "What is the output of the following application?\nimport java.io.*;\nimport java.sql.*;\npublic class DatabaseHelper {\nstatic class MyDatabase implements Closeable {\npublic void close() throws SQLException {\nSystem.out.print(\"2\");\n}\npublic void write(String data) {}\npublic String read() {return null;}\n}\npublic static void main(String… files) throws Exception\n{\ntry (MyDatabase myDb = new MyDatabase()) {\n// TODO: Decide what to read/rite\n} finally {\nSystem.out.print(\"1\");\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "12"
      }, {
        "code": "B",
        "value": "21"
      }, {
        "code": "C",
        "value": "The code does not compile because of the MyDatabase nested class."
      }, {
        "code": "D",
        "value": "The code does not compile because of the try‐with‐resources\nstatement."
      }, {
        "code": "E",
        "value": "The code does not compile for a different reason."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "53. C. The Closeable interface defines a close() method that throws\nIOException. The overridden implementation of MyDatabase, which\nimplements Closeable, declares a SQLException. This is a new checked\nexception not found in the inherited method signature. Therefore, the\nmethod override is invalid, and the close() method in MyDatabase does not\ncompile, making option C the correct answer."
      }
    },
    "54": {
      "nbr": 54,
      "value": "What constructors are capable of being called on a custom exception class\nthat directly extends the Exception class?",
      "responses": [{
        "code": "A",
        "value": "One that takes a single Exception"
      }, {
        "code": "B",
        "value": "One that takes a single String"
      }, {
        "code": "C",
        "value": "Both of these"
      }, {
        "code": "D",
        "value": "Neither of these"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "54. C. Custom exception classes may simply use the default constructor. It is\nalso common to override the constructors that take a single Exception or a\nsingle String, making option C correct."
      }
    },
    "55": {
      "nbr": 55,
      "value": "What is the result of compiling and running the following application?\npackage dinner;\npublic class Pizza {\nException order(RuntimeException e) { // h1\nthrow e; // h2\n}\npublic static void main(String… u) {\nvar p = new Pizza();\ntry {\np.order(new IllegalArgumentException()); // h3\n} catch(RuntimeException e) { // h4\nSystem.out.print(e);\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "java.lang.IllegalArgumentException is printed."
      }, {
        "code": "B",
        "value": "The code does not compile because of line h1."
      }, {
        "code": "C",
        "value": "The code does not compile because of line h2."
      }, {
        "code": "D",
        "value": "The code does not compile because of line h3."
      }, {
        "code": "E",
        "value": "The code does not compile because of line h4."
      }, {
        "code": "F",
        "value": "The code compiles, but a stack trace is printed at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "55. A. While this code looks a bit strange, it does compile. An exception can\nbe passed to a method or set as the return type of a method. In this case, the\nexception passed to the order() method is thrown and caught on line h4.\nThe output is just the name of the class, making option A correct."
      }
    },
    "56": {
      "nbr": 56,
      "value": "Given an application that hosts a website, which of the following would\nmost likely result in a java.lang.Error being thrown? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "A user tries to sign in too many times."
      }, {
        "code": "B",
        "value": "Two users try to register an account at the same time."
      }, {
        "code": "C",
        "value": "An order update page calls itself infinitely."
      }, {
        "code": "D",
        "value": "The application temporarily loses connection to the network."
      }, {
        "code": "E",
        "value": "A user enters their password incorrectly."
      }, {
        "code": "F",
        "value": "The connections to a database are never released and keep\naccumulating."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "56. C,F. A Java application tends to only throw an Error when the application\nhas encountered an unrecoverable error. Failure of a user to sign in or\nregister are common occurrences, making options A, B, and E incorrect. On\nthe other hand, calling a method infinitely can lead to an unrecoverable\nStackOverflowError, making option C correct. Option D uses the word\ntemporarily, meaning the network connection could come back up allowing\nthe application to recover. Option F is the other correct answer. Over time,\nfailing to release database connections could result in the application\nrunning out of available database connections or worse, out of memory, and\nbeing unable to recover."
      }
    },
    "57": {
      "nbr": 57,
      "value": "How many lines of text does the following program print?\npackage tron;\nclass DiskPlayer implements AutoCloseable {\npublic void close() {}\n}\npublic class LightCycle {\npublic static void main(String… bits) {\ntry (DiskPlayer john = new DiskPlayer()) {\nSystem.out.println(\"ping\");\njohn.close();\n} finally {\nSystem.out.println(\"pong\");\njohn.close();\n}\nSystem.out.println(\"return\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "Three."
      }, {
        "code": "D",
        "value": "The code does not compile because of the DiskPlayer class."
      }, {
        "code": "E",
        "value": "The code does not compile for a different reason."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "57. E. The code does not compile because john is declared in the try‐withresources\nstatement and not accessible in the finally block."
      }
    },
    "58": {
      "nbr": 58,
      "value": "What is the output of the following?\npackage com.tps;\nimport java.io.IOException;\npublic class IncidentReportException extends\nRuntimeException {\npublic IncidentReportException(Exception e) {\nsuper(e);\n}\npublic static void main(String[] args) throws Exception\n{\ntry {\nthrow new IncidentReportException(new\nIOException());\n} catch (RuntimeException e) {\nSystem.out.println(e.getCause());\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "com.tps.IncidentReportException"
      }, {
        "code": "B",
        "value": "java.lang.IOException"
      }, {
        "code": "C",
        "value": "The code does not compile because IOException is a checked\nexception."
      }, {
        "code": "D",
        "value": "The code does not compile due to the declaration of\nIncidentReportException."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "58. B. The code does compile, making options C and D incorrect. The catch\nblock successfully catches the IncidentReportException and prints the\nIOException passed to its constructor, making option B the correct answer."
      }
    },
    "59": {
      "nbr": 59,
      "value": "Given the following application, what is the name of the class printed at\nline e1?\npackage canyon;\nfinal class FallenException extends Exception {}\nfinal class HikingGear implements AutoCloseable {\n@Override public void close() throws Exception {\nthrow new FallenException();\n}\n}\npublic class Cliff {\npublic final void climb() throws Exception {\ntry (HikingGear gear = new HikingGear()) {\nthrow new RuntimeException();\n}\n}\npublic static void main(String… rocks) {\ntry {\nnew Cliff().climb();\n} catch (Throwable t) {\nSystem.out.println(t); // e1\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "canyon.FallenException"
      }, {
        "code": "B",
        "value": "java.lang.RuntimeException"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles, but the answer cannot be determined until runtime."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "59. B. The code compiles without issue, making option C incorrect. In the\nclimb() method, two exceptions are thrown. The RuntimeException\nthrown in the try block is considered the primary exception, while the\nFallenException thrown by the close() method is suppressed. For this\nreason, java.lang.RuntimeException is reported to the caller in the\nmain() method, and option B is the correct answer."
      }
    },
    "60": {
      "nbr": 60,
      "value": "Given the following application, which specific type of exception will be\nprinted in the stack trace at runtime?\npackage carnival;\npublic class WhackAnException {\npublic static void main(String… hammer) {\ntry {\nthrow new ClassCastException();\n} catch (IllegalArgumentException e) {\nthrow new IllegalArgumentException();\n} catch (RuntimeException e) {\nthrow new NullPointerException();\n} finally {\nthrow new RuntimeException();\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "ClassCastException"
      }, {
        "code": "B",
        "value": "IllegalArgumentException"
      }, {
        "code": "C",
        "value": "NullPointerException"
      }, {
        "code": "D",
        "value": "RuntimeException"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "60. D. For this question, notice that all the exceptions thrown or caught are\nunchecked exceptions. First, the ClassCastException is thrown in the try\nblock and caught by the second catch block, since it inherits from\nRuntimeException, not IllegalArgumentException. Next, a\nNullPointerException is thrown, but before it can be returned the finally\nblock is executed and a RuntimeException replaces it. The application\nexits, and the caller sees the RuntimeException in the stack trace, making\noption D the correct answer. If the finally block did not throw any\nexceptions, then NullPointerException would be printed at runtime."
      }
    }
  }
}, {
  "name": "Working with Arrays and Collections",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "What is the output of the following?\nList<String> museums = new ArrayList<>(1);\nmuseums.add(\"Natural History\");\nmuseums.add(\"Science\");\nmuseums.add(\"Art\");\nmuseums.remove(2);\nSystem.out.println(museums);",
      "responses": [{
        "code": "A",
        "value": "[Natural History, Science]"
      }, {
        "code": "B",
        "value": "[Natural History, Art, Science]"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "1. A. While the ArrayList is declared with an initial capacity of one\nelement, it is free to expand as more elements are added. Each of the three\ncalls to the add() method adds an element to the end of the ArrayList. The\nremove() method call deletes the element at index 2, which is Art.\nTherefore, option A is correct."
      }
    },
    "2": {
      "nbr": 2,
      "value": "How many of the following are legal declarations?\n[]String lions = new String[];\nString[] tigers = new String[1] {\"tiger\"};\nString bears[] = new String[] {};\nString ohMy [] = new String[0] {};",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "2. B. The array brackets, [], are not allowed to appear before the type,\nmaking the lions declaration incorrect. When using an array initializer\nwith braces, {}, you are not allowed to specify the size separately. The size\nis inferred from the number of elements listed. Therefore, tigers and ohMy\nare incorrect. When you're not using an array initializer, the size is required.\nAn empty array initializer is allowed. Option B is correct because only\nbears is legal."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Which of the following can fill in the blank to make the code compile?\npublic class News<____> {}",
      "responses": [{
        "code": "A",
        "value": "? only"
      }, {
        "code": "B",
        "value": "N only"
      }, {
        "code": "C",
        "value": "? and N"
      }, {
        "code": "D",
        "value": "News, and Object"
      }, {
        "code": "E",
        "value": "N, News, and Object"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "3. E. When declaring a class that uses generics, you must specify a name for\nthe formal type parameter. Java uses the standard rules for naming a\nvariable or class. A question mark is not allowed in a variable name,\nmaking options A and C incorrect. While it is common practice to use a\nsingle uppercase letter for the type parameter, this is not required. It\ncertainly isn't a good idea to use existing class names like the News class\nbeing declared here or the Object class built into Java. However, both are\nallowed, making option E the answer."
      }
    },
    "4": {
      "nbr": 4,
      "value": "What is true of this code? (Choose two.)\n26: List<String> strings = new ArrayList<?>();\n27: var ints = new HashSet<Integer>();\n28: Double dbl = 5.0;\n29: ints.add(2);\n30: ints.add(null);",
      "responses": [{
        "code": "A",
        "value": "The code compiles as is."
      }, {
        "code": "B",
        "value": "One line needs to be removed for the code to compile."
      }, {
        "code": "C",
        "value": "Two lines need to be removed for the code to compile."
      }, {
        "code": "D",
        "value": "One line of code uses autoboxing."
      }, {
        "code": "E",
        "value": "Two lines of code use autoboxing."
      }, {
        "code": "F",
        "value": "Three lines of code use autoboxing."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "4. B,E. Option B is one answer because line 26 does not compile. The ?\nwildcard cannot be used when instantiating a type on the right side of the\nassignment operator. The other lines do compile. Additionally, option E is\ncorrect because lines 28 and 29 use autoboxing. They convert a primitive to\na wrapper object, in this case Double and Integer, respectively. Line 30 is\ncorrect and does not use autoboxing. It places a null reference as the\nInteger object."
      }
    },
    "5": {
      "nbr": 5,
      "value": "Which of the following creates an empty two‐dimensional array with\ndimensions 2×2?",
      "responses": [{
        "code": "A",
        "value": "int[][] blue = new int[2, 2];"
      }, {
        "code": "B",
        "value": "int[][] blue = new int[2], [2];"
      }, {
        "code": "C",
        "value": "int[][] blue = new int[2][2];"
      }, {
        "code": "D",
        "value": "int[][] blue = new int[2 x 2];"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "5. C. A two‐dimensional array is declared by listing both sizes in separate\npairs of brackets, []. Option C correctly shows this syntax."
      }
    },
    "6": {
      "nbr": 6,
      "value": "What is the output of the following?\nvar q = new ArrayDeque<String>();\nq.offer(\"snowball\");\nq.offer(\"minnie\");\nq.offer(\"sugar\");\nSystem.out.println(q.peek() + \" \" + q.peek() + \" \" +\nq.size());",
      "responses": [{
        "code": "A",
        "value": "sugar sugar 3"
      }, {
        "code": "B",
        "value": "sugar minnie 1"
      }, {
        "code": "C",
        "value": "snowball minnie 1"
      }, {
        "code": "D",
        "value": "snowball snowball 3"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "6. D. The offer() method inserts an element at the end of the queue. This\nmeans the queue contains [snowball, minnie, sugar]. The peek()\nmethod returns the element at the front of the queue without removing it.\nTherefore, snowball is printed twice, but the queue remains with three\nelements. This matches option D."
      }
    },
    "7": {
      "nbr": 7,
      "value": "We are running a library. Patrons select books by name. They get at the\nback of the checkout line. When they get to the front, they scan the book's\nISBN, a unique identification number. The checkout system finds the book\nbased on this number and marks the book as checked out. Of these choices,\nwhich data structures best represent the line to check out the book and the\nbook lookup to mark it as checked out, respectively?",
      "responses": [{
        "code": "A",
        "value": "ArrayList, HashSet"
      }, {
        "code": "B",
        "value": "ArrayList, TreeMap"
      }, {
        "code": "C",
        "value": "ArrayList, TreeSet"
      }, {
        "code": "D",
        "value": "LinkedList, HashSet"
      }, {
        "code": "E",
        "value": "LinkedList, TreeMap"
      }, {
        "code": "F",
        "value": "LinkedList, TreeSet"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "7. E. Notice how there is unnecessary information in this description. The\nfact that patrons select books by name is irrelevant. The checkout line is a\nperfect example of a Queue. We need easy access to one end of the Queue\nfor patrons to add themselves to the queue. We also need easy access for\npatrons to get off the queue when it is their turn. Since a LinkedList is a\nQueue, this narrows down the answer to options D, E, and F.\nThe book lookup by ISBN is a lookup by key. We need a map for this. A\nHashMap is probably better here, but it isn't a choice. So the answer is option\nE, which does include both a Queue and a Map."
      }
    },
    "8": {
      "nbr": 8,
      "value": "What is the result of running the following program?\n1: package fun;\n2: public class Sudoku {\n3: static int[][] game;\n4:\n5: public static void main(String[] args) {\n6: game[3][3] = 6;\n7: Object[] obj = game;\n8: game[3][3] = \"X\";\n9: System.out.println(game[3][3]);\n10: }\n11: }",
      "responses": [{
        "code": "A",
        "value": "X"
      }, {
        "code": "B",
        "value": "The code does not compile."
      }, {
        "code": "C",
        "value": "The code compiles but throws a NullPointerException at runtime."
      }, {
        "code": "D",
        "value": "The code compiles but throws a different exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "8. B. Line 8 attempts to store a String in an array meant for an int. Line 8\ndoes not compile, and option B is correct."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Suppose we want to implement a Comparator<String> so that it sorts the\nlongest strings first. You may assume there are no null values. Which\nmethod could implement such a comparator?",
      "responses": [{
        "code": "A",
        "value": "public int compare(String s1, String s2) {\nreturn s1.length() - s2.length();\n}"
      }, {
        "code": "B",
        "value": "public int compare(String s1, String s2) {\nreturn s2.length() – s1.length();\n}"
      }, {
        "code": "C",
        "value": "public int compare(Object obj1, Object obj2) {\nString s1 = (String) obj1;\nString s2 = (String) obj2;\nreturn s1.length() - s2.length();\n}"
      }, {
        "code": "D",
        "value": "public int compare(Object obj1, Object obj2) {\nString s1 = (String) obj1;\nString s2 = (String) obj2;\nreturn s2.length() – s1.length();\n}"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "9. B. Options C and D are incorrect because the method signature is\nincorrect. Unlike the equals() method, the method in Comparator<String>\ntakes the type being compared as the parameters when using generics.\nOption A is a valid Comparator<String>. However, it sorts in ascending\norder by length. Option B is correct. If s1 is three characters and s2 is one\ncharacter, it returns ‐2. The negative value says that s1 should sort first,\nwhich is correct, because we want the longest String first."
      }
    },
    "10": {
      "nbr": 10,
      "value": "How many lines does the following code output?\nvar days = new String[] { \"Sunday\", \"Monday\", \"Tuesday\",\n\"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };\nfor (int i = 1; i < days.length; i++)\nSystem.out.println(days[i]);",
      "responses": [{
        "code": "A",
        "value": "Zero."
      }, {
        "code": "B",
        "value": "Six."
      }, {
        "code": "C",
        "value": "Seven."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "10. B. In Java, arrays are indexed starting with 0. While it is unusual for the\nloop to start with 1, this does not cause an error. It does cause the code to\noutput six lines instead of seven, since the loop doesn't cover the first array\nelement. Therefore, option B is correct."
      }
    },
    "11": {
      "nbr": 11,
      "value": "Which cannot fill in the blank for this code to compile?\nvar c = new _______________<String>();\nc.add(\"pen\");\nc.remove(\"pen\");\nSystem.out.println(c.isEmpty());",
      "responses": [{
        "code": "A",
        "value": "ArrayList"
      }, {
        "code": "B",
        "value": "LinkedList"
      }, {
        "code": "C",
        "value": "TreeMap"
      }, {
        "code": "D",
        "value": "TreeSet"
      }, {
        "code": "E",
        "value": "All of these can fill in the blank."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "11. C. Java talks about the collections framework, but the Map interface does\nnot actually implement the Collection interface. TreeMap has different\nmethods than the other options. It cannot fill in the blank, so option C is\ncorrect."
      }
    },
    "12": {
      "nbr": 12,
      "value": "What is true of the following code? (Choose two.)\nprivate static void sortAndSearch(String… args) {\nvar one = args[0];\nArrays.sort(args);\n________ result = Arrays.binarySearch(args, one);\nSystem.out.println(result);\n}\npublic static void main(String[] args) {\nsortAndSearch(\"seed\", \"flower\");\n}",
      "responses": [{
        "code": "A",
        "value": "If the blank contains int, then the code outputs 0."
      }, {
        "code": "B",
        "value": "If the blank contains int, then the code outputs 1."
      }, {
        "code": "C",
        "value": "If the blank contains int, then the does not compile."
      }, {
        "code": "D",
        "value": "If the blank contains String, then the code outputs flower."
      }, {
        "code": "E",
        "value": "If the blank contains String, then the code outputs seed."
      }, {
        "code": "F",
        "value": "If the blank contains String, then the code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "12. B,F. In Java, Arrays.binarySearch() returns a positive int, representing\nthe index of a match if one is found. An int cannot be stored in a String\nvariable, making option F one of the answers. When using the correct data\ntype and searching for seed, we find it at index 1. Therefore, option B is the\nother correct answer."
      }
    },
    "13": {
      "nbr": 13,
      "value": "How many of the following are legal declarations?\npublic void greek() {\n[][]String alpha;\n[]String beta;\nString[][] gamma;\nString[] delta[];\nString epsilon[][];\nvar[][] zeta;\n}",
      "responses": [{
        "code": "A",
        "value": "One"
      }, {
        "code": "B",
        "value": "Two"
      }, {
        "code": "C",
        "value": "Three"
      }, {
        "code": "D",
        "value": "Four"
      }, {
        "code": "E",
        "value": "Five"
      }, {
        "code": "F",
        "value": "Six"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "13. C. As with a one‐dimensional array, the brackets, [], must be after the\ntype, making alpha and beta illegal declarations. For a multidimensional\narray, the brackets may be before and/or after the variable name. They do\nnot need to be in the same place. Therefore, gamma, delta, and epsilon are\ncorrect. Finally, var can be used as a local variable, but not with array\nbrackets after it. The code would compile if it said var zeta. Since three\noptions are correct, the answer is option C."
      }
    },
    "14": {
      "nbr": 14,
      "value": "What is the result of the following?\nvar list = new ArrayList<Integer>();\nlist.add(56);\nlist.add(56);\nlist.add(3);\nvar set = new TreeSet<Integer>(list);\nSystem.out.print(set.size());\nSystem.out.print(\" \" );\nSystem.out.print(set.iterator().next());",
      "responses": [{
        "code": "A",
        "value": "2 3"
      }, {
        "code": "B",
        "value": "2 56"
      }, {
        "code": "C",
        "value": "3 3"
      }, {
        "code": "D",
        "value": "3 56"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "14. A. First the code creates an ArrayList of three elements. Then the list is\ntransformed into a TreeSet. Since sets are not allowed to have duplicates,\nthe set only has two elements. Remember that a TreeSet is sorted, which\nmeans that the first element in the TreeSet is 3. Therefore, option A is\ncorrect."
      }
    },
    "15": {
      "nbr": 15,
      "value": "What is true of the code when run as java Copier.java? (Choose two.)\n1: import java.util.Arrays;\n2:\n3: public class Copier {\n4: public static void main(String… original) {\n5: String… copy = original;\n6: Arrays.linearSort(original);\n7: Arrays.search(original, \"\");\n8: System.out.println(original.size()\n9: + \" \" + original[0]);\n10: }\n11: }",
      "responses": [{
        "code": "A",
        "value": "One line contains a compiler error."
      }, {
        "code": "B",
        "value": "Two lines contain a compiler error."
      }, {
        "code": "C",
        "value": "Three lines contain a compiler error."
      }, {
        "code": "D",
        "value": "Four lines contain a compiler error."
      }, {
        "code": "E",
        "value": "If the compiler errors were fixed, the code would throw an exception."
      }, {
        "code": "F",
        "value": "If the compiler errors were fixed, the code would run successfully."
      }
      ],
      "answer": {
        "codes": [
          "D",
          "E"
        ],
        "explanation": "15. D,E. Three dots in a row is a varargs parameter. While varargs is used like\nan array from within the method, it can only be used as a method parameter.\nThis syntax is not allowed for a variable, causing a compiler error on line 5.\nLine 6 does not compile because linearSort() should be sort(). On line\n7, the method name is also incorrect. The search() should be\nbinarySearch(). Finally, line 9 uses size() instead of length. Since there\nare four errors, option D is correct. If all these errors were corrected,\noriginal[0] would cause an exception because the array is empty.\nTherefore, option E is also correct."
      }
    },
    "16": {
      "nbr": 16,
      "value": "What is the output of the following? (Choose three.)\n20: var chars = new _______________<Character>();\n21: chars.add('a');\n22: chars.add(Character.valueOf('b'));\n23: chars.set(1, 'c');\n24: chars.remove(0);\n25: System.out.print(chars.size() + \" \" +\nchars.contains('b'));",
      "responses": [{
        "code": "A",
        "value": "When inserting ArrayList into the blank, the code prints 1 false."
      }, {
        "code": "B",
        "value": "When inserting ArrayList into the blank, the code does not compile."
      }, {
        "code": "C",
        "value": "When inserting HashMap into the blank, the code prints 1 false."
      }, {
        "code": "D",
        "value": "When inserting HashMap into the blank, the code does not compile."
      }, {
        "code": "E",
        "value": "When inserting HashSet into the blank, the code prints 1 false."
      }, {
        "code": "F",
        "value": "When inserting HashSet into the blank, the code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "F"
        ],
        "explanation": "16. A,D,F. Line 20 does not compile for a Map because it requires two generic\ntypes. Line 23 does not compile for a Set because the elements are\nunordered and do not have an index. This makes options D and F correct.\nAdditionally, option A is correct because line 23 replaces the second\nelement with a new value, making chars contain [a, c]. Then line 24\nremoves the first element, making it just [c]. There is only one element, but\nit is not the value b."
      }
    },
    "17": {
      "nbr": 17,
      "value": "What is the output of the following?\nclass Magazine {\nprivate String name;\npublic Magazine(String name) {\nthis.name = name;\n}\npublic int compareTo(Magazine m) {\nreturn name.compareTo(m.name);\n}\npublic String toString() {\nreturn name;\n}\n}\npublic class Newsstand {\npublic static void main(String[] args) {\nvar set = new TreeSet<Magazine>();\nset.add(new Magazine(\"highlights\"));\nset.add(new Magazine(\"Newsweek\"));\nset.add(new Magazine(\"highlights\"));\nSystem.out.println(set.iterator().next());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "highlights"
      }, {
        "code": "B",
        "value": "Newsweek"
      }, {
        "code": "C",
        "value": "null"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "17. E. The Magazine class doesn't implement Comparable<Magazine>. It\nhappens to implement the compareTo() method properly, but it is missing\nactually writing implements Comparable. Since TreeSet doesn't look to\nsee if the object can be compared until runtime, this code throws a\nClassCastException when TreeSet calls add(), so option E is correct."
      }
    },
    "18": {
      "nbr": 18,
      "value": "Which is the first line to prevent this code from compiling and running\nwithout error?\nchar[][] ticTacToe = new char[3][3]; // r1\nticTacToe[1][3] = 'X'; // r2\nticTacToe[2][2] = 'X';\nticTacToe[3][1] = 'X';\nSystem.out.println(ticTacToe.length + \" in a row!\"); // r3",
      "responses": [{
        "code": "A",
        "value": "Line r1"
      }, {
        "code": "B",
        "value": "Line r2"
      }, {
        "code": "C",
        "value": "Line r3"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "18. B. Arrays begin with an index of 0. This array is a 3×3 array, making only\nindexes 0, 1, and 2 valid. Line r2 throws an\nArrayIndexOutOfBoundsException. Therefore, option B is correct."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What is the first line with a compiler error?\nclass Mammal {}\nclass Bat extends Mammal {}\nclass Cat extends Mammal {}\nclass Sat {}\nclass Fur<T extends Mammal> { // line R\nvoid clean() {\nvar bat = new Fur<Bat>(); // line S\nvar cat = new Fur<Cat>(); // line T\nvar sat = new Fur<Sat>(); // line U\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Line R"
      }, {
        "code": "B",
        "value": "Line S"
      }, {
        "code": "C",
        "value": "Line T"
      }, {
        "code": "D",
        "value": "Line U"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "19. D. The generic declaration on line R is valid. It sets a constraint on the\ngeneric type used when declaring a Fur object. Lines S and T compile as\nthey meet this constraint. However, line U has a problem since Sat does not\nextend Mammal. Since this line does not compile, option D is the answer."
      }
    },
    "20": {
      "nbr": 20,
      "value": "What is a possible result of this code?\n17: var nums = new HashSet<Long>();\n18: nums.add((long) Math.min(5, 3));\n19: nums.add(Math.round(3.14));\n20: nums.add((long) Math.pow(4,2));\n21: System.out.println(nums);",
      "responses": [{
        "code": "A",
        "value": "[3]"
      }, {
        "code": "B",
        "value": "[16]"
      }, {
        "code": "C",
        "value": "[16, 3]"
      }, {
        "code": "D",
        "value": "[16, 3, 3]"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "20. C. Line 18 puts 3 in nums since it is the smaller value. Since a Set must\nhave unique elements, line 19 does not add another value to nums. Line 20\nadds the final value of 16. The set has a total of two elements, 3 and 16. A\nHashSet does not commit to an output order, making option C correct."
      }
    },
    "21": {
      "nbr": 21,
      "value": "What is the output of the following?\n5: var x = new LinkedList<Integer>();\n6: x.offer(18);\n7: x.offer(5);\n8: x.push(13);\n9: System.out.println(x.poll() + \" \" + x.poll());",
      "responses": [{
        "code": "A",
        "value": "13 5"
      }, {
        "code": "B",
        "value": "13 18"
      }, {
        "code": "C",
        "value": "18 5"
      }, {
        "code": "D",
        "value": "18 13"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles, but prints something else."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "21. B. Note that LinkedList is a Deque, or double‐ended queue. This lets us\nadd elements at both ends. The offer() method adds an element to the\nback of the queue. After line 7 completes, the queue contains 18 and 5 in\nthat order. The push() method adds an element to the front of the queue.\nHow rude! The element 13 pushes past everyone on the line. After line 8\ncompletes, the queue now contains 13, 18, and 5, in that order. Then we get\nthe first two elements from the front, which are 13 and 18, making option B\ncorrect."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Suppose we want to store JellyBean objects. Which of the following\nrequire JellyBean to implement the Comparable interface or create a\nComparator to add them to the collection? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "ArrayList"
      }, {
        "code": "B",
        "value": "HashMap"
      }, {
        "code": "C",
        "value": "HashSet"
      }, {
        "code": "D",
        "value": "SortedArray"
      }, {
        "code": "E",
        "value": "TreeMap"
      }, {
        "code": "F",
        "value": "TreeSet"
      }
      ],
      "answer": {
        "codes": [
          "E",
          "F"
        ],
        "explanation": "22. E,F. TreeMap and TreeSet keep track of sort order when you insert\nelements. TreeMap sorts the keys and TreeSet sorts the objects in the set.\nThis makes options E and F correct. Note that you have the option of\nhaving JellyBean implement Comparable, or you can pass a Comparator to\nthe constructor of TreeMap or TreeSet. Option D is trying to trick you as\nSortedArray is not a class or interface in the collections framework."
      }
    },
    "23": {
      "nbr": 23,
      "value": "Which of the following references the first and last elements in a nonempty\narray?",
      "responses": [{
        "code": "A",
        "value": "trains[0] and trains[trains.length]"
      }, {
        "code": "B",
        "value": "trains[0] and trains[trains.length ‐ 1]"
      }, {
        "code": "C",
        "value": "trains[1] and trains[trains.length]"
      }, {
        "code": "D",
        "value": "trains[1] and trains[trains.length ‐ 1]"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "23. B. Array indices start with 0, making options C and D incorrect. The\nlength attribute refers to the number of elements in an array. It is one past\nthe last valid array index. Therefore, option B is correct."
      }
    },
    "24": {
      "nbr": 24,
      "value": "Which of the following fills in the blank so this code compiles?\npublic static void throwOne(Collection<__________> coll) {\nvar iter = coll.iterator();\nif (iter.hasNext())\nthrow iter.next();\n}",
      "responses": [{
        "code": "A",
        "value": "?"
      }, {
        "code": "B",
        "value": "? extends RuntimeException"
      }, {
        "code": "C",
        "value": "? super RuntimeException"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "24. B. Since the method does not have any declared exceptions, it can only\nthrow unchecked exceptions. Option B is the only one that requires the\nelements of coll to be RuntimeException or any subclasses."
      }
    },
    "25": {
      "nbr": 25,
      "value": "Which of these four array declarations produces a different array than the\nothers?",
      "responses": [{
        "code": "A",
        "value": "int[][] nums = new int[2][1];"
      }, {
        "code": "B",
        "value": "int[] nums[] = new int[2][1];"
      }, {
        "code": "C",
        "value": "int[] nums[] = new int[][] { { 0 }, { 0 } };"
      }, {
        "code": "D",
        "value": "int[] nums[] = new int[][] { { 0, 0 } };"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "25. D. Options A and B show that the brackets, [], can be before or after the\nvariable name and produce the same array. Option C specifies the same\narray the long way with two arrays of length 1. Option D is the answer\nbecause it is different than the others. It instead specifies an array of length\n1 where that element is of length 2."
      }
    },
    "26": {
      "nbr": 26,
      "value": "What does the following output?\nvar linux = new String[] { \"Linux\", \"Mac\", \"Windows\" };\nvar mac = new String[] { \"Mac\", \"Linux\", \"Windows\" };\nvar search = Arrays.binarySearch(linux, \"Linux\");\nvar mismatch1 = Arrays.mismatch(linux, mac);\nvar mismatch2 = Arrays.mismatch(mac, mac);\nSystem.out.println(search + \" \" + mismatch1 + \" \" +\nmismatch2);",
      "responses": [{
        "code": "A",
        "value": "‐1 0 ‐1"
      }, {
        "code": "B",
        "value": "‐1 ‐1 0"
      }, {
        "code": "C",
        "value": "0 ‐1 0"
      }, {
        "code": "D",
        "value": "0 0 ‐1"
      }, {
        "code": "E",
        "value": "The output is not defined."
      }, {
        "code": "F",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "26. D. Java requires having a sorted array before calling the binarySearch()\nmethod. You do not have to call Arrays.sort to perform the sort, though.\nThis array happens to already be sorted, so it meets the precondition. The\ntarget string of \"Linux\" is the first element in the array. Since Java uses\nzero‐based indexing, search is 0. The Arrays.mismatch() method returns\n‐1 if the arrays are the same and returns the index of the first difference if\nthey are not. In our cases, mismatch1 is 0 because the first element differs,\nand mismatch2 is ‐1 because the arrays are the same. This makes option D\nthe correct answer."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Which line in the main() method doesn't compile or points to a class that\ndoesn't compile?\n1: interface Comic<C> {\n2: void draw(C c);\n3: }\n4: class ComicClass<C> implements Comic<C> {\n5: public void draw(C c) {\n6: System.out.println(c);\n7: }\n8: }\n9: class SnoopyClass implements Comic<Snoopy> {\n10: public void draw(Snoopy c) {\n11: System.out.println(c);\n12: }\n13: }\n14: class SnoopyComic implements Comic<Snoopy> {\n15: public void draw(C c) {\n16: System.out.println(c);\n17: }\n18: }\n19: public class Snoopy {\n20: public static void main(String[] args) {\n21: Comic<Snoopy> c1 = c -> System.out.println(c);\n22: Comic<Snoopy> c2 = new ComicClass<>();\n23: Comic<Snoopy> c3 = new SnoopyClass();\n24: Comic<Snoopy> c4 = new SnoopyComic();\n25: }\n26: }",
      "responses": [{
        "code": "A",
        "value": "Line 21."
      }, {
        "code": "B",
        "value": "Line 22."
      }, {
        "code": "C",
        "value": "Line 23."
      }, {
        "code": "D",
        "value": "Line 24."
      }, {
        "code": "E",
        "value": "None of the above. All of the code compiles."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "27. D. The Comic<C> interface declares a formal type parameter. This means\nthat a class implementing it needs to specify this type. The code on line 21\ncompiles because the lambda reference supplies the necessary context\nmaking option A incorrect. Option B declares a generic class. While this\ndoesn't tell us the type is Snoopy, it punts the problem to the caller of the\nclass. The declaration of c2 on line 22 compiles because it supplies the\ntype, making option B incorrect. The code on line 23 compiles because the\nSnoopyClass itself supplies the type, making option C incorrect.\nOption D has a problem. SnoopyClass and SnoopyComic appear similar.\nHowever, SnoopyComic refers to C. This type parameter exists in the\ninterface. It isn't available in the class because the class has said it is using\nSnoopy as the type. Since the SnoopyComic class itself doesn't compile, the\nline with c4 can't instantiate it, and option D is the answer."
      }
    },
    "28": {
      "nbr": 28,
      "value": "Fill in the blank to make this code compile:\npublic class Truck implements Comparable<Truck> {\nprivate int id;\npublic Truck(int id) {\nthis.id = id;\n}\n@Override\npublic int _____________________ {\nreturn id - t.id;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "compare(Truck t)"
      }, {
        "code": "B",
        "value": "compare(Truck t1, Truck t2)"
      }, {
        "code": "C",
        "value": "compareTo(Truck t)"
      }, {
        "code": "D",
        "value": "compareTo(Truck t1, Truck t2)"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "28. C. When implementing Comparable<Truck>, you implement the\ncompareTo() method. Since this is an instance method, it already has a\nreference to itself and only needs the item it is comparing. Only one\nparameter is specified, and option C is correct. By contrast, the\nComparator<Truck> interface uses the compare() method, and the method\ntakes two parameters."
      }
    },
    "29": {
      "nbr": 29,
      "value": "How many lines does the following code output?\nvar days = new String[] { \"Sunday\", \"Monday\", \"Tuesday\",\n\"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };\nfor (int i = 0; i < days.length; i++)\nSystem.out.println(days[i]);",
      "responses": [{
        "code": "A",
        "value": "Six."
      }, {
        "code": "B",
        "value": "Seven."
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "29. B. There is nothing wrong or tricky about this code. It correctly creates a\nseven‐element array. The loop starts with index 0 and ends with index 6.\nEach line is correctly output. Therefore, option B is correct."
      }
    },
    "30": {
      "nbr": 30,
      "value": "Which of the following fill in the blank to print out true? (Choose two.)\nString[] array = {\"Natural History\", \"Science\"};\nvar museums = _______________________;\nmuseums.set(0, \"Art\");\nSystem.out.println(museums.contains(\"Art\"));",
      "responses": [{
        "code": "A",
        "value": "Arrays.asList(array)"
      }, {
        "code": "B",
        "value": "Arrays.asList(\"Natural History, Science\")"
      }, {
        "code": "C",
        "value": "List.of(array)"
      }, {
        "code": "D",
        "value": "List.of(\"Natural History\", \"Science\")"
      }, {
        "code": "E",
        "value": "new ArrayList<String>(\"Natural History\", \"Science\")"
      }, {
        "code": "F",
        "value": "new List<String>(\"Natural History\", \"Science\")"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B"
        ],
        "explanation": "30. A,B. Options E and F are incorrect because they do not compile. List is\nan interface and does not have a constructor. ArrayList has a constructor\nbut not one that takes individual elements as parameters. Options C and D\nare incorrect because List.of() creates an immutable list. Trying to\nchange one of its values causes an exception at runtime.\nOptions A and B are correct. Since we are creating the list from an array, it\nis a fixed size. We are allowed to change elements. When successfully\ncompleting this code, museums is [Art, Science] for both solutions."
      }
    },
    "31": {
      "nbr": 31,
      "value": "Which option cannot fill in the blank to print Clean socks?\nclass Wash<T> {\nT item;\npublic void clean(T item) {\nSystem.out.println(\"Clean \" + item);\n}\n}\npublic class LaundryTime {\npublic static void main(String[] args) {\n______________________\nwash.clean(\"socks\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "var wash = new Wash<String>();"
      }, {
        "code": "B",
        "value": "var wash = new Wash<>();"
      }, {
        "code": "C",
        "value": "Wash wash = new Wash();"
      }, {
        "code": "D",
        "value": "Wash wash = new Wash<String>();"
      }, {
        "code": "E",
        "value": "Wash<String> wash = new Wash<>();"
      }, {
        "code": "F",
        "value": "All of these can fill in the blank."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "31. F. The Wash class takes a formal type parameter named T. Options A and E\nshow the best ways to call it. These option declare a generic reference type\nthat specifies the type is String. Option A uses local variable type\ninference, whereas option E uses the diamond syntax to avoid redundantly\nspecifying the type of the assignment.\nOptions B, C, and D show that you can omit the generic type in the\nreference and still have the code compile. You do get a compiler warning\nscolding you for having a raw type. But compiler warnings do not prevent\ncompilation. With the raw type, the compiler treats T as if it is of type\nObject. That is OK in this example, because the only method we call is\ntoString() implicitly when printing the value. Since toString() is\ndefined on the Object class, we are safe, and options B, C, and D work.\nSince all can fill in the blank, option F is the answer."
      }
    },
    "32": {
      "nbr": 32,
      "value": "Which of the options in the graphic best represent the blocks variable?\nchar[][] blocks = new char[][] {\n{ 'a', 'b', 'c' }, { 'd' }, { 'e', 'f' } };",
      "responses": [{
        "code": "A",
        "value": "Option A"
      }, {
        "code": "B",
        "value": "Option B"
      }, {
        "code": "C",
        "value": "Option C"
      }, {
        "code": "D",
        "value": "Option D"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "32. B. Options A, C, and D represent 3×3 2D arrays. Option B best represents\nthe array in the code. It shows there are three different arrays of different\nlengths."
      }
    },
    "33": {
      "nbr": 33,
      "value": "Fill in the blank so the code prints gamma. (Choose two.)\nvar list = Arrays.asList(\"alpha\", \"beta\", \"gamma\");\nCollections.sort(list, _______________);\nSystem.out.println(list.get(0));",
      "responses": [{
        "code": "A",
        "value": "(s, t) ‐> s.compareTo(t)"
      }, {
        "code": "B",
        "value": "(s, t) ‐> t.compareTo(s)"
      }, {
        "code": "C",
        "value": "Comparator.comparing((String s) ‐> s.charAt(0))"
      }, {
        "code": "D",
        "value": "Comparator.comparing((String s) ‐> s.charAt(0)).reverse()"
      }, {
        "code": "E",
        "value": "Comparator.comparing((String s) ‐> s.charAt(0)).reversed()"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "33. B,E. The goal is to write code that sorts in descending order. Option A\nsorts ascendingly and option B sorts descendingly. Similarly, option C sorts\nascendingly and option E sorts descendingly. Option D attempts to call the\nreverse() method, which is not defined."
      }
    },
    "34": {
      "nbr": 34,
      "value": "How many of the following are legal declarations?\nfloat[] lion = new float[];\nfloat[] tiger = new float[1];\nfloat[] bear = new[] float;\nfloat[] ohMy = new[1] float;",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "34. B. When creating an array object, a set of elements or size is required.\nTherefore, lion and bear are incorrect. The brackets containing the size are\nrequired to be after the type, making ohMy incorrect. The only one that is\ncorrect is tiger, making the correct answer option B."
      }
    },
    "35": {
      "nbr": 35,
      "value": "Which is the first line of code that causes an\nArrayIndexOutOfBoundsException?\nvar matrix = new String[1][2];\nmatrix[0][0] = \"Don't think you are, know you are.\";\n// m1\nmatrix[0][1] = \"I'm trying to free your mind Neo\";\n// m2\nmatrix[1][0] = \"Is all around you \";\n// m3\nmatrix[1][1] = \"Why oh why didn't I take the BLUE pill?\";\n// m4",
      "responses": [{
        "code": "A",
        "value": "m1"
      }, {
        "code": "B",
        "value": "m2"
      }, {
        "code": "C",
        "value": "m3"
      }, {
        "code": "D",
        "value": "m4"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "35. C. This code creates a two‐dimensional array of size 1×2. Lines m1 and m2\nassign values to both elements in the outer array. Line m3 attempts to\nreference the second element of the outer array. Since there is no such\nposition, it throws an exception, and option C is correct."
      }
    },
    "36": {
      "nbr": 36,
      "value": "Suppose we have list of type List<Integer>. Which method allows you\nto pass a List and returns an immutable Set containing the same elements?",
      "responses": [{
        "code": "A",
        "value": "List.copyOf(list)"
      }, {
        "code": "B",
        "value": "List.of(list)"
      }, {
        "code": "C",
        "value": "Set.copyOf(list);"
      }, {
        "code": "D",
        "value": "Set.of(list);"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "36. C. All four of these return immutable collections. Options B and D take a\nvarargs rather than a List. Option A returns a List, not a Set. Option C\nmeets both our requirements."
      }
    },
    "37": {
      "nbr": 37,
      "value": "What does the following output? (Choose two.)\nvar os = new String[] { \"Mac\", \"Linux\", \"Windows\" };\nArrays.sort(os);\nSystem.out.println(Arrays.binarySearch(os, \"RedHat\"));\nSystem.out.println(Arrays.binarySearch(os, \"Mac\"));",
      "responses": [{
        "code": "A",
        "value": "‐1"
      }, {
        "code": "B",
        "value": "‐2"
      }, {
        "code": "C",
        "value": "‐3"
      }, {
        "code": "D",
        "value": "0"
      }, {
        "code": "E",
        "value": "1"
      }, {
        "code": "F",
        "value": "2"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "37. C,E. The code sorts before calling the binarySearch() method, so it\nmeets the precondition for that method. The target string of \"RedHat\" is not\nfound in the sorted array. If it were found, it would be between the second\nand third elements. The rule is to take the negative index of where it would\nbe inserted and subtract 1. It would need to be inserted as the third element.\nSince indexes are zero‐based, this is index 2. We take the negative, which is\n‐2, and subtract 1, giving ‐3.\nThe target string of \"Mac\" is the second element in the sorted array. Since\narray indices begin with zero, the second position is index 1. This makes\nthe answer options C and E."
      }
    },
    "38": {
      "nbr": 38,
      "value": "What does the following output?\nvar names = new HashMap<String, String>();\nnames.put(\"peter\", \"pan\");\nnames.put(\"wendy\", \"darling\");\nvar first = names.entrySet(); // line x1\nSystem.out.println(first.getKey()); // line x2",
      "responses": [{
        "code": "A",
        "value": "peter"
      }, {
        "code": "B",
        "value": "wendy"
      }, {
        "code": "C",
        "value": "Does not compile due to line x1"
      }, {
        "code": "D",
        "value": "Does not compile due to line x2"
      }, {
        "code": "E",
        "value": "Does not compile due to another reason"
      }, {
        "code": "F",
        "value": "Throws an exception at runtime"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "38. D. Line x1 returns a Set of map entries. Set does not have a getKey()\nmethod, so line x2 does not compile, and option D is the answer."
      }
    },
    "39": {
      "nbr": 39,
      "value": "Which of these elements are in the output of the following? (Choose three.)\nvar q = new ArrayDeque<String>();\nq.offerFirst(\"snowball\");\nq.offer(\"sugar\");\nq.offerLast(\"minnie\");\nSystem.out.println(q.poll());\nSystem.out.println(q.removeFirst());\nSystem.out.println(q.size());",
      "responses": [{
        "code": "A",
        "value": "sugar"
      }, {
        "code": "B",
        "value": "minnie"
      }, {
        "code": "C",
        "value": "snowball"
      }, {
        "code": "D",
        "value": "1"
      }, {
        "code": "E",
        "value": "2"
      }, {
        "code": "F",
        "value": "3"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "D"
        ],
        "explanation": "39. A,C,D. The offerLast() and offer() methods insert an element at the\nback of the queue, while the offerFirst() method inserts the element at\nthe front of the queue. This means the queue initially contains [snowball,\nsugar, minnie]. The poll() method returns the element at the front of the\nqueue and removes it. In this case, it prints snowball, and the queue is\nreduced from three elements to [sugar, minnie]. Then, the\nremoveFirst() method removes sugar, leaving the queue as only\ncontaining [minnie]. Further, the queue becomes one smaller, and 1 is\nprinted. These are options A, C, and D."
      }
    },
    "40": {
      "nbr": 40,
      "value": "Which of these four pairs of declarations can point to an array that is\ndifferent from the others?",
      "responses": [{
        "code": "A",
        "value": "int[][][][] nums1a, nums1b;"
      }, {
        "code": "B",
        "value": "int[][][] nums2a[], nums2b;"
      }, {
        "code": "C",
        "value": "int[][] nums3a[][], nums3b[][];"
      }, {
        "code": "D",
        "value": "int[] nums4a[][][], numbs4b[][][];"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "40. B. All of the variables except nums2b point to a 4D array. Don't create a\n4D array in practice; it's confusing. The options show that the brackets, [],\ncan be before or after the variable in any combination. Option B is the\nanswer because nums2b points to a 3D array. It has only three pairs of\nbrackets before the variable and none after. By comparison, nums2a has\nthree pairs of brackets before the variable and the fourth pair of brackets\nafter."
      }
    },
    "41": {
      "nbr": 41,
      "value": "Which of the following does not behave the same way as the others?",
      "responses": [{
        "code": "A",
        "value": "var set = new HashSet<>();"
      }, {
        "code": "B",
        "value": "var set = new HashSet<Object>();"
      }, {
        "code": "C",
        "value": "HashSet<> set = new HashSet<Object>();"
      }, {
        "code": "D",
        "value": "HashSet<Object> set = new HashSet<>();"
      }, {
        "code": "E",
        "value": "HashSet<Object> set = new HashSet<Object>();"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "41. C. Option E is the longest way to specify this code. Options A and D\nshorten it by using the diamond operator (<>). Options A and B shorten it\nusing var. Option C does not compile because the diamond operator cannot\nbe used on the left side of the assignment."
      }
    },
    "42": {
      "nbr": 42,
      "value": "What is true about the output of the following code?\nvar ints = new int[] {3,1,4};\nvar others = new int[] {2,7,1,8};\nSystem.out.println(Arrays.compare(ints, others));",
      "responses": [{
        "code": "A",
        "value": "It is negative because ints has fewer elements."
      }, {
        "code": "B",
        "value": "It is 0 because the arrays can't be compared."
      }, {
        "code": "C",
        "value": "It is positive because the first element is larger."
      }, {
        "code": "D",
        "value": "It is undefined."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "42. C. The Arrays.compare() method looks at each element in turn. Since the\nfirst elements are different, we get the result of comparing them. In this\ncase, we get a positive number because 3 is larger than 2, and option C is\ncorrect."
      }
    },
    "43": {
      "nbr": 43,
      "value": "Fill in the blank so the code prints beta.\nvar list = List.of(\"alpha\", \"beta\", \"gamma\");\nCollections.sort(list, _______________);\nSystem.out.println(list.get(0));",
      "responses": [{
        "code": "A",
        "value": "(s, t) ‐> s.compareTo(t)"
      }, {
        "code": "B",
        "value": "(s, t) ‐> t.compareTo(s)"
      }, {
        "code": "C",
        "value": "Comparator.comparing(String::length)"
      }, {
        "code": "D",
        "value": "Comparator.comparing(String::length).reversed()"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "43. E. List.of() makes an immutable list. Attempting to sort throws an\nexception so option E is the answer. If we were calling, Arrays.asList()\ninstead, option C would be the answer because it is the only option to sort\nascendingly by length."
      }
    },
    "44": {
      "nbr": 44,
      "value": "How many of these lines have a compiler error?\n20: var list = List.of('a', 'c', 'e');\n21: Char letter1 = list.get(0);\n22: char letter2 = list.get(0);\n23: int letter3 = list.get(0);\n24: Integer letter4 = list.get(0);\n25: Object letter5 = list.get(0);",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }, {
        "code": "F",
        "value": "5"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "44. C. Line 20 creates a List<Character>. Line 21 does not compile because\nit is the wrong type. Char should be Character. Line 22 uses unboxing to\nget a primitive. Line 23 also compiles because Character can be unboxed\nand widened to int automatically. However, line 24 does not compile as\nInteger and Character are not in the same class hierarchy. The Character\nvalue cannot be unboxed, widened to int, and then autoboxed as Integer.\nFinally, line 25 is correct as Character is a subclass of Object. Since two\nlines of code fail to compile, option C is the answer."
      }
    },
    "45": {
      "nbr": 45,
      "value": "How many dimensions does the array reference moreBools allow?\nboolean[][] bools[], moreBools;",
      "responses": [{
        "code": "A",
        "value": "One dimension"
      }, {
        "code": "B",
        "value": "Two dimensions"
      }, {
        "code": "C",
        "value": "Three dimensions"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "45. B. This one is tricky since the array brackets, [], are split up. This means\nthat bools is a 3D array reference. The brackets both before and after the\nvariable name count. For moreBools, it is only a 2D array reference because\nthere are only two pairs of brackets next to the type. In other words,\nboolean[][] applies to both variables. Then bools gets another dimension\nfrom the brackets right after the variable name. However, moreBools stays\nat 2D, making option B correct."
      }
    },
    "46": {
      "nbr": 46,
      "value": "What is the result of the following?\nComparator<Integer> c = (x, y) -> y - x;var ints =\nArrays.asList(3, 1, 4);Collections.sort(ints,\nc);System.out.println(Collections.binarySearch(ints, 1));",
      "responses": [{
        "code": "A",
        "value": "‐1"
      }, {
        "code": "B",
        "value": "0"
      }, {
        "code": "C",
        "value": "‐1"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The result is not defined."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "46. E. A custom sort order is specified using a Comparator to sort in\ndescending order. However, this Comparator is not passed when searching.\nWhen a different sort order is used for searching and sorting, the result is\nundefined. Therefore, option E is correct."
      }
    },
    "47": {
      "nbr": 47,
      "value": "Which statement most accurately represents the relationship between\nsearching and sorting with respect to the Arrays class?",
      "responses": [{
        "code": "A",
        "value": "If the array is not sorted, calling Arrays.binarySearch() will be\naccurate, but slower than if it were sorted."
      }, {
        "code": "B",
        "value": "The array does not need to be sorted before calling\nArrays.binarySearch() to get an accurate result."
      }, {
        "code": "C",
        "value": "The array must be sorted before calling Arrays.binarySearch() to\nget an accurate result."
      }, {
        "code": "D",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "47. C. The binarySearch() method requires a sorted array in order to return a\ncorrect result. If the array is not sorted, the results of a binary search are\nundefined."
      }
    },
    "48": {
      "nbr": 48,
      "value": "Which statement is true about the following figure while ensuring the code\ncontinues to compile? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "<> can be inserted at positions P and R without making any other\nchanges."
      }, {
        "code": "B",
        "value": "<> can be inserted at positions Q and S without making any other\nchanges."
      }, {
        "code": "C",
        "value": "<> can be inserted at all four positions."
      }, {
        "code": "D",
        "value": "Both variables point to an ArrayList<String>."
      }, {
        "code": "E",
        "value": "Only one variable points to an ArrayList<String>."
      }, {
        "code": "F",
        "value": "Neither variable points to an ArrayList<String>."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "48. B,F. The <> is known as the diamond operator. Here, it works as a shortcut\nto avoid repeating the generic type twice for the same declaration. On the\nright side of the expression, this is a handy shortcut. Java still needs the\ntype on the left side, so there is something to infer. Positions Q and S are on\nthe right side, making option B correct. In this question, the generic type is\nnever specified, so it is Object. Since it is not String, option F is correct."
      }
    },
    "49": {
      "nbr": 49,
      "value": "What is the result of the following when called as java Binary.java?\n(Choose two.)\n1: import java.util.*;\n2: public class Binary {\n3:\n4: public static void main(String… args) {\n5: Arrays.sort(args);\n6: System.out.println(Arrays.toString(args));\n7: System.out.println(args[0]);\n8: } }",
      "responses": [{
        "code": "A",
        "value": "null"
      }, {
        "code": "B",
        "value": "[]"
      }, {
        "code": "C",
        "value": "Binary"
      }, {
        "code": "D",
        "value": "The code throws an ArrayIndexOutOfBoundsException."
      }, {
        "code": "E",
        "value": "The code throws a NullPointerException."
      }, {
        "code": "F",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "49. B,D. Since no arguments are passed from the command line, this creates\nan empty array. Sorting an empty array is valid and results in an empty\narray printed on line 6. Then line 7 attempts to access an element of the\nempty array and throws an ArrayIndexOutOfBoundsException. Therefore,\noptions B and D are correct."
      }
    },
    "50": {
      "nbr": 50,
      "value": "What is the first line with a compiler error?\nclass Mammal {}\nclass Bat extends Mammal {}\nclass Cat extends Mammal {}\nclass Sat {}\nclass Fur<? extends Mammal> { // line R\nvoid clean() {\nvar bat = new Fur<Bat>(); // line S\nvar cat = new Fur<Cat>(); // line T\nvar sat = new Fur<Sat>(); // line U\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Line R"
      }, {
        "code": "B",
        "value": "Line S"
      }, {
        "code": "C",
        "value": "Line T"
      }, {
        "code": "D",
        "value": "Line U"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "50. A. The generic declaration on line R is not valid due to the question mark\n(?) wildcard. While a question mark is allowed on the left side of a\ndeclaration, it is not allowed when specifying a constraint on a class. Since\nline R does not compile, option A is the answer."
      }
    },
    "51": {
      "nbr": 51,
      "value": "What is the result of running the following program?\n1: package fun;\n2: public class Sudoku {\n3: static int[][] game = new int[6][6];\n4:\n5: public static void main(String[] args) {\n6: game[3][3] = 6;\n7: Object[] obj = game;\n8: obj[3] = \"X\";\n9: System.out.println(game[3][3]);\n10: }\n11: }",
      "responses": [{
        "code": "A",
        "value": "6"
      }, {
        "code": "B",
        "value": "X"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws a NullPointerException at runtime."
      }, {
        "code": "E",
        "value": "The code compiles but throws a different exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "51. E. Line 6 assigns an int to a cell in a 2D array. This is fine. Line 7 casts to\na general Object[]. This is dangerous, but legal. Why is it dangerous, you\nask? That brings us to line 8. The compiler can't protect us from assigning a\nString to the int[] because the reference is more generic. Therefore, line 8\nthrows an ArrayStoreException because the type is incorrect, and option E\nis correct. You couldn't have assigned an int on line 8 either because\nobj[3] is really an int[] behind the scenes and not an int."
      }
    },
    "52": {
      "nbr": 52,
      "value": "How many of these allow inserting null values: ArrayList, LinkedList,\nHashSet, and TreeSet?",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "52. D. TreeSet does not allow null values because it needs to compare the\nvalues. While HashSet does call hashCode(), it knows to skip that call if\nthe value is null. ArrayList and LinkedList do not make method calls on\ntheir contents. Three of the four allow inserting null values, making option\nD the answer."
      }
    },
    "53": {
      "nbr": 53,
      "value": "What is the output of the following?\nvar threes = Arrays.asList(\"3\", \"three\", \"THREE\");\nCollections.sort(threes);\nSystem.out.println(threes);",
      "responses": [{
        "code": "A",
        "value": "[3, three, THREE]"
      }, {
        "code": "B",
        "value": "[3, THREE, three]"
      }, {
        "code": "C",
        "value": "[three, THREE, 3]"
      }, {
        "code": "D",
        "value": "[THREE, three, 3]"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "53. B. Unfortunately, you do have to memorize two facts about sort order.\nFirst, numbers sort before letters. Second, uppercase sorts before lowercase.\nSince, the first value is 3 and the last is three, option B is correct."
      }
    },
    "54": {
      "nbr": 54,
      "value": "How many dimensions does the array reference moreBools allow?\nboolean[][][] bools, moreBools;",
      "responses": [{
        "code": "A",
        "value": "One dimension"
      }, {
        "code": "B",
        "value": "Two dimensions"
      }, {
        "code": "C",
        "value": "Three dimensions"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "54. C. Since the brackets in the declaration are before the variable names, the\nvariable type boolean[][][] applies to both variables. Therefore, both\nbools and moreBools can reference a 3D array."
      }
    },
    "55": {
      "nbr": 55,
      "value": "What is the output of the following?\n20: List<Character> chars = new ArrayList<>();\n21: chars.add('a');\n22: chars.add('b');\n23: chars.clear();\n24: chars.remove(0);\n25: System.out.print(chars.isEmpty() + \" \" +\nchars.length());",
      "responses": [{
        "code": "A",
        "value": "false 0"
      }, {
        "code": "B",
        "value": "true 1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "55. D. Line 25 does not compile, making option D the answer. On an\nArrayList, the method to get the number of elements is size(). The\nlength() method is used for a String or StringBuilder. If this were fixed,\nthe answer would be option E. Line 23 empties the ArrayList. Then line 24\nattempts to access an index that is not present."
      }
    },
    "56": {
      "nbr": 56,
      "value": "Which fills in the blank in the method signature to allow this code to\ncompile?\nimport java.util.*;\npublic class ExtendingGenerics {\nprivate static < ___________, U> U add(T list, U\nelement) {\nlist.add(element);\nreturn element;\n}\npublic static void main(String[] args) {\nvar values = new ArrayList<String>();\nadd(values, \"duck\");\nadd(values, \"duck\");\nadd(values, \"goose\");\nSystem.out.println(values);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "? extends Collection<U>"
      }, {
        "code": "B",
        "value": "? implements Collection<U>"
      }, {
        "code": "C",
        "value": "T extends Collection<U>"
      }, {
        "code": "D",
        "value": "T implements Collection<U>"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "56. C. The ? is an unbounded wildcard. It is used in variable references but is\nnot allowed in declarations. In a static method, the type parameter\nspecified inside the <> is used in the rest of the method declaration. Since it\nneeds an actual name, options A and B are incorrect. We need to specify a\ntype constraint so we can call the add() method. Regardless of whether the\ntype is a class or interface, Java uses the extends keyword for generics.\nTherefore, option D is incorrect, and option C is the answer."
      }
    },
    "57": {
      "nbr": 57,
      "value": "What does the following output?\nString[] os = new String[] { \"Mac\", \"Linux\", \"Windows\" };\nSystem.out.println(Arrays.binarySearch(os, \"Linux\"));",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "The output is not defined."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "57. D. Java requires having a sorted array before calling the binarySearch()\nmethod. Since the array is not sorted, the result is undefined, and option D\nis correct. It may happen that you get 1 as the result, but this behavior is not\nguaranteed. You need to know for the exam that this is undefined even if\nyou happen to get the “right” answer."
      }
    },
    "58": {
      "nbr": 58,
      "value": "Which is the first line to prevent this code from compiling and running\nwithout error?\nchar[][] ticTacToe = new char[3,3]; // r1\nticTacToe[1][3] = 'X'; // r2\nticTacToe[2][2] = 'X';\nticTacToe[3][1] = 'X';\nSystem.out.println(ticTacToe.length + \" in a row!\"); // r3",
      "responses": [{
        "code": "A",
        "value": "Line r1"
      }, {
        "code": "B",
        "value": "Line r2"
      }, {
        "code": "C",
        "value": "Line r3"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "58. A. A multidimensional array is created with multiple sets of size\nparameters. The first line should be char[] ticTacToe = new char[3]\n[3];. Therefore, option A is the answer."
      }
    },
    "59": {
      "nbr": 59,
      "value": "What is the result of the following?\nvar list = new ArrayList<String>();\nlist.add(\"Austin\");\nlist.add(\"Boston\");\nlist.add(\"San Francisco\");\nlist.removeIf(a -> a.length()> 10);\nSystem.out.println(list.size());",
      "responses": [{
        "code": "A",
        "value": "1"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "3"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "59. B. On a stream, the filter() method only keeps values matching the\nlambda. The removeIf() does the reverse on a Collection and keeps the\nelements that do not match. In this case, that is Austin and Boston, so\noption B is correct."
      }
    },
    "60": {
      "nbr": 60,
      "value": "What happens when calling the following method with a non‐null and nonempty\narray?\npublic static void addStationName(String[] names) {\nnames[names.length] = \"Times Square\";\n}",
      "responses": [{
        "code": "A",
        "value": "It adds an element to the array the value of which is Times Square."
      }, {
        "code": "B",
        "value": "It replaces the last element in the array with the value Times Square."
      }, {
        "code": "C",
        "value": "It does not compile."
      }, {
        "code": "D",
        "value": "It throws an exception."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "60. D. The names.length value is the number of elements in the array. The\nlast valid index in the array is one less than names.length. In Java, arrays\ndo not resize automatically. Therefore, the code throws an\nArrayIndexOutOfBoundsException, and option D is correct."
      }
    },
    "61": {
      "nbr": 61,
      "value": "Which is not a true statement about an array?",
      "responses": [{
        "code": "A",
        "value": "An array expands automatically when it is full."
      }, {
        "code": "B",
        "value": "An array is allowed to contain duplicate values."
      }, {
        "code": "C",
        "value": "An array understands the concept of ordered elements."
      }, {
        "code": "D",
        "value": "An array uses a zero index to reference the first element."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "61. A. An ArrayList expands automatically when it is full. An array does not,\nmaking option A the answer. The other three statements are true of both an\narray and an ArrayList."
      }
    },
    "62": {
      "nbr": 62,
      "value": "Which of the following cannot fill in the blank to make the code compile?\nprivate void output(____________<?> x) {\nx.forEach(System.out::println);\n}",
      "responses": [{
        "code": "A",
        "value": "Collection"
      }, {
        "code": "B",
        "value": "LinkedList"
      }, {
        "code": "C",
        "value": "TreeMap"
      }, {
        "code": "D",
        "value": "None of these can fill in the blank."
      }, {
        "code": "E",
        "value": "All of these can fill in the blank."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "62. C. The forEach() method that takes one parameter is defined on the\nCollection interface allowing options A and B to fill in the blank. Option\nC requires you to notice that only one generic parameter is passed. A Map\nneeds two parameters, so option C is the answer."
      }
    },
    "63": {
      "nbr": 63,
      "value": "Which of the following fills in the blank so this code compiles?\npublic static void getExceptions(Collection<____________>\ncoll) {\ncoll.add(new RuntimeException());\ncoll.add(new Exception());\n}",
      "responses": [{
        "code": "A",
        "value": "?"
      }, {
        "code": "B",
        "value": "? extends RuntimeException"
      }, {
        "code": "C",
        "value": "? super RuntimeException"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "63. D. Option A is incorrect because coll could be any type, which doesn't\nnecessarily allow exceptions to be added. Option B is incorrect because\nneither add() method compiles. We could have\nCollection<IllegalStateException> as a parameter. That would not\nallow either type to be added. Finally, option C is incorrect as the second\nadd() method does not compile because broader types than the generic\nallows are a problem when adding to coll. Therefore, option D is the\nanswer."
      }
    },
    "64": {
      "nbr": 64,
      "value": "What is the output of the following? (Choose two.)\n35: var mags = new HashMap<String, Integer>();\n36: mags.put(\"People\", 1974);\n37: mags.put(\"Readers Digest\", 1922);\n38: mags.put(\"The Economist\", 1843);\n39:\n40: Collection<Integer> years = mags.values();\n41:\n42: List<Integer> sorted = new ArrayList<>(years);\n43: Collections.sort(sorted);\n44:\n45: int first = sorted.get(0);\n46: System.out.println(first);\n47:\n48: Integer last = sorted.get(sorted.size());\n49: System.out.println(last);",
      "responses": [{
        "code": "A",
        "value": "1843"
      }, {
        "code": "B",
        "value": "1922"
      }, {
        "code": "C",
        "value": "1974"
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D"
        ],
        "explanation": "64. A,D. Lines 35–38 create a Map with three key/value pairs. Lines 40–43\nsort just the values ascendingly by year. Lines 45 and 48 show you can\nassign the Integer values to an int via unboxing or an Integer directly.\nLine 46 shows the values are properly sorted, making option A correct.\nFinally, line 48 throws an exception because sorted.size() returns 3 and\nthe maximum index in the List is 2. This makes option D correct as well."
      }
    },
    "65": {
      "nbr": 65,
      "value": "How do you access the array element with the value of \"z\"?",
      "responses": [{
        "code": "A",
        "value": "dimensions[\"three\"][2]"
      }, {
        "code": "B",
        "value": "dimensions[\"three\"][3]"
      }, {
        "code": "C",
        "value": "dimensions[2][2]"
      }, {
        "code": "D",
        "value": "dimensions[3][3]"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "65. C. Arrays are indexed using numbers, not strings, making options A and B\nincorrect. Since array indexes are zero‐based, option C is the answer."
      }
    },
    "66": {
      "nbr": 66,
      "value": "What is the output of the following?\nclass Magazine implements Comparable<Magazine> {\nprivate String name;\npublic Magazine(String name) {\nthis.name = name;\n}\n@Override\npublic int compareTo(Magazine m) {\nreturn name.compareTo(m.name);\n}\n@Override\npublic String toString() {\nreturn name;\n}\n}\npublic class Newsstand {\npublic static void main(String[] args) {\nvar set = new TreeSet<Magazine>();\nset.add(new Magazine(\"highlights\"));\nset.add(new Magazine(\"Newsweek\"));\nset.add(new Magazine(\"highlights\"));\nSystem.out.println(set.iterator().next());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "highlights"
      }, {
        "code": "B",
        "value": "Newsweek"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "66. B. This code shows a proper implementation of Comparable. It has the\ncorrect method signature. It compares the magazine names in alphabetical\norder. Remember that uppercase letters sort before lowercase letters. Since\nNewsweek starts with uppercase, option B is correct."
      }
    },
    "67": {
      "nbr": 67,
      "value": "Which options can fill in the blanks to print Cleaned 2 items?\nimport java.util.*;\nclass Wash<T __________ Collection> {\nT item;\npublic void clean(T items) {\nSystem.out.println(\"Cleaned \" + items.size() + \"\nitems\");\n}\n}\npublic class LaundryTime {\npublic static void main(String[] args) {\nWash<List> wash = new Wash<_______________>();\nwash.clean(List.of(\"sock\", \"tie\"));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "extends, ArrayList"
      }, {
        "code": "B",
        "value": "extends, List"
      }, {
        "code": "C",
        "value": "super, ArrayList"
      }, {
        "code": "D",
        "value": "super, List"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "67. B. Options A and C are incorrect because a generic type cannot be\nassigned to another direct type unless you are using upper or lower bounds\nin that statement. Now, we just have to decide whether a lower or upper\nbound is correct for the T formal type parameter in Wash. The clue is that the\nmethod calls size(). This method is available on Collection, and all\nclasses that extend/implement it. Therefore, option B is correct."
      }
    },
    "68": {
      "nbr": 68,
      "value": "How many lines does the following code output?\nvar days = new String[] { \"Sunday\", \"Monday\", \"Tuesday\",\n\"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" };\nfor (int i = 1; i <= days.length; i++)\nSystem.out.println(days[i]);",
      "responses": [{
        "code": "A",
        "value": "Six."
      }, {
        "code": "B",
        "value": "Seven."
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "68. D. In Java, arrays are indexed starting with 0. While it is unusual for the\nloop to start with 1, this does not cause an error. What does cause an error is\nthe loop ending at data.length, because the <= operator is used instead of\nthe < operator. The last loop index is 6, not 7. On the last iteration of the\nloop, the code throws an ArrayIndexOutOfBoundsException. Therefore,\noption D is correct."
      }
    },
    "69": {
      "nbr": 69,
      "value": "What is the output of the following?\nvar listing = new String[][] {\n{ \"Book\" }, { \"Game\", \"29.99\" } };\nSystem.out.println(listing.length + \" \" +\nlisting[0].length);",
      "responses": [{
        "code": "A",
        "value": "1 2"
      }, {
        "code": "B",
        "value": "2 1"
      }, {
        "code": "C",
        "value": "2 2"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "69. B. This array has two elements, making listing.length output 2. While\neach array element does not have the same size, this does not matter\nbecause we are only looking at the first element. The first element has one.\nThis makes the answer option B."
      }
    },
    "70": {
      "nbr": 70,
      "value": "What is the output of the following?\nQueue<String> q = new ArrayDeque<>();\nq.add(\"snowball\");\nq.addLast(\"sugar\");\nq.addFirst(\"minnie\");\nSystem.out.println(q.peek() + \" \" + q.peek() + \" \" +\nq.size());",
      "responses": [{
        "code": "A",
        "value": "sugar sugar 3"
      }, {
        "code": "B",
        "value": "sugar minnie 1"
      }, {
        "code": "C",
        "value": "minnie minnie 3"
      }, {
        "code": "D",
        "value": "minnie snowball 1"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "70. E. The addFirst() and addLast() methods are on the Deque interface.\nWhile ArrayDeque does implement this interface, it also implements Queue.\nSince the q variable is of type Queue, these methods do not compile, and\noption E is the answer. If the correct interface were used, minnie minnie 3\nwould be printed."
      }
    },
    "71": {
      "nbr": 71,
      "value": "What is the result of the following?\n13: var numbers = Arrays.asList(3, 1, 4);\n14: numbers.set(1, null);\n15: int first = numbers.get(0);\n16: int middle = numbers.get(1);\n17: int last = numbers.get(3);\n18: System.out.println(first + \" \" + middle + \" \" + last);",
      "responses": [{
        "code": "A",
        "value": "The code does not compile."
      }, {
        "code": "B",
        "value": "Line 14 throws an exception."
      }, {
        "code": "C",
        "value": "Line 15 throws an exception."
      }, {
        "code": "D",
        "value": "Line 16 throws an exception."
      }, {
        "code": "E",
        "value": "Line 17 throws an exception."
      }, {
        "code": "F",
        "value": "3null4"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "71. D. The code does compile, making option A incorrect. Line 13 creates a\nfixed‐size list. While we are using var, the type is List<Integer>. Line 14\nsuccessfully changes the contents of the list to [3, null, 4]. Line 15\nautomatically unboxes to the primitive 3. Line 16 has a problem. The list\nhas a null value at index 1. This cannot be unboxed to a primitive and\nthrows a NullPointerException. Therefore, option D is the answer. If line\n16 were commented out, line 17 would have thrown an exception because\nJava uses zero based indexes, and there is no element at index 3."
      }
    },
    "72": {
      "nbr": 72,
      "value": "Fill in the blank so the code prints gamma.\nvar list = Arrays.asList(\"alpha\", \"beta\", \"gamma\");\nCollections.sort(list, ___________________________);\nSystem.out.println(list.get(0));",
      "responses": [{
        "code": "A",
        "value": "Comparator.comparing(String::length)\n.andCompare(s -> s.charAt(0))"
      }, {
        "code": "B",
        "value": "Comparator.comparing(String::length)\n.thenCompare(s -> s.charAt(0))"
      }, {
        "code": "C",
        "value": "Comparator.comparing(String::length)\n.thenComparing(s -> s.charAt(0))"
      }, {
        "code": "D",
        "value": "Comparator.comparing(String::length)\n.andCompare(s -> s.charAt(0))\n.reversed()"
      }, {
        "code": "E",
        "value": "Comparator.comparing(String::length)\n.thenCompare(s -> s.charAt(0))\n.reversed()"
      }, {
        "code": "F",
        "value": "Comparator.comparing(String::length)\n.thenComparing(s -> s.charAt(0))\n.reversed()"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "72. F. We need to first sort descendingly and then ascendingly by first\ncharacter. Options A, B, and C are missing the logic to sort descendingly.\nOptions D and E call the andCompare() and thenCompare() methods,\nwhich do not exist. Option F is correct."
      }
    },
    "73": {
      "nbr": 73,
      "value": "What is the output of the following when run as java FirstName Wolfie?\n(Choose two.)\npublic class FirstName {\npublic static void main(String… names) {\nSystem.out.println(names[0]);\nSystem.out.println(names[1]);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "FirstName"
      }, {
        "code": "B",
        "value": "Wolfie"
      }, {
        "code": "C",
        "value": "The code throws an ArrayIndexOutOfBoundsException."
      }, {
        "code": "D",
        "value": "The code throws a NullPointerException."
      }, {
        "code": "E",
        "value": "The code throws a different exception."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C"
        ],
        "explanation": "73. B,C. Array indexes begin with zero. FirstName is the name of the class,\nnot an argument. The first argument is Wolfie, making option B correct.\nThere is not a second argument, and the array is of size 1, so option C is\nalso correct."
      }
    },
    "74": {
      "nbr": 74,
      "value": "What does the following output?\n11: var pennies = new ArrayList<>();\n12: pennies.add(1);\n13: pennies.add(2);\n14: pennies.add(Integer.valueOf(3));\n15: pennies.add(Integer.valueOf(4));\n16: pennies.remove(2);\n17: pennies.remove(Integer.valueOf(1));\n18: System.out.println(pennies);",
      "responses": [{
        "code": "A",
        "value": "[1, 2]"
      }, {
        "code": "B",
        "value": "[1, 4]"
      }, {
        "code": "C",
        "value": "[2, 4]"
      }, {
        "code": "D",
        "value": "[2, 3]"
      }, {
        "code": "E",
        "value": "[3, 4]"
      }, {
        "code": "F",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "74. C. This one is tricky. Line 11 creates an ArrayList with a generic type\nObject rather than Integer. This is allowed since we aren't trying to assign\nany of the values to an int or Integer after getting them from pennies.\nThis gives us the list [1, 2, 3, 4].\nThe next trick is that there are two remove() methods available on\nArrayList. One removes an element by index and takes an int parameter.\nThe other removes an element by value and takes an Object. On line 16,\nthe int primitive is a better match, and the element with index 2 is\nremoved, which is the value of 3. At this point, we have [1, 2, 4].\nThen on line 17, the other remove() method is called because we are\nexplicitly using the wrapper object. This deletes the object that is equal to 1,\nand now we have [2, 4]. This brings us to option C as the answer."
      }
    },
    "75": {
      "nbr": 75,
      "value": "What is true of the following code? (Choose two.)\nprivate static void sortAndSearch(String… args) {\nvar one = args[1];\nComparator<String> comp = (x, y) -> _______________;\nArrays.sort(args, comp);\nvar result = Arrays.binarySearch(args, one, comp);\nSystem.out.println(result);\n}\npublic static void main(String[] args) {\nsortAndSearch(\"seed\", \"flower\");\n}",
      "responses": [{
        "code": "A",
        "value": "If the blank contains ‐x.compareTo(y), then the code outputs 0."
      }, {
        "code": "B",
        "value": "If the blank contains ‐x.compareTo(y), then the code outputs ‐1."
      }, {
        "code": "C",
        "value": "If the blank contains x.compareTo(y), then the code outputs 0."
      }, {
        "code": "D",
        "value": "If the blank contains ‐y.compareTo(x), then the code outputs 0."
      }, {
        "code": "E",
        "value": "If the blank contains ‐y.compareTo(x), then the code outputs ‐1."
      }, {
        "code": "F",
        "value": "If the blank contains y.compareTo(x), then the code outputs 0."
      }, {
        "code": "G",
        "value": "If the blank contains y.compareTo(x), then the code outputs ‐1."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "75. C,D. The code will output 0 when the array is sorted in ascending order\nsince flower will be first. Option C is the most straightforward way of\ndoing this, making it one of the answers. Reversing the order of the\nvariables or adding a negative sign sorts in descending order makes options\nA, B, E, F, and G incorrect. Doing both is a complicated way of sorting in\nascending order, making option D the other correct answer."
      }
    },
    "76": {
      "nbr": 76,
      "value": "What does this code output?\nString[] nums = new String[] { \"1\", \"9\", \"10\" };\nArrays.sort(nums);\nSystem.out.println(Arrays.toString(nums));",
      "responses": [{
        "code": "A",
        "value": "[1, 9, 10]"
      }, {
        "code": "B",
        "value": "[1, 10, 9]"
      }, {
        "code": "C",
        "value": "[9, 1, 10]"
      }, {
        "code": "D",
        "value": "[9, 10, 1]"
      }, {
        "code": "E",
        "value": "[10, 1, 9]"
      }, {
        "code": "F",
        "value": "[10, 9, 1]"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "76. B. The elements of the array are of type String rather than int. Therefore,\nwe use alphabetical order when sorting. The character 1 sorts before the\ncharacter 9, alphabetically making option A incorrect. Shorter strings sort\nbefore longer strings when all the other characters are the same, making\noption B the answer."
      }
    },
    "77": {
      "nbr": 77,
      "value": "Which is the first line to prevent this code from compiling and running\nwithout error?\nchar[][] ticTacToe = new char[3][3]; // r1\nticTacToe[0][0] = 'X'; // r2\nticTacToe[1][1] = 'X';\nticTacToe[2][2] = 'X';\nSystem.out.println(ticTacToe.length + \" in a row!\"); // r3",
      "responses": [{
        "code": "A",
        "value": "Line r1"
      }, {
        "code": "B",
        "value": "Line r2"
      }, {
        "code": "C",
        "value": "Line r3"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "77. D. This code is correct. Line r1 correctly creates a 2D array. The next\nthree lines correctly assign a value to an array element. Line r3 correctly\noutputs 3 in a row!"
      }
    },
    "78": {
      "nbr": 78,
      "value": "What is true of the following code? (Choose three.)\n36: var names = new HashMap<String, String>();\n37: names.put(\"peter\", \"pan\");\n38: names.put(\"wendy\", \"darling\");\n39:\n40: String w = names.getOrDefault(\"peter\");\n41: String x = names.getOrDefault(\"peter\", \"x\");\n42: String y = names.getOrDefault(\"john\", \"x\");",
      "responses": [{
        "code": "A",
        "value": "One line does not compile."
      }, {
        "code": "B",
        "value": "Two lines do not compile."
      }, {
        "code": "C",
        "value": "If any lines that do not compile are removed, the String on line 40 is\nset to null."
      }, {
        "code": "D",
        "value": "If any lines that do not compile are removed, the String on line 41 is\nset to \"pan\"."
      }, {
        "code": "E",
        "value": "If any lines that do not compile are removed, the String on line 41 is\nset to \"x\"."
      }, {
        "code": "F",
        "value": "If any lines that do not compile are removed, the String on line 42 is\nset to \"x\"."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "F"
        ],
        "explanation": "78. A,D,F. Line 40 does not compile since getOrDefault() requires two\nparameters. This makes option A the first answer. The rest of the code does\ncompile. Option D is the next answer because getOrDefault() returns the\nvalue from the map when the key is present. Finally, option F is correct\nbecause getOrDefault() returns the second parameter when the key is not\npresent."
      }
    },
    "79": {
      "nbr": 79,
      "value": "What does the following output?\n18: List<String> list = List.of(\n19: \"Mary\", \"had\", \"a\", \"little\", \"lamb\");\n20: Set<String> set = new HashSet<>(list);\n21: set.addAll(list);\n22: for(String sheep : set)\n23: if (sheep.length()> 1)\n24: set.remove(sheep);\n25: System.out.println(set);",
      "responses": [{
        "code": "A",
        "value": "[a, lamb, had, Mary, little]"
      }, {
        "code": "B",
        "value": "[a]"
      }, {
        "code": "C",
        "value": "[a, a]"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "79. E. Lines 18 and 19 create a list with five elements. Line 20 makes a set\nwith the same five elements. Line 21 does not change the contents of the set\nsince sets must have unique elements. The loop on line 22 tries to delete\nelements but instead throws a ConcurrentModificationException, making\noption E the answer."
      }
    },
    "80": {
      "nbr": 80,
      "value": "Which of the following fills in the blank so this code compiles?\npublic static void getExceptions(Collection<__________>\ncoll) {\ncoll.add(new RuntimeException());\ncoll.add(new Exception());\n}",
      "responses": [{
        "code": "A",
        "value": "?"
      }, {
        "code": "B",
        "value": "? extends Exception"
      }, {
        "code": "C",
        "value": "? super Exception"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "80. C. Option C is correct because all the types being added are of type\nException or direct subclasses."
      }
    }
  }
}, {
  "name": "Working with Streams and Lambda Expressions",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "The following figure represents a stream pipeline. Given this, would the\nboxes X, Y, Z best represent?",
      "responses": [{
        "code": "A",
        "value": "Origin, intermediate operation, and final operation"
      }, {
        "code": "B",
        "value": "Origin, intermediate operation, and sink"
      }, {
        "code": "C",
        "value": "Origin, intermediate operation, and terminal operation"
      }, {
        "code": "D",
        "value": "Source, intermediate operation, and final operation"
      }, {
        "code": "E",
        "value": "Source, intermediate operation, and sink"
      }, {
        "code": "F",
        "value": "Source, intermediate operation, and terminal operation"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "1. F. The source is the first operation, and the terminal operation comes last,\nmaking option F the answer. You need to know this terminology."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Which of the following is required for all valid lambda expressions?",
      "responses": [{
        "code": "A",
        "value": "()"
      }, {
        "code": "B",
        "value": "‐>"
      }, {
        "code": "C",
        "value": "{}"
      }, {
        "code": "D",
        "value": "Parameter data type(s)"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "2. B. The lambda expression s ‐> true is valid, making options A, C, and D\nincorrect. Parentheses, (), are not required on the left‐hand side if there is\nonly one variable. Braces, {}, are not required if the right‐hand side is a\nsingle expression. Parameter data types are only required if the data type for\nat least one parameter is specified; otherwise, none are required. The\nremaining choice, the arrow operator, ‐>, is required for all lambda\nexpressions, making option B the correct answer."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Fill in the blanks: The ______________ functional interface does not take\nany inputs, while the ______________ functional interface does not return\nany data.",
      "responses": [{
        "code": "A",
        "value": "IntConsumer, LongSupplier"
      }, {
        "code": "B",
        "value": "IntSupplier, Function"
      }, {
        "code": "C",
        "value": "Supplier, DoubleConsumer"
      }, {
        "code": "D",
        "value": "UnaryOperator, Consumer"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "3. C. The Supplier functional interface does not take any inputs, while the\nConsumer functional interface does not return any data. This behavior\nextends to the primitive versions of the functional interfaces, making option\nC the correct answer. Option A is incorrect because IntConsumer takes a\nvalue, while LongSupplier returns a value. Options B and D are incorrect\nbecause Function and UnaryOperator both take an input and produce a\nvalue."
      }
    },
    "4": {
      "nbr": 4,
      "value": "What is the result of executing the following application multiple times?\npackage bears;\nimport java.util.*;\npublic class Bounce {\npublic static void main(String… legend) {\nList.of(1,2,3,4).stream()\n.forEach(System.out::println);\nList.of(1,2,3,4).parallel()\n.forEach(System.out::println);\nList.of(1,2,3,4).parallel()\n.forEachOrdered(System.out::println);\n} }",
      "responses": [{
        "code": "A",
        "value": "Only the first stream prints the same order every time."
      }, {
        "code": "B",
        "value": "Only the first and second streams print the same order every time."
      }, {
        "code": "C",
        "value": "Only the first and third streams print the same order every time."
      }, {
        "code": "D",
        "value": "All of the streams print the same order every time."
      }, {
        "code": "E",
        "value": "None of the streams prints the same order every time."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "4. F. A List instance, which inherits the Collection interface, does not have\na parallel() method. Instead, parallelStream() must be used, making\noption F correct. If the code was corrected to use parallelStream(), then\nthe first and third streams would be consistently printed in the same order.\nRemember that the forEachOrdered() method forces parallel streams to\nrun in sequential order. The order of the second operation would be\nunknown ahead of time, since it uses a parallel stream."
      }
    },
    "5": {
      "nbr": 5,
      "value": "A lambda expression for which of the following functional interfaces could\nbe used to return a Double value? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "UnaryOperator"
      }, {
        "code": "B",
        "value": "BiPredicate"
      }, {
        "code": "C",
        "value": "BiOperator"
      }, {
        "code": "D",
        "value": "BiConsumer"
      }, {
        "code": "E",
        "value": "BiFunction"
      }, {
        "code": "F",
        "value": "BiSupplier"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "5. A,E. The UnaryOperator and BiFunction return a generic argument, such\nas Double, making options A and E correct. Option B is incorrect because\nall predicate functions return boolean. Option C is incorrect because\nBiOperator does not exist in the java.util.function package. The\ncorrect name is BinaryOperator. Option D is incorrect because all\nconsumer functions return void. Finally, option F is incorrect because\nBiSupplier does not exist in the java.util.function package. Supplier\nfunctions return values, and Java does not support methods with more than\none return type."
      }
    },
    "6": {
      "nbr": 6,
      "value": "What does the following output?\nvar list = new ArrayList<String>();\nlist.add(\"Austin\");\nlist.add(\"Boston\");\nlist.add(\"San Francisco\");\nvar c = list.stream()\n.filter(a -> a.length()> 10) // line x\n.count();\nSystem.out.println(c + \" \" + list.size());",
      "responses": [{
        "code": "A",
        "value": "1 1"
      }, {
        "code": "B",
        "value": "1 3"
      }, {
        "code": "C",
        "value": "2 3"
      }, {
        "code": "D",
        "value": "The code does not compile due to line x."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "6. B. The stream pipeline is correct and filters all values out that are 10\ncharacters or smaller. Only San Francisco is long enough, so c is 1. The\nstream() call creates a new object, so stream operations do not affect the\noriginal list. Since the original list is still 3 elements, option B is correct."
      }
    },
    "7": {
      "nbr": 7,
      "value": "Identify the correct functional interfaces to fill in this table correctly.\n(Choose three.)\nFunctional Interface Possible Return Type\nInterface X Boolean\nInterface Y int\nInterface Z Void",
      "responses": [{
        "code": "A",
        "value": "Interface X is Predicate."
      }, {
        "code": "B",
        "value": "Interface X is Supplier."
      }, {
        "code": "C",
        "value": "Interface Y is Comparator."
      }, {
        "code": "D",
        "value": "Interface Y is Supplier."
      }, {
        "code": "E",
        "value": "Interface Z is Consumer."
      }, {
        "code": "F",
        "value": "Interface Z is Supplier."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "E"
        ],
        "explanation": "7. B,C,E. Interface X is tricky. If it returned a boolean primitive, option A\nwould be correct as Predicate returns a boolean. However, it returns a\nwrapper object, so it has to be a Supplier, making option B the answer\ninstead.\nInterface Y and Z are more straightforward as a Comparator and Consumer,\nrespectively. This makes options C and E the final two answers."
      }
    },
    "8": {
      "nbr": 8,
      "value": "What is a common reason for a stream pipeline not to run?",
      "responses": [{
        "code": "A",
        "value": "The source doesn't generate any items."
      }, {
        "code": "B",
        "value": "There are no intermediate operations."
      }, {
        "code": "C",
        "value": "The terminal operation is missing."
      }, {
        "code": "D",
        "value": "The version of Java is too old."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "8. C. Option A is incorrect because a pipeline still runs if the source doesn't\ngenerate any items and the rest of the pipeline is correct. Granted, some of\nthe operations have nothing to do, but control still passes to the terminal\noperation. Option B is incorrect because intermediate operations are\noptional. Option C is the answer. The terminal operation triggers the\npipeline to run. Option D is incorrect because the code would not compile\nat all if the version of Java were too old."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Which functional interface takes a long value as an input argument and has\nan accept() method?",
      "responses": [{
        "code": "A",
        "value": "LongConsumer"
      }, {
        "code": "B",
        "value": "LongFunction"
      }, {
        "code": "C",
        "value": "LongPredicate"
      }, {
        "code": "D",
        "value": "LongSupplier"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "9. A. The LongSupplier interface does not take any input, making option D\nincorrect. It also uses the method name getAsLong(). The rest of the\nfunctional interfaces all take a long value but vary on the name of the\nabstract method they use. LongFunction contains apply() and\nLongPredicate contains test(), making options B and C, respectively,\nincorrect. That leaves us with LongConsumer, which contains accept(),\nmaking option A the correct answer."
      }
    },
    "10": {
      "nbr": 10,
      "value": "Given a parallel Stream<T>, which method would you use to obtain an\nequivalent serial Stream<T>?",
      "responses": [{
        "code": "A",
        "value": "unordered()"
      }, {
        "code": "B",
        "value": "reduce()"
      }, {
        "code": "C",
        "value": "concat()"
      }, {
        "code": "D",
        "value": "stream()"
      }, {
        "code": "E",
        "value": "boxed()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "10. F. The correct method to obtain an equivalent sequential stream of an\nexisting stream is sequential(), which is inherited by any class that\nimplements BaseStream<T>. Since this isn't an option, option F is correct.\nNote that unordered() creates a stream that can be evaluated in any order,\nbut it can still be processed in a sequential or parallel stream."
      }
    },
    "11": {
      "nbr": 11,
      "value": "Which of the following is a valid lambda expression?",
      "responses": [{
        "code": "A",
        "value": "r ‐> {return 1==2}"
      }, {
        "code": "B",
        "value": "(q) ‐> true"
      }, {
        "code": "C",
        "value": "(x,y) ‐> {int test; return test>0;}"
      }, {
        "code": "D",
        "value": "a,b ‐> true"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "11. B. Option A is incorrect because the lambda expression is missing a\nsemicolon (;) at the end of the return statement. Option C is incorrect\nbecause the local variable test is used without being initialized. Option D\nis also incorrect. The parentheses are required on the left‐hand side of the\nlambda expression when there is more than one value or a data type is\nspecified. Option B is the correct answer and the only valid lambda\nexpression."
      }
    },
    "12": {
      "nbr": 12,
      "value": "Which are true of the following? (Choose two.)\nvar empty = Optional.empty();\nvar param = Optional.of(null);\nvar method = Optional.ofNullable(null);",
      "responses": [{
        "code": "A",
        "value": "All of these will run without error."
      }, {
        "code": "B",
        "value": "One of the lines fails to compile or throws an exception."
      }, {
        "code": "C",
        "value": "Two of the lines fail to compile or throw an exception."
      }, {
        "code": "D",
        "value": "None of these returns true when calling opt.isPresent()"
      }, {
        "code": "E",
        "value": "One of these returns true when calling opt.isPresent()"
      }, {
        "code": "F",
        "value": "Two of these return true when calling opt.isPresent()"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "12. B,D. The second line throws a NullPointerException when you pass a\nnull reference to the of() method. The others compile and run\nsuccessfully, making option B correct. The first and third lines return false\nbecause they represent an empty Optional. This makes option D the other\nanswer."
      }
    },
    "13": {
      "nbr": 13,
      "value": "Which of the following statements about DoubleSupplier and\nSupplier<Double> is not true?",
      "responses": [{
        "code": "A",
        "value": "Both are functional interfaces."
      }, {
        "code": "B",
        "value": "Both take zero parameters."
      }, {
        "code": "C",
        "value": "Lambdas for both can return a double value."
      }, {
        "code": "D",
        "value": "Lambdas for both cannot return a null value."
      }, {
        "code": "E",
        "value": "One supports a generic type; the other does not."
      }, {
        "code": "F",
        "value": "All of these are true."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "13. D. Both are functional interfaces in the java.util.function package,\nmaking option A true. Additionally, both lack parameters, making option B\ntrue. The major difference between the two is that Supplier<Double> takes\nthe generic type Double, while the other does not take any generic type and\ninstead uses the primitive double. For this reason, options C and E are true\nstatements. For Supplier<Double> in option C, remember that the returned\ndouble value can be implicitly autoboxed to Double. Option D is the correct\nanswer. Lambdas for Supplier<Double> can return a null value since\nDouble is an object type, while lambdas for DoubleSupplier cannot; they\ncan only return primitive double values."
      }
    },
    "14": {
      "nbr": 14,
      "value": "What is the output of the following program?\nimport java.util.stream.*;\npublic class Bull {\nvoid charge() {\nIntStream.range(1,6)\n.parallel()\n.forEachOrdered(System.out::print);\n}\npublic static void main(String[] args) {\nvar b = new Bull();\nb.charge();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "12345"
      }, {
        "code": "B",
        "value": "54321"
      }, {
        "code": "C",
        "value": "The output cannot be determined ahead of time."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "An exception is thrown at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "14. A. Even though a parallel stream is used, the forEachOrdered() method\nforces the stream to operate in the order of its data source. The code\ncompiles and runs without issue printing 12345 every time, and making\noption A correct. If forEach() was used instead, then the output would\nvary at runtime."
      }
    },
    "15": {
      "nbr": 15,
      "value": "Fill in the blank with the functional interface from java.util.function\nthat allows the code to compile and print 3 at runtime.\n_____________ transformer = x -> x;\nvar prime = List.of(3,1,4,1,5,9)\n.stream()\n.limit(1)\n.peek(s -> {})\n.mapToInt(transformer)\n.peek(s -> {})\n.sum();\nSystem.out.println(prime);",
      "responses": [{
        "code": "A",
        "value": "Function<Integer,Integer>"
      }, {
        "code": "B",
        "value": "UnaryOperator<Integer>"
      }, {
        "code": "C",
        "value": "ToIntFunction<Integer>"
      }, {
        "code": "D",
        "value": "IntUnaryOperator"
      }, {
        "code": "E",
        "value": "The code does not compile regardless of what functional interface is\nplaced in the blank."
      }, {
        "code": "F",
        "value": "The code is capable of compiling, but since prime is an OptionalInt\nvalue, it cannot be 3 at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "15. C. The first line that contains the lambda expression will actually compile\nwith any of the functional interfaces listed in the options. The stream\noperation, though, will compile only if ToIntFunction<Integer> is used. It\nrequires this functional interface, which takes a generic argument and\nreturns int. For this reason, option C is correct. Option F is incorrect\nbecause sum() on an IntStream returns an int, not an OptionalInt. Note\nthat the peek() operations in this stream have no effect."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Which fills in the blank so the code is guaranteed to print 1?\nvar stream = Stream.of(1, 2, 3);\nSystem.out.println(stream.__________);",
      "responses": [{
        "code": "A",
        "value": "anyMatch()"
      }, {
        "code": "B",
        "value": "findAny()"
      }, {
        "code": "C",
        "value": "first()"
      }, {
        "code": "D",
        "value": "min()"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "16. E. Option A is incorrect because anyMatch() returns a boolean. Option B\nis incorrect because findAny() might not return 1. The result could be any\nof the three numbers. Option C is incorrect because there is no first()\nmethod available as a terminal operation. Option D is tempting because\nthere is a min() method. However, since we are working with a Stream (not\na primitive stream like IntStream), this method requires a Comparator as a\nparameter. Therefore, option E is the answer."
      }
    },
    "17": {
      "nbr": 17,
      "value": "What is the result of the following?\n6: var list = new ArrayList<String>();\n7: list.add(\"Monday\");\n8: list.add(String::new);\n9: list.add(\"Tuesday\");\n10: list.remove(0);\n11: System.out.println(list.get(0));",
      "responses": [{
        "code": "A",
        "value": "null"
      }, {
        "code": "B",
        "value": "An empty String."
      }, {
        "code": "C",
        "value": "Monday"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "17. D. Line 8 does not compile. String::new is a constructor reference. This\nconstructor reference is equivalent to writing the lambda () ‐> new\nString(). It participates in deferred execution. When it is executed later, it\nwill return a String. It does not return a String on line 8, though. The\nmethod reference is a Supplier<String>, which cannot be stored in list.\nSince the code does not compile, option D is correct."
      }
    },
    "18": {
      "nbr": 18,
      "value": "Which functional interface, when filled into the blank, allows the class to\ncompile?\npackage space;\nimport java.util.function.*;\npublic class Asteroid {\npublic void mine(___________ lambda) {\n// IMPLEMENTATION OMITTED\n}\npublic static void main(String[] debris) {\nnew Asteroid().mine((s,p) -> s+p);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "BiConsumer<Integer,Double>"
      }, {
        "code": "B",
        "value": "BiConsumer<Integer,Double,Double>"
      }, {
        "code": "C",
        "value": "BiFunction<Integer,Double,Double>"
      }, {
        "code": "D",
        "value": "BiFunction<Integer,Integer,Double>"
      }, {
        "code": "E",
        "value": "Function<Integer,Double>"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "18. C. The lambda (s,p) ‐> s+p takes two arguments and returns a value.\nFor this reason, options A and B are incorrect because BiConsumer does not\nreturn any values. Option E is also incorrect, since Function takes only one\nargument and returns a value. This leaves us with options C and D, which\nboth use BiFunction, which takes two generic arguments and returns a\ngeneric value. Option D is incorrect because the datatype of the unboxed\nsum s+q is int, and int cannot be both autoboxed and implicitly cast to\nDouble. Option C is correct. The sum s+p is of type double, and double can\nbe autoboxed to Double."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What best describes a reduction?",
      "responses": [{
        "code": "A",
        "value": "A source operation that creates a small value"
      }, {
        "code": "B",
        "value": "An intermediate operation where it filters the stream it receives"
      }, {
        "code": "C",
        "value": "An intermediate operation where it mathematically divides each\nelement in the stream"
      }, {
        "code": "D",
        "value": "A terminal operation where a single value is generated by reading each\nelement in the prior step in a stream pipeline"
      }, {
        "code": "E",
        "value": "A terminal operation where one element is returned from the prior step\nin a stream pipeline without reading all the elements"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "19. D. The word reduction is used with streams for a terminal operation, so\noptions A, B, and C are incorrect. Option E describes a valid terminal\noperation like anyMatch(), but is not a reduction. Option D is correct\nbecause a reduction has to look at each element in the stream to determine\nthe result."
      }
    },
    "20": {
      "nbr": 20,
      "value": "Which statements about the following application are correct? (Choose\ntwo.)\nimport java.util.concurrent.atomic.*;\nimport java.util.stream.*;\npublic class TicketTaker {\nlong ticketsSold;\nfinal AtomicInteger ticketsTaken;\npublic TicketTaker() {\nticketsSold = 0;\nticketsTaken = new AtomicInteger(0);\n}\npublic void performJob() {\nIntStream.iterate(1, p -> p+1)\n.parallel()\n.limit(100)\n.forEach(i -> ticketsTaken.getAndIncrement());\nIntStream.iterate(1, q -> q+1)\n.parallel()\n.limit(500)\n.forEach(i -> ++ticketsSold);\nSystem.out.print(ticketsTaken+\" \"+ticketsSold);\n}\npublic static void main(String[] matinee) {\nnew TicketTaker().performJob();\n} }",
      "responses": [{
        "code": "A",
        "value": "The TicketTaker constructor does not compile."
      }, {
        "code": "B",
        "value": "The performJob() method does not compile."
      }, {
        "code": "C",
        "value": "The class compiles."
      }, {
        "code": "D",
        "value": "The first number printed is consistently 100."
      }, {
        "code": "E",
        "value": "The second number printed is consistently 500."
      }, {
        "code": "F",
        "value": "A ConcurrentModificationException is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "20. C,D. The class compiles and runs without throwing an exception, making\noption C correct and options A, B, and F incorrect. The class defines two\nvalues that are incremented by multiple threads in parallel. The first\nIntStream statement uses an atomic class to update a variable. Since\nupdating an atomic numeric instance is thread‐safe by design, the first\nnumber printed is always 100, making option D correct. The second\nIntStream statement uses an int with the pre‐increment operator (++),\nwhich is not thread‐safe. It is possible two threads could update and set the\nsame value at the same time, a form of race condition, resulting in a value\nless than 500 and making option E incorrect."
      }
    },
    "21": {
      "nbr": 21,
      "value": "Suppose you have a stream with one element and the code\nstream.xxxx.forEach(System.out::println). Filling in xxxx from top to\nbottom in the table, how many elements can be printed out? Assume a valid\nlambda expression is passed to each method in the table.\nMethod Number elements printed\nfilter() ?\nflatMap() ?\nmap() ?",
      "responses": [{
        "code": "A",
        "value": "Zero or one, zero or more, exactly one"
      }, {
        "code": "B",
        "value": "Zero or one, exactly one, zero or more"
      }, {
        "code": "C",
        "value": "Zero or one, zero or more, zero or more"
      }, {
        "code": "D",
        "value": "Exactly one, zero or more, exactly one"
      }, {
        "code": "E",
        "value": "Exactly one, exactly one, zero or more"
      }, {
        "code": "F",
        "value": "Exactly one, zero or more, zero or more"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "21. A. The filter() method either passes along a given element or doesn't,\nmaking options D, E, and F incorrect. The flatMap() method doesn't pass\nalong any elements for empty streams. For nonempty streams, it flattens the\nelements, allowing it to return zero or more elements. This makes option B\nincorrect. Finally, the map() method applies a one‐to‐one function for each\nelement. It has to return exactly one element, so option A is the correct\nanswer."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Assuming the proper generic types are used, which lambda expression can\nbe assigned to a ToDoubleBiFunction functional interface reference?\n(Choose three.)",
      "responses": [{
        "code": "A",
        "value": "(Integer a, Double b) ‐> {int c; return b;}"
      }, {
        "code": "B",
        "value": "(h,i) ‐> (long)h"
      }, {
        "code": "C",
        "value": "(String u, Object v) ‐> u.length()+v.length()"
      }, {
        "code": "D",
        "value": "(x,y) ‐> {int z=2; return y/z;}"
      }, {
        "code": "E",
        "value": "z ‐> z"
      }, {
        "code": "F",
        "value": "(double y, double z) ‐> y + z"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "D"
        ],
        "explanation": "22. A,B,D. To begin with, ToDoubleBiFunction<T,U> takes two generic\ninputs and returns a double value. Option A is correct because it takes an\nInteger and Double and returns a Double value that can be implicitly\nunboxed to double. Option B is correct because long can be implicitly cast\nto double. While we don't know the data types for the input arguments, we\nknow that some values, such as using Integer for both, will work. Option\nC cannot be assigned and does not compile because the variable v is of type\nObject and Object does not have a length() method. Option D is correct.\nThe variable y could be declared Double in the generic argument to the\nfunctional interface, making y/z a double return value. Option E is not\ncorrect because the lambda only has one parameter. Finally, option F is\nincorrect because the interface uses the class Double rather than primitive\ndouble."
      }
    },
    "23": {
      "nbr": 23,
      "value": "Given a Stream<T>, which method would you use to obtain an equivalent\nparallel Stream<T>?",
      "responses": [{
        "code": "A",
        "value": "getParallelStream()"
      }, {
        "code": "B",
        "value": "parallelStream()"
      }, {
        "code": "C",
        "value": "parallel()"
      }, {
        "code": "D",
        "value": "getParallel()"
      }, {
        "code": "E",
        "value": "parallels()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "23. C. The correct method to obtain an equivalent parallel stream of an\nexisting stream is parallel(), which is inherited by any class that\nimplements BaseStream<T>. For this reason, option C is correct."
      }
    },
    "24": {
      "nbr": 24,
      "value": "Rewrite this lambda that takes an int n using a constructor reference:\nn -> new ArrayList<>(n)",
      "responses": [{
        "code": "A",
        "value": "ArrayList::new"
      }, {
        "code": "B",
        "value": "ArrayList::new()"
      }, {
        "code": "C",
        "value": "ArrayList::new(n)"
      }, {
        "code": "D",
        "value": "ArrayList::new[n]"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "24. A. The lambda is a Function<Integer, ArrayList>. We need a\nconstructor reference that uses the new keyword where a method name\nwould normally go in a method reference. It can implicitly take zero or one\nparameters just like a method reference. In this case, we have one\nparameter, which gets passed to the constructor. Option A is correct.\nOptions B, C, and D use syntax that is not supported with method\nreferences."
      }
    },
    "25": {
      "nbr": 25,
      "value": "On a DoubleStream, how many of the methods average(), count(), max(),\nand sum() return an OptionalDouble?",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "25. C. The average() method returns an OptionalDouble. This reflects that it\ndoesn't make sense to calculate an average when you don't have any\nnumbers. Similarly, max() returns an OptionalDouble because there isn't a\nmaximum of no number. By contrast, counting without any numbers gives\nthe long number 0 and summing gives the double number 0.0. Since only\ntwo methods matches the desired return type, option C is correct."
      }
    },
    "26": {
      "nbr": 26,
      "value": "Which of the following is not a functional interface in the\njava.util.function package? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "BiPredicate"
      }, {
        "code": "B",
        "value": "DoubleUnaryOperator"
      }, {
        "code": "C",
        "value": "IntUnaryOperator"
      }, {
        "code": "D",
        "value": "ObjectDoubleConsumer"
      }, {
        "code": "E",
        "value": "ObjectIntConsumer"
      }, {
        "code": "F",
        "value": "ToLongFunction"
      }
      ],
      "answer": {
        "codes": [
          "D",
          "E"
        ],
        "explanation": "26. D,E. The BiPredicate interface takes two generic arguments and returns a\nboolean value. Next, DoubleUnaryOperator and IntUnaryOperator exist\nand transform values of type double and int, respectively. Last,\nToLongFunction takes a generic argument and returns a long value. That\nleaves options D and E, which is the answer. While there are\nObjDoubleConsumer and ObjIntConsumer functional interfaces, there is no\nsuch thing as ObjectDoubleConsumer or ObjectIntConsumer. Remember\nthat Object is abbreviated to Obj in all functional interfaces in\njava.util.function."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Five of the following six methods always produce the same result whether\nthey are executed on an ordered serial or parallel stream. Which one does\nnot?",
      "responses": [{
        "code": "A",
        "value": "findAny()"
      }, {
        "code": "B",
        "value": "findFirst()"
      }, {
        "code": "C",
        "value": "limit()"
      }, {
        "code": "D",
        "value": "skip()"
      }, {
        "code": "E",
        "value": "anyMatch()"
      }, {
        "code": "F",
        "value": "count()"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "27. A. The findAny() method can return the first, last, or any element of the\nstream, regardless of whether the stream is serial or parallel. While on serial\nstreams this is likely to be the first element in the stream, on parallel\nstreams the result is less certain. For this reason, option A is the correct\nanswer. The anyMatch() and count() methods produce the same result,\nregardless of whether the stream is serial or parallel. The rest of the\noperations force the stream to behave in a sequential manner when applied\nto an ordered stream, even if it is parallel. Note that the behavior is not the\nsame on an unordered stream. For example, findFirst() can return any\nelement when applied to an unordered stream."
      }
    },
    "28": {
      "nbr": 28,
      "value": "In a stream pipeline, which can return a value other than a Stream?",
      "responses": [{
        "code": "A",
        "value": "Source"
      }, {
        "code": "B",
        "value": "Intermediate operation"
      }, {
        "code": "C",
        "value": "Terminal operation"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "28. C. The result of the source and any intermediate operations are chained\nand eventually passed to the terminal operation. The terminal operation is\nwhere a nonstream result is generated, making option C correct."
      }
    },
    "29": {
      "nbr": 29,
      "value": "When working with a Stream<String>, which of these types can be\nreturned from the collect() terminal operator by passing arguments to\nCollectors.groupingBy()?",
      "responses": [{
        "code": "A",
        "value": "Only Map<Boolean, HashSet<String>>"
      }, {
        "code": "B",
        "value": "Only Map<Integer, List<String>>"
      }, {
        "code": "C",
        "value": "Both Map<Boolean, HashSet<String>> and Map<Integer,\nList<String>>"
      }, {
        "code": "D",
        "value": "Only List<Integer>"
      }, {
        "code": "E",
        "value": "Only List<String>"
      }, {
        "code": "F",
        "value": "Both List<Integer> and List<String>"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "29. C. The groupingBy() collector always returns a Map (or a specific\nimplementation class of Map), so options D, E, and F are incorrect. The\nother two are definitely possible. To get one, you can group using a\nFunction that returns an Integer such as\ns.collect(groupingBy(String::length)). To get the other, you need to\ngroup using a Function that returns a Boolean and specify the type, such as\ns.collect(groupingBy(String::isEmpty,\ntoCollection(HashSet::new))). Therefore, option C is correct."
      }
    },
    "30": {
      "nbr": 30,
      "value": "What does the following output?\n12: Set<String> set = new HashSet<>();\n13: set.add(\"tire-\");\n14: List<String> list = new LinkedList<>();\n15: Deque<String> queue = new ArrayDeque<>();\n16: queue.push(\"wheel-\");\n17: Stream.of(set, list, queue)\n18: .flatMap(x -> x)\n19: .forEach(System.out::print);",
      "responses": [{
        "code": "A",
        "value": "[tire‐][wheel‐]"
      }, {
        "code": "B",
        "value": "tire‐wheelC.\n[wheel‐][tire‐]"
      }, {
        "code": "D",
        "value": "wheel‐tire‐"
      }, {
        "code": "E",
        "value": "None of the above."
      }, {
        "code": "F",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "30. F. The flatMap() method works with streams rather than collections. Line\n18 is problematic because the return value is not a stream. Since the code\ndoes not compile, option F is correct. If the lambda was changed to x ‐>\nx.stream(), option B would be the answer."
      }
    },
    "31": {
      "nbr": 31,
      "value": "What is the result of executing the following?\nvar list = new LinkedList<>();\nlist.add(\"Archie\");\nlist.add(\"X-Men\");\nStream s = list.stream(); // line w\ns.forEach(System.out::println);\ns.forEach(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "The code runs without exception and prints two lines."
      }, {
        "code": "B",
        "value": "The code runs without exception and prints four lines."
      }, {
        "code": "C",
        "value": "The code does not compile due to line w."
      }, {
        "code": "D",
        "value": "The code does not compile due to another line."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "31. E. Since no generic type is specified, list is a LinkedList<Object>. Line\nw compiles because no generic type is specified. However, Java only allows\nyou to operate on a stream once. The final line of code throws an\nIllegalStateException because the stream has already been used up,\nmaking option D correct."
      }
    },
    "32": {
      "nbr": 32,
      "value": "What is the output of the following application?\npackage zoo;\nimport java.util.function.*;\npublic class TicketTaker {\nprivate static int AT_CAPACITY = 100;\npublic int takeTicket(int currentCount,\nIntUnaryOperator<Integer> counter) {\nreturn counter.applyAsInt(currentCount);\n}\npublic static void main(String…theater) {\nfinal TicketTaker bob = new TicketTaker();\nfinal int oldCount = 50;\nfinal int newCount = bob.takeTicket(oldCount,t -> {\nif(t>AT_CAPACITY) {\nthrow new RuntimeException(\n\"Sorry, max has been reached\");\n}\nreturn t+1;\n});\nSystem.out.print(newCount);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "50"
      }, {
        "code": "B",
        "value": "51"
      }, {
        "code": "C",
        "value": "The code does not compile because of the lambda expression."
      }, {
        "code": "D",
        "value": "The code does not compile for a different reason."
      }, {
        "code": "E",
        "value": "The code compiles but prints an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "32. D. The code does not compile, so options A, B, and E are incorrect. The\nIntUnaryOperator functional interface is not generic, so the argument\nIntUnaryOperator<Integer> in the takeTicket() does not compile,\nmaking option D the correct answer. The lambda expression compiles\nwithout issue, making option C incorrect. If the generic argument\n<Integer> was dropped from the argument declaration, the class would\ncompile without issue and output 51 at runtime, making option B the\ncorrect answer."
      }
    },
    "33": {
      "nbr": 33,
      "value": "What are the three requirements for performing a parallel reduction with the\ncollect() method, which takes a Collector argument. (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "The Collector argument is marked concurrent."
      }, {
        "code": "B",
        "value": "The elements of the stream implement the Comparable interface."
      }, {
        "code": "C",
        "value": "The stream is parallel."
      }, {
        "code": "D",
        "value": "The stream is thread‐safe."
      }, {
        "code": "E",
        "value": "The stream or Collector is marked unordered."
      }, {
        "code": "F",
        "value": "The stream is not a primitive stream."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "E"
        ],
        "explanation": "33. A,C,E. Options A, C, and E are the precise requirements for Java to\nperform a concurrent reduction using the collect() method, which takes a\nCollector argument. Recall from your studies that a Collector is\nconsidered concurrent and unordered if it has the\nCollector.Characteristics enum values CONCURRENT and UNORDERED,\nrespectively. The rest of the options are not required for a parallel\nreduction."
      }
    },
    "34": {
      "nbr": 34,
      "value": "What is true about the following code? (Choose two.)\n27: public static void main(String[] s) {\n28: Predicate dash = c -> c.startsWith(\"-\");\n29: System.out.println(dash.test(\"–\"));\n30:\n31: Consumer clear = x -> System.out.println(x);\n32: clear.accept(\"pink\");\n33:\n34: Comparator<String> c = (String s, String t) -> 0;\n35: System.out.println(c.compare(\"s\", \"t\"));\n36: }",
      "responses": [{
        "code": "A",
        "value": "The code compiles successfully."
      }, {
        "code": "B",
        "value": "One line does not compile."
      }, {
        "code": "C",
        "value": "Two lines do not compile."
      }, {
        "code": "D",
        "value": "Three lines do not compile."
      }, {
        "code": "E",
        "value": "If any lines that do not compile are fixed, the output includes pink."
      }, {
        "code": "F",
        "value": "If any lines that do not compile are fixed, the output does not include\npink."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "34. C,E. While it is common for a Predicate to have a generic type, it is not\nrequired. However, it is treated like a Predicate of type Object if the\ngeneric type is missing. Since startsWith() does not exist on Object, line\n28 does not compile.\nLine 34 would be a correct lambda declaration in isolation. However, it\nuses the variable s, which is already taken from the main() method\nparameter. This causes a compiler error on line 34. These are the only two\ncompiler errors, making option C correct. If Predicate were changed to\nPredicate<String> and lambda variable were changed to x, the Consumer\nwould in fact print pink, making option E the other answer."
      }
    },
    "35": {
      "nbr": 35,
      "value": "Which functional interface returns a primitive value?",
      "responses": [{
        "code": "A",
        "value": "BiPredicate"
      }, {
        "code": "B",
        "value": "CharSupplier"
      }, {
        "code": "C",
        "value": "LongFunction"
      }, {
        "code": "D",
        "value": "UnaryOperator"
      }, {
        "code": "E",
        "value": "TriDoublePredicate"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "35. A. Option A is the correct answer because BiPredicate takes two generic\ntypes and returns a primitive boolean value. Option B is incorrect, since\nCharSupplier does not exist in java.util.function. Option C is also\nincorrect, since LongFunction takes a primitive long value and returns a\ngeneric type. Remember, Java only includes primitive functional interfaces\nthat operate on double, int, or long. Option D is incorrect because\nUnaryOperator takes a generic type and returns a generic value. Finally,\noption E is incorrect because TriDoublePredicate is not a built‐in\nfunctional interface."
      }
    },
    "36": {
      "nbr": 36,
      "value": "Given the following code snippet, which lambda expressions are the best\nchoices for an accumulator? (Choose two.)\nimport java.util.*;\nimport java.util.function.*;\npublic class GoodAccumulator {\nint i = 0;\nList<String> words = new ArrayList<>();\npublic void test() {\nBiFunction<Integer,Integer,Integer> x =\n_____________;\nSystem.out.print(List.of(1,2,3,4,5)\n.parallelStream()\n.reduce(0,x,(s1, s2) -> s1 + s2));\n} }",
      "responses": [{
        "code": "A",
        "value": "(a,b) ‐> (a‐b)"
      }, {
        "code": "B",
        "value": "(a,b) ‐> 5"
      }, {
        "code": "C",
        "value": "(a,b) ‐> i++"
      }, {
        "code": "D",
        "value": "(a,b) ‐> {words.add(\"awesome\"); return 0;}"
      }, {
        "code": "E",
        "value": "(a,b) ‐> {return 0;}"
      }, {
        "code": "F",
        "value": "(a,b) ‐> words.add(\"awesome\")"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "36. B,E. An accumulator in a serial or parallel reduction should be associative\nand stateless. In a parallel reduction, problematic accumulators tend to\nproduce more visible errors. Option A is not associative, since (a‐b)‐c is\nnot the same as a‐(b‐c) for all values a, b, and c. Options C and D are\nincorrect because they represent stateful lambda expressions, which should\nbe avoided especially on parallel streams. Option F doesn't even compile,\nsince the return type is a boolean, not an Integer. That leaves us with the\ncorrect answers, options B and E. While these accumulators may not seem\nuseful, they are both stateless and associative, which meets the\nqualifications for performing a reduction."
      }
    },
    "37": {
      "nbr": 37,
      "value": "Fill in the blanks so that both methods produce the same output for all\ninputs.\nprivate static void longer(Optional<Boolean> opt) {\nif (opt.___________())\nSystem.out.println(\"run: \" + opt.get());\n}\nprivate static void shorter(Optional<Boolean> opt) {\nopt.map(x -> \"run: \" + x)\n._________(System.out::println);\n}",
      "responses": [{
        "code": "A",
        "value": "isNotNull, isPresent"
      }, {
        "code": "B",
        "value": "ifPresent, isPresent"
      }, {
        "code": "C",
        "value": "isPresent, forEach"
      }, {
        "code": "D",
        "value": "isPresent, ifPresent"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "37. D. The Optional class has an isPresent() method that doesn't take any\nparameters. It returns a boolean and is commonly used in if statements.\nThere is also an ifPresent() method that takes a Consumer parameter and\nruns it only if the Optional is nonempty. The methods isNotNull() and\nforEach() are not declared in Optional. Therefore, option D is correct."
      }
    },
    "38": {
      "nbr": 38,
      "value": "Rewrite this lambda using a method reference:\n() -> Math.random()",
      "responses": [{
        "code": "A",
        "value": "Math.random"
      }, {
        "code": "B",
        "value": "Math::random"
      }, {
        "code": "C",
        "value": "Math::random()"
      }, {
        "code": "D",
        "value": "java.lang::Math.random"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "38. B. The lambda is a Supplier<Double>. Since the random() method is\nstatic, we need a static method reference. It uses :: to separate the class\nname and method name. Option B is correct. Options A, C, and D use\nsyntax that is not supported with method references."
      }
    },
    "39": {
      "nbr": 39,
      "value": "Which operation can occur more than once in a stream pipeline?",
      "responses": [{
        "code": "A",
        "value": "Origin"
      }, {
        "code": "B",
        "value": "Sink"
      }, {
        "code": "C",
        "value": "Source"
      }, {
        "code": "D",
        "value": "Intermediate operation"
      }, {
        "code": "E",
        "value": "Terminal operation"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "39. D. Options A and B are incorrect because they are not operations in a\nstream pipeline. A source and the terminal operation are required parts of a\nstream pipeline and must occur exactly once. The intermediate operation is\noptional. It can appear zero or more times. Since more than once falls\nwithin zero or more, option D is correct."
      }
    },
    "40": {
      "nbr": 40,
      "value": "What is true of the following code?\n21: var list = List.of('c', 'b', 'a');\n22:\n23: list.stream()\n24: .sorted()\n25: .findAny()\n26: .ifPresent(System.out::println);\n27:\n28: System.out.println(list.stream().sorted().findFirst());",
      "responses": [{
        "code": "A",
        "value": "Both streams are guaranteed to print the single character a."
      }, {
        "code": "B",
        "value": "Both streams will print a single character of a, b, or c."
      }, {
        "code": "C",
        "value": "Only one stream is guaranteed to print the single character a."
      }, {
        "code": "D",
        "value": "Only one stream will print a single character of a, b, or c."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "40. D. All of the code compiles. The first stream source has three elements.\nThe intermediate operations both sort the elements of this stream and then\nwe request one from findAny(). The findAny() method is not guaranteed\nto return a specific element. Since we are not using parallelization, it is\nhighly likely that the code will print a. However, you need to know this is\nnot guaranteed. Additionally, the stream on line 28 prints Optional[a],\nOptional[b], or Optional[c]. Since only lines 23–26 print a single\ncharacter, option D is the answer."
      }
    },
    "41": {
      "nbr": 41,
      "value": "Which functional interface, when entered into the following blank, allows\nthe class to compile?\npackage groceries;\nimport java.util.*;\nimport java.util.function.*;\npublic class Market {\nprivate static void checkPrices(List<Double> prices,\n____________ scanner) {\nprices.forEach(scanner);\n}\npublic static void main(String[] right) {\nList<Double> prices = List.of(1.2, 6.5, 3.0);\ncheckPrices(prices,\np -> {\nString result = p<5 ? \"Correct\" : \"Too\nhigh\";\nSystem.out.println(result);\n});\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Consumer<Integer>"
      }, {
        "code": "C",
        "value": "DoubleConsumer"
      }, {
        "code": "D",
        "value": "Supplier<Double>"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "41. E. First, the forEach() method requires a Consumer instance. Option D\ncan be immediately discarded because Supplier<Double> does not inherit\nConsumer. For this same reason, option C is also incorrect. DoubleConsumer\ndoes not inherit from Consumer. In this manner, primitive functional\ninterfaces cannot be used in the forEach() method. Option A seems\ncorrect, since forEach() does take a Consumer instance, but it is missing a\ngeneric argument. Without the generic argument, the lambda expression\ndoes not compile because the expression p<5 cannot be applied to an\nObject. Option B is also close, however, a Double cannot be passed to an\nInteger. The correct functional interface is Consumer<Double>, and since\nthat is not available, option E is the correct answer."
      }
    },
    "42": {
      "nbr": 42,
      "value": "Which of the following is not a valid lambda expression?",
      "responses": [{
        "code": "A",
        "value": "(Integer j, k) ‐> 5"
      }, {
        "code": "B",
        "value": "(p,q) ‐> p+q"
      }, {
        "code": "C",
        "value": "(Integer x, Integer y) ‐> x*y"
      }, {
        "code": "D",
        "value": "(left,right) ‐> {return \"null\";}"
      }, {
        "code": "E",
        "value": "All of these are valid."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "42. A. Option A is the invalid lambda expression because the type is specified\nfor the variable j, but not the variable k. The rest of the options are valid\nlambda expressions. To be a valid lambda expression, the type must be\nspecified for all of the variables, as in option C, or none of them, as in\noptions B and D."
      }
    },
    "43": {
      "nbr": 43,
      "value": "What is the output of the following application?\npackage exercise;\nimport java.util.*;\npublic class Concat {\npublic String concat1(List<String> values) {\nreturn values.parallelStream()\n.reduce(\"a\",\n(x,y)->x+y,\nString::concat);\n}\npublic String concat2(List<String> values) {\nreturn values.parallelStream()\n.reduce((w,z)->z+w).get();\n}\npublic static void main(String… questions) {\nConcat c = new Concat();\nvar list = List.of(\"Cat\",\"Hat\");\nString x = c.concat1(list);\nString y = c.concat2(list);\nSystem.out.print(x+\" \"+y);\n} }",
      "responses": [{
        "code": "A",
        "value": "CatHat CatHat"
      }, {
        "code": "B",
        "value": "aCataHat HatCat"
      }, {
        "code": "C",
        "value": "The code does not compile because the stream in concat1() returns an\nOptional."
      }, {
        "code": "D",
        "value": "The code does not compile for a different reason."
      }, {
        "code": "E",
        "value": "An exception is printed at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "43. B. The code compiles and runs without issue. The three‐argument\nreduce() method returns a generic type, while the one‐argument reduce()\nmethod returns an Optional. The concat1() method is passed an identity\n\"a\", which it applies to each element, resulting in the reduction to\naCataHat. The lambda expression in the concat2() method reverses the\norder of its inputs, leading to a value of HatCat. For these reasons, option B\nis the correct answer."
      }
    },
    "44": {
      "nbr": 44,
      "value": "Which of the following three functional interfaces is not equivalent to the\nother two?",
      "responses": [{
        "code": "A",
        "value": "BiFunction<Double,Double,Double>"
      }, {
        "code": "B",
        "value": "BinaryOperator<Double>"
      }, {
        "code": "C",
        "value": "DoubleFunction<Double>"
      }, {
        "code": "D",
        "value": "None of the above. All three are equivalent."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "44. C. BiFunction<Double,Double,Double> and BinaryOperator<Double>\nboth take two Double input arguments and return a Double value, making\nthem equivalent to one another. On the other hand,\nDoubleFunction<Double> takes a single double value and returns a Double\nvalue. For this reason, it is different from the other two, making option C\ncorrect and option D incorrect."
      }
    },
    "45": {
      "nbr": 45,
      "value": "Given the following code snippet, what changes should be made for the\nJVM to correctly process this as a concurrent reduction? (Choose two.)\nvar w = Stream.of(\"c\",\"a\",\"t\")\n.collect(HashSet::new, Set::add, Set::addAll);\nSystem.out.println(w);",
      "responses": [{
        "code": "A",
        "value": "Replace HashSet with LinkedHashSet."
      }, {
        "code": "B",
        "value": "Mark the stream parallel."
      }, {
        "code": "C",
        "value": "Remove the second argument of the collect() method."
      }, {
        "code": "D",
        "value": "Remove the third argument of the collect() method."
      }, {
        "code": "E",
        "value": "Replace HashSet with ConcurrentSkipListSet."
      }, {
        "code": "F",
        "value": "Mark the stream unordered."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "45. B,E. For a concurrent reduction, the underlying type should be a threadsafe\ncollection. For this reason, option A is incorrect and option E is\ncorrect. The streams must all be parallel, making option B correct and\noption F incorrect. Options C and D are incorrect, as there is no twoargument\nversion of collect() within the Stream interface."
      }
    },
    "46": {
      "nbr": 46,
      "value": "Fill in the blank so this code outputs three lines:\nvar list = new ArrayList<String>();\nlist.add(\"Atlanta\");\nlist.add(\"Chicago\");\nlist.add(\"New York\");\nlist.stream()\n.filter(__________)\n.forEach(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "String::isEmpty"
      }, {
        "code": "B",
        "value": "! String::isEmpty"
      }, {
        "code": "C",
        "value": "String::! isEmpty"
      }, {
        "code": "D",
        "value": "String::isNotEmpty"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "46. E. Option A is the only one of the three options to compile. However, it\nresults in no lines being output since none of the three strings is empty.\nOptions B and C do not even compile because a method reference cannot\nhave an operator next to it. Option D does not compile because String does\nnot have an isNotEmpty() method. Therefore, option E is correct."
      }
    },
    "47": {
      "nbr": 47,
      "value": "What does the following output?\nvar chars = Stream.generate(() -> 'a');\nchars.filter(c -> c < 'b')\n.sorted()\n.findFirst()\n.ifPresent(System.out::print);",
      "responses": [{
        "code": "A",
        "value": "a"
      }, {
        "code": "B",
        "value": "The code runs successfully without any output."
      }, {
        "code": "C",
        "value": "The code does not complete."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "47. C. The source of this stream is infinite. Sorting something infinite never\nfinishes, so the stream pipeline never completes. This corresponds to option\nC."
      }
    },
    "48": {
      "nbr": 48,
      "value": "What is the expected output of the following code snippet?\nStream.iterate(1, x -> x + 1)\n.limit(5)\n.skip(2)\n.peek(System.out::print)\n.collect(Collectors.toList())\n.forEach(System.out::print);",
      "responses": [{
        "code": "A",
        "value": "It does not compile."
      }, {
        "code": "B",
        "value": "It throws an exception at runtime."
      }, {
        "code": "C",
        "value": "It does not print any output at runtime."
      }, {
        "code": "D",
        "value": "345345"
      }, {
        "code": "E",
        "value": "334455"
      }, {
        "code": "F",
        "value": "The behavior of the code snippet cannot be determined until runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "48. D. The code compiles and does not throw any exception at runtime, so\noptions A and B are incorrect. The code snippet is serial, by default, so the\norder is predictable, making option F incorrect. The peek() method\nexecutes on each member of the pipeline, printing five numbers as the\nelements are then collected into a List, which gives us 345. They are then\nprinted again, making the final output 345345 and option D correct."
      }
    },
    "49": {
      "nbr": 49,
      "value": "What is the output of the following program?\npackage ai;\nimport java.util.function.*;\npublic class Android {\npublic void wakeUp(Supplier supplier) { //\nd1\nsupplier.get();\n}\npublic static void main(String… electricSheep) {\nAndroid data = new Android();\ndata.wakeUp(() -> System.out.print(\"Started!\")); //\nd2\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Started!"
      }, {
        "code": "B",
        "value": "The code does not compile because of line d1 only."
      }, {
        "code": "C",
        "value": "The code does not compile because of line d2 only."
      }, {
        "code": "D",
        "value": "The code does not compile because of both lines d1 and d2."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "49. C. The program does not compile, so option A is incorrect. The Supplier\nfunctional interface normally takes a generic argument, although generic\ntypes are not strictly required, since they are removed by the compiler.\nTherefore, line d1 compiles while triggering a compiler warning, and\noptions B and D are incorrect. On the other hand, line d2 does cause a\ncompiler error, because the lambda expression does not return a value.\nTherefore, it is not compatible with Supplier, making option C the correct\nanswer."
      }
    },
    "50": {
      "nbr": 50,
      "value": "Given the following code snippet, what statement about the values printed\non lines p1 and p2 is correct?\nvar db = Collections.synchronizedList(new ArrayList<>());\nIntStream.range(1,6)\n.parallel()\n.map(i -> {db.add(i); return i;})\n.forEachOrdered(System.out::print); // p1\nSystem.out.println();\ndb.forEach(System.out::print); // p2",
      "responses": [{
        "code": "A",
        "value": "They are always the same."
      }, {
        "code": "B",
        "value": "They are sometimes the same."
      }, {
        "code": "C",
        "value": "They are never the same."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code will produce a ConcurrentModificationException at\nruntime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "50. B. First, the class uses a synchronized list, which is thread‐safe and allows\nmodification from multiple threads, making option E incorrect. The process\ngenerates a stream of numbers from 1 to 5 and sends them into a parallel\nstream where the map() is applied, possibly out of order. This results in\nelements being written to db in a random order. The stream then applies the\nforEachOrdered() method to its elements, which will force the parallel\nstream into a single‐threaded state. At runtime, line p1 will print the results\nin order every time as 12345. On the other hand, since the elements were\nadded to db in a random order, the output of line p2 is random and cannot\nbe predicted ahead of time. Since the results may sometimes be the same,\noption B is the correct answer. Part of the reason that the results are\nindeterminate is that the question uses a stateful lambda expression, which,\nbased on your studies, should be avoided!"
      }
    },
    "51": {
      "nbr": 51,
      "value": "Fill in the blanks so this code prints *8.0‐8.0*? (Choose two.)\nvar ints = IntStream.of(6, 10);\nvar longs = ints.mapToLong(i -> i);\nvar first = longs.________________;\nvar moreLongs = LongStream.of(6, 10);\nvar stats = moreLongs.summaryStatistics();\nvar second = _____________________;\nSystem.out.println(\"*\" + first + \"-\" + second + \"*\");",
      "responses": [{
        "code": "A",
        "value": "averageAsDouble() in the first blank"
      }, {
        "code": "B",
        "value": "average().getAsDouble() in the first blank"
      }, {
        "code": "C",
        "value": "getAverage().get() in the first blank"
      }, {
        "code": "D",
        "value": "stats.average() in the second blank"
      }, {
        "code": "E",
        "value": "stats.average().get() in the second blank"
      }, {
        "code": "F",
        "value": "stats.getAverage() in the second blank"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "51. B,F. Primitive streams, like LongStream, declare an average() method\nthat returns an OptionalDouble object. This object declares a\ngetAsDouble() method rather than a get() method. Therefore, option A is\nincorrect, and option B is correct.\nBy contrast, the summary statistics classes provide getters in order to access\nthe data. The getAverage() method returns a double and not an\nOptionalDouble, which makes option F correct. The other options do not\ncompile."
      }
    },
    "52": {
      "nbr": 52,
      "value": "Starting with DoubleConsumer and going downward, fill in the missing\nvalues for the table.\nFunctional Interface # Parameters in Method Signature\nDoubleConsumer\nIntFunction\nLongSupplier\nObjDoubleConsumer",
      "responses": [{
        "code": "A",
        "value": "0, 1, 1, 1"
      }, {
        "code": "B",
        "value": "0, 1, 0, 2"
      }, {
        "code": "C",
        "value": "0, 2, 1, 2"
      }, {
        "code": "D",
        "value": "1, 1, 0, 2"
      }, {
        "code": "E",
        "value": "1, 1, 1, 1"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "52. D. Remember that all Supplier interfaces take zero parameters. For this\nreason, the third value in the table is 0, making options A, C, and E\nincorrect. Next, DoubleConsumer and IntFunction each take one value,\ndouble and int, respectively. On the other hand, ObjDoubleConsumer takes\ntwo values, a generic value and a double, and returns void. For this reason,\noption D is correct, and option B is incorrect."
      }
    },
    "53": {
      "nbr": 53,
      "value": "Starting with DoubleConsumer and going downward, fill in the values for\nthe table. For the following choices, assume R is a generic type.\nFunctional Interface Return Type\nDoubleConsumer\nIntFunction\nLongSupplier\nObjDoubleConsumer",
      "responses": [{
        "code": "A",
        "value": "double, int, long, R"
      }, {
        "code": "B",
        "value": "double, R, long, R"
      }, {
        "code": "C",
        "value": "R, int, long, R"
      }, {
        "code": "D",
        "value": "R, int, long, void"
      }, {
        "code": "E",
        "value": "void, int, R, void"
      }, {
        "code": "F",
        "value": "void, R, long, void"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "53. F. All Consumer functional interfaces have a void return type. For this\nreason, the first and last values in the table are both void, making options\nA, B and C incorrect. IntFunction takes an int and returns a generic\nvalue, ruling out option D. Finally, LongSupplier does not take any values\nand returns a long value. For this reason, option E is incorrect, and option F\nis correct."
      }
    },
    "54": {
      "nbr": 54,
      "value": "What is a possible output of the following application?\npackage salvage;\nimport java.util.*;\nimport java.util.stream.*;\npublic class Car {\nprivate String model;\nprivate int year;\n@Override public String toString() {return model;}\n// Constructor/Getters/Setters Omitted\npublic static void main(String… make) {\nvar cars = new ArrayList<Car>();\ncars.add(new Car(\"Mustang\",1967));\ncars.add(new Car(\"Thunderbird\",1967));\ncars.add(new Car(\"Escort\",1975));\nvar map = cars\n.stream()\n.collect(\nCollectors.groupingByConcurrent(Car::getYear));\nSystem.out.print(map);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "{1975=[Escort], 1967=[ Mustang, Thunderbird]}"
      }, {
        "code": "B",
        "value": "{Escort=[1975], Thunderbird=[1967], Mustang=[1967]}"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code hangs indefinitely at runtime."
      }, {
        "code": "E",
        "value": "The application throws an exception at runtime because the stream is\nnot parallel."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "54. A. The code compiles and runs without issue. The JVM will fall back to a\nsingle‐threaded process if all of the conditions for performing the parallel\nreduction are not met. The stream used in the main() method is not parallel,\nbut the groupingByConcurrent() method can still be applied without\nthrowing an exception at runtime. Although performance will suffer from\nnot using a parallel stream, the application will still process the results\ncorrectly. Since the process groups the data by year, option A is the correct\nanswer."
      }
    },
    "55": {
      "nbr": 55,
      "value": "How many lines does this code output?\nvar list = new LinkedList<String>();\nlist.add(\"Archie\");\nlist.add(\"X-Men\");\nlist.stream().forEach(System.out.println);\nlist.stream().forEach(System.out.println);",
      "responses": [{
        "code": "A",
        "value": "Two."
      }, {
        "code": "B",
        "value": "Four."
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "55. C. This code is almost correct. Calling two different streams is allowed.\nThe code attempts to use a method reference when calling the forEach()\nmethod. However, it does not use the right syntax for a method reference. A\ndouble colon needs to be used. The code would need to be changed to\nSystem.out::println to work and print two lines for each call. Since it\ndoes not compile, option C is correct."
      }
    },
    "56": {
      "nbr": 56,
      "value": "Which lambda expression can replace the instance of new\nBiologyMaterial() in the Scientist class and produce the same results\nunder various inputted values?\npackage university;\n@FunctionalInterface interface Study {\nabstract int learn(String subject, int duration);\n}\nclass BiologyMaterial implements Study {\n@Override public int learn(String subject, int duration)\n{\nif(subject == null)\nreturn duration;\nelse\nreturn duration+1;\n}\n}\npublic class Scientist {\npublic static void main(String[] courses) {\nfinal Study s = new BiologyMaterial();\nSystem.out.print(s.learn(courses[0],\nInteger.parseInt(courses[1])));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "(p,q) ‐> q==null ? p : p+1"
      }, {
        "code": "B",
        "value": "(c,d) ‐> {int d=1; return c!=null ? d+1 : d;}"
      }, {
        "code": "C",
        "value": "(x,y) ‐> {return x==null ? y : y+1;}"
      }, {
        "code": "D",
        "value": "(a,b) ‐> 1"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "56. C. First, option A does not compile, since the variables p and q are\nreversed, making the return type of the method and usage of operators\ninvalid. The first argument p is a String and q is an int, but the lambda\nexpression reverses them, and the code does not compile. Option B also\ndoes not compile. The variable d is declared twice, first in the lambda\nargument list and then in the body of the lambda expression. The second\ndeclaration in the body of the lambda expression causes the compiler to\ngenerate a duplicate local variable message. Note that other than it being\nused twice, the expression is valid; the ternary operator is functionally\nequivalent to the learn() method in the BiologyMaterial class. Option C\nis the correct answer since it compiles and handles the input in the same\nway as the learn() method in the BiologyMaterial class. Option D\ncompiles but does not return the same result."
      }
    },
    "57": {
      "nbr": 57,
      "value": "What is true of the following? (Choose two.)\nvar s = Stream.of(\"speak\", \"bark\", \"meow\", \"growl\");\nBinaryOperator<String> merge = (a, b) -> a;\nvar map = s.collect(toMap(String::length, k -> k, merge));\nSystem.out.println(map.size() + \" \" + map.get(4));",
      "responses": [{
        "code": "A",
        "value": "The output is 2 bark."
      }, {
        "code": "B",
        "value": "The output is 2 meow."
      }, {
        "code": "C",
        "value": "The output is 4 bark."
      }, {
        "code": "D",
        "value": "The output is 4 meow."
      }, {
        "code": "E",
        "value": "If \"meow\" was replaced by a null reference, the output would remain\nthe same."
      }, {
        "code": "F",
        "value": "If \"meow\" was replaced by a null reference, the output would change."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "F"
        ],
        "explanation": "57. A,F. This code does compile. Remember that imports are implied,\nincluding the static import for Collectors. The collector tries to use the\nnumber of characters in each stream element as the key in a map. This\nworks fine for the first two elements, speak and bark, because they are of\nlength 5 and 4, respectively. When it gets to meow, it sees another key of 4.\nThe merge function says to use the first one, so it chooses bark for the\nvalue. Similarly, growl is 5 characters, but the first value of speak is used.\nThere are only two distinct lengths, so option A is correct.\nIf the stream had a null instead of \"meow\", the code would throw a\nNullPointerException, since we need to check the length of the String to\ndetermine which part of the Map it goes in. Since you cannot call a method\non null, option F is correct."
      }
    },
    "58": {
      "nbr": 58,
      "value": "Which statement about a source in a Stream is true?",
      "responses": [{
        "code": "A",
        "value": "The source is mandatory in a stream pipeline."
      }, {
        "code": "B",
        "value": "The source is only allowed to return primitives."
      }, {
        "code": "C",
        "value": "The source must be retrieved by calling the stream() method."
      }, {
        "code": "D",
        "value": "The source must return a finite number of elements."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "58. A. Option A is correct as the source and terminal operation are mandatory\nparts of a stream pipeline. Option B is incorrect because a Stream must\nreturn objects. Specialized interfaces like IntStream are needed to return\nprimitives. Option C is incorrect because Stream has methods such as of()\nand iterate() that return a Stream. Option D is incorrect because infinite\nstreams are possible."
      }
    },
    "59": {
      "nbr": 59,
      "value": "Given an IntStream, which method would you use to obtain an equivalent\nparallel Stream<T>?",
      "responses": [{
        "code": "A",
        "value": "parallel()"
      }, {
        "code": "B",
        "value": "parallelStream()"
      }, {
        "code": "C",
        "value": "parallels()"
      }, {
        "code": "D",
        "value": "getParallel()"
      }, {
        "code": "E",
        "value": "getParallelStream()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "59. F. Trick question! The correct method to obtain an equivalent parallel\nstream of an existing IntStream is parallel(), but for an IntStream this\nreturns another IntStream, not a generic Stream<T>. For this reason, option\nF is correct."
      }
    },
    "60": {
      "nbr": 60,
      "value": "Which can fill in the blank to have the code print true?\nvar stream = Stream.iterate(1, i -> i+1);\nvar b = stream.________(i -> i> 5);\nSystem.out.println(b);",
      "responses": [{
        "code": "A",
        "value": "anyMatch"
      }, {
        "code": "B",
        "value": "allMatch"
      }, {
        "code": "C",
        "value": "noneMatch"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "60. A. This code generates an infinite stream of integers: 1, 2, 3, 4, 5, 6, 7, etc.\nThe Predicate checks if the element is greater than 5. With anyMatch(),\nthe stream pipeline ends once element 6 is hit, and the code prints true. For\nthe allMatch() operator, it sees that the first element in the stream does not\nmatch, and the code prints false. Similarly, the noneMatch() operator gets\nto the point where i is 6 and returns false because there is a match.\nTherefore, option A is correct."
      }
    },
    "61": {
      "nbr": 61,
      "value": "Which of the following fills in the blank so that the code outputs one line\nbut uses a poor practice?\nimport java.util.*;\npublic class Cheater {\nint count = 0;\npublic void sneak(Collection<String> coll) {\ncoll.stream()._____________________________;\n}\npublic static void main(String[] args) {\nvar c = new Cheater();\nc.sneak(Arrays.asList(\"weasel\"));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "peek(System.out::println)"
      }, {
        "code": "B",
        "value": "peek(System.out::println).findFirst()"
      }, {
        "code": "C",
        "value": "peek(r ‐> System.out.println(r)).findFirst()"
      }, {
        "code": "D",
        "value": "peek(r ‐> {count++; System.out.println(r); }).findFirst()"
      }, {
        "code": "E",
        "value": "None of the above compile."
      }, {
        "code": "F",
        "value": "None of these are bad practice."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "61. D. Option A is incorrect because it doesn't print out one line. The peek()\nmethod is an intermediate operation. Since there is no terminal operation,\nthe stream pipeline is not executed, so the peek() method is never\nexecuted, and nothing is printed. Options B and C are incorrect because\nthey correctly output one line using a method reference and lambda,\nrespectively, and don't use any bad practices. Option D is the correct\nanswer. It does output one line. However, it is bad practice to have a peek()\nmethod that has side effects like modifying a variable."
      }
    },
    "62": {
      "nbr": 62,
      "value": "What is the output of the following application?\npackage nesting;\nimport java.util.function.*;\npublic class Doll {\nprivate int layer;\npublic Doll(int layer) {\nsuper();\nthis.layer = layer;\n}\npublic static void open(\nUnaryOperator<Doll> task, Doll doll) {\nwhile((doll = task.accept(doll)) != null) {\nSystem.out.print(\"X\");\n}\n}\npublic static void main(String[] wood) {\nopen(s -> {\nif(s.layer<=0) return null;\nelse return new Doll(s.layer--);\n}, new Doll(5));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "XXXXX"
      }, {
        "code": "B",
        "value": "The code does not compile because of the lambda expression."
      }, {
        "code": "C",
        "value": "The code does not compile for a different reason."
      }, {
        "code": "D",
        "value": "The code compiles, but produces an infinite loop at runtime."
      }, {
        "code": "E",
        "value": "The code compiles, but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "62. C. The code does not compile, so option A, D, and E are incorrect. The\nlambda expression compiles without issue, making option B incorrect. The\ntask variable is of type UnaryOperator<Doll>, with the abstract method\napply(). There is no accept() method defined on that interface, therefore\nthe code does not compile, and option C is the correct answer. If the code\nwas corrected to use the apply() method, the rest of it would compile\nwithout issue. At runtime, it would then produce an infinite loop. On each\niteration of the loop, a new Doll instance would be created with 5, since the\npost‐decrement (‐‐) operator returns the original value of the variable, and\nthat would be option D."
      }
    },
    "63": {
      "nbr": 63,
      "value": "What is the expected output of the following code snippet?\nRandom r = new Random();\nStream.generate(r::nextDouble)\n.skip(2)\n.limit(4)\n.sorted()\n.peek(System.out::println)\n.forEach(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "It does not compile."
      }, {
        "code": "B",
        "value": "It throws an exception at runtime."
      }, {
        "code": "C",
        "value": "It does not print any output at runtime."
      }, {
        "code": "D",
        "value": "It prints four numbers twice each."
      }, {
        "code": "E",
        "value": "It can print up to eight distinct numbers."
      }, {
        "code": "F",
        "value": "The behavior of the code snippet cannot be determined until runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "63. D. The code compiles and does not throw any exception at runtime, so\noptions A and B are incorrect. As an element goes through the pipeline, it is\nprinted once by the peek() method, then once by the forEach() method.\nFor example, 0.1 0.1 0.54 0.54 0.6 0.6 0.3 0.3 is a possible output\nfrom this code. For this reason, option D is correct."
      }
    },
    "64": {
      "nbr": 64,
      "value": "Which statements about the findAny() method applied to a stream are\ncorrect? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "It always returns the first element on an ordered serial stream."
      }, {
        "code": "B",
        "value": "It may return any element on an ordered serial stream."
      }, {
        "code": "C",
        "value": "It always returns the first element on an unordered stream."
      }, {
        "code": "D",
        "value": "It may return any element on an unordered stream."
      }, {
        "code": "E",
        "value": "It always returns the first element on an ordered parallel stream."
      }, {
        "code": "F",
        "value": "It may return any element on an ordered parallel stream."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "F"
        ],
        "explanation": "64. B,D,F. The findAny() method is capable to return any element of the\nstream regardless of whether it is serial, parallel, ordered, or unordered. For\nthis reason, options B, D, and F are correct. Option C is actually invalid, as\nan unordered stream does not have a first element."
      }
    },
    "65": {
      "nbr": 65,
      "value": "Which functional interface has a get() method?",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Function"
      }, {
        "code": "C",
        "value": "Supplier"
      }, {
        "code": "D",
        "value": "UnaryOperator"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "65. C. To begin with, Consumer uses accept(), making option A incorrect.\nNext, Function and UnaryOperator use apply(), making options B and D,\nrespectively, incorrect. Finally, Supplier uses get(), making option C the\ncorrect answer."
      }
    },
    "66": {
      "nbr": 66,
      "value": "Why can't String::charAt be used as a method reference within a\nFunction?",
      "responses": [{
        "code": "A",
        "value": "Method references can only be used on static methods."
      }, {
        "code": "B",
        "value": "The charAt() method takes an int rather than Integer parameter."
      }, {
        "code": "C",
        "value": "The method reference is not compatible with Function."
      }, {
        "code": "D",
        "value": "The method reference syntax is illegal."
      }, {
        "code": "E",
        "value": "There is no charAt() method in the String class."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "66. C. Option D is incorrect as the syntax is fine. Option E is incorrect\nbecause there is a charAt() instance method. While option B is correct that\nthe method takes in an int parameter, autoboxing would take care of\nconversion for us if there were no other problems. So, option B is not the\nanswer either. Option A is not true because there are constructor and\ninstance method references. This method reference could be assigned to\nBiFunction<String,Integer, Character>. However, it cannot be\nassigned to a Function. This makes option C the correct answer."
      }
    },
    "67": {
      "nbr": 67,
      "value": "Given the following independent stream operations, which statements are\ncorrect? (Choose three.)\nList.of(2,4,6,8)\n.parallel()\n.parallelStream()\n.forEach(System.out::print);\nList.of(2,4,6,8)\n.parallelStream()\n.parallel()\n.forEach(System.out::print);\nList.of(2,4,6,8)\n.parallelStream()\n.parallel().parallel().parallel()\n.forEach(System.out::print);",
      "responses": [{
        "code": "A",
        "value": "The first stream operation compiles."
      }, {
        "code": "B",
        "value": "The second stream operation compiles."
      }, {
        "code": "C",
        "value": "The third stream operation compiles."
      }, {
        "code": "D",
        "value": "None of the stream operations that compile produce an exception at\nruntime."
      }, {
        "code": "E",
        "value": "At least one of the stream operations that compiles produces at\nexception at runtime."
      }, {
        "code": "F",
        "value": "The output of the stream operations that compile is consistent between\nexecutions."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "D"
        ],
        "explanation": "67. B,C,D. While the second and third stream operations compile, the first\ndoes not. The parallel() method should be applied to a stream, while the\nparallelStream() method should be applied to a Collection<E>. For this\nreason, option A is incorrect, and options B and C are correct. Neither the\nsecond or third stream operation are expected to produce an exception at\nruntime, making option D correct and option E incorrect. Note that calling\nparallel() on an already parallel stream is unnecessary but allowed.\nFinally, the output of the second and third stream operations will vary at\nruntime since the streams are parallel, making option F incorrect."
      }
    },
    "68": {
      "nbr": 68,
      "value": "Which method reference can replace the lambda on the first line so the\noutput is the same?\nBiPredicate<String, String> pred = (a, b) -> a.contains(b);\nSystem.out.println(pred.test(\"fish\", \"is\"));",
      "responses": [{
        "code": "A",
        "value": "a::contains(b)"
      }, {
        "code": "B",
        "value": "a::contains"
      }, {
        "code": "C",
        "value": "String::contains(b)"
      }, {
        "code": "D",
        "value": "String::contains"
      }, {
        "code": "E",
        "value": "The supplied code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "68. D. Since the code uses a BiPredicate, it takes two parameters in the\ntest() call. The first is the instance of String and the second is the\nsubstring value to check. Since both parameters are passed in, we use the\ntype of String in the method reference, making option D the correct\nanswer."
      }
    },
    "69": {
      "nbr": 69,
      "value": "What is the result of the following?\nimport static java.util.stream.Collectors.*;\nimport java.util.stream.Stream;\nclass Ballot {\nprivate String name;\nprivate int judgeNumber;\nprivate int score;\npublic Ballot(String name, int judgeNumber, int score) {\nthis.name = name;\nthis.judgeNumber = judgeNumber;\nthis.score = score;\n}\n// all getters and setters\n}\npublic class Speaking {\npublic static void main(String[] args) {\nStream<Ballot> ballots = Stream.of(\nnew Ballot(\"Mario\", 1, 10),\nnew Ballot(\"Christina\", 1, 8),\nnew Ballot(\"Mario\", 2, 9),\nnew Ballot(\"Christina\", 2, 8)\n);\nvar scores = ballots.collect(\ngroupingBy(Ballot::getName,\nsummingInt(Ballot::getScore)));\nSystem.out.println(scores.get(\"Mario\"));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "2"
      }, {
        "code": "B",
        "value": "18"
      }, {
        "code": "C",
        "value": "19"
      }, {
        "code": "D",
        "value": "110"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "69. C. This code compiles. It creates a stream of Ballot objects. Then it\ncreates a map with the contestant's name as the key and the sum of the\nscores as the value. For Mario, this is 10 + 9, or 19, so option C is correct."
      }
    },
    "70": {
      "nbr": 70,
      "value": "Which of the following can fill in the blank to have the code print 44?\nvar stream = Stream.of(\"base\", \"ball\");\nstream.______(s -> s.length()).forEach(System.out::print);",
      "responses": [{
        "code": "A",
        "value": "Only map"
      }, {
        "code": "B",
        "value": "Only mapToInt"
      }, {
        "code": "C",
        "value": "Only mapToObject"
      }, {
        "code": "D",
        "value": "Both map and mapToInt"
      }, {
        "code": "E",
        "value": "Both map and mapToObject"
      }, {
        "code": "F",
        "value": "map, mapToInt, and mapToObject"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "70. D. The map() method can fill in the blank. The lambda converts a String\nto an int, and Java uses autoboxing to turn that into an Integer. The\nmapToInt() method can also fill in the blank, and Java doesn't even need to\nautobox. There isn't a mapToObject() in the stream API. Note there is a\nsimilarly named mapToObj() method on IntStream. Since both map() and\nmapToInt() work here, option D is correct."
      }
    },
    "71": {
      "nbr": 71,
      "value": "What does the following do? (Choose two.)\npublic class Shoot {\ninterface Target {\nboolean needToAim(double angle);\n}\nstatic void prepare(double angle, Target t) {\nboolean ready = t.needToAim(angle); // k1\nSystem.out.println(ready);\n}\npublic static void main(String[] args) {\nprepare(45, d -> d> 5 || d < -5); // k2\n}\n}",
      "responses": [{
        "code": "A",
        "value": "If any compiler errors are fixed, it prints true."
      }, {
        "code": "B",
        "value": "If any compiler errors are fixed, it prints false."
      }, {
        "code": "C",
        "value": "It compiles without issue."
      }, {
        "code": "D",
        "value": "It doesn't compile due to line k1."
      }, {
        "code": "E",
        "value": "It doesn't compile due to line k2."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "71. A,C. This is a correct example of code that uses a lambda. The interface\nhas a single abstract method. The lambda correctly takes one double\nparameter and returns a boolean. This matches the interface. The lambda\nsyntax is correct. Since it compiles, option C is correct. Finally, option A is\ncorrect because 45 is greater than 5."
      }
    },
    "72": {
      "nbr": 72,
      "value": "Which statements about the following code are correct?\nvar data = List.of(1,2,3);\nint f = data.parallelStream()\n.reduce(1, (a,b) -> a+b, (a,b) -> a+b);\nSystem.out.println(f);",
      "responses": [{
        "code": "A",
        "value": "It consistently prints 6."
      }, {
        "code": "B",
        "value": "It consistently prints 7."
      }, {
        "code": "C",
        "value": "It consistently prints another value."
      }, {
        "code": "D",
        "value": "It does not consistently print the same value on every execution."
      }, {
        "code": "E",
        "value": "It compiles but throws an exception at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "72. C. The reduction is parallel, but since the accumulator and combiner are\nwell‐behaved (stateless and associative), the result is consistent, making\noption D incorrect. The identity is 1, which is applied to every element\nmeaning the operation sums the values (1+1), (1+2), and (1+3). For this\nreason, 9 is consistently printed at runtime, making option C correct."
      }
    },
    "73": {
      "nbr": 73,
      "value": "What is the result of the following?\n11: var s1 = IntStream.empty();\n12: System.out.print(s1.average().getAsDouble());\n13:\n14: var s2 = IntStream.of(-1,0, 1);\n15: System.out.print(s2.average().getAsDouble());",
      "responses": [{
        "code": "A",
        "value": "Both statements print 0."
      }, {
        "code": "B",
        "value": "Both statements print 0.0."
      }, {
        "code": "C",
        "value": "The statements print different values."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "73. E. The average() method returns an OptionalDouble. This interface has a\ngetAsDouble() method rather than a get() method, so the code does\ncompile. However, the stream is empty, so the optional is also empty. When\ntrying to get the value on line 12, the code throws a\nNoSuchElementException, making option E correct."
      }
    },
    "74": {
      "nbr": 74,
      "value": "Which lambdas can replace the method references in this code? (Choose\ntwo.)\nStream.of(\"fish\", \"mammal\", \"amphibian\")\n.map(String::length)\n.findFirst()\n.ifPresent(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "x.length()"
      }, {
        "code": "B",
        "value": "x ‐> x.length()"
      }, {
        "code": "C",
        "value": "x ‐> x::length"
      }, {
        "code": "D",
        "value": "System.out.println(s)"
      }, {
        "code": "E",
        "value": "s ‐> System.out.println(s)"
      }, {
        "code": "F",
        "value": "s ‐> System.out::println"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "74. B,E. Options A and D are incorrect since they are missing the arrow (‐>),\nwhich makes them lambdas. Options C and F are incorrect as they try to\nmix lambdas and method references. This leaves options B and E as the\nanswers."
      }
    },
    "75": {
      "nbr": 75,
      "value": "What collector can turn the stream at left to the Map at right?",
      "responses": [{
        "code": "A",
        "value": "Only grouping()"
      }, {
        "code": "B",
        "value": "Only groupingBy()"
      }, {
        "code": "C",
        "value": "Only partitioning()"
      }, {
        "code": "D",
        "value": "Only partitioningBy()"
      }, {
        "code": "E",
        "value": "Both grouping() and partitioning()"
      }, {
        "code": "F",
        "value": "Both groupingBy() and partitioningBy()"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "75. F. Both Collectors.groupingBy() and Collectors.partitioningBy()\nare useful for turning a stream into a Map. The other two methods do not\nexist. The partitioningBy() method automatically groups using a Boolean\nkey. However, we can also have a Boolean key with groupingBy(). For\nexample, we could write s ‐> s.length() > 3. Therefore, option F is\ncorrect."
      }
    },
    "76": {
      "nbr": 76,
      "value": "Which expression is compatible with the IntSupplier functional interface?",
      "responses": [{
        "code": "A",
        "value": "() ‐> 1<10 ? \"3\" : 4"
      }, {
        "code": "B",
        "value": "() ‐> {return 1/0;}"
      }, {
        "code": "C",
        "value": "() ‐> return 4"
      }, {
        "code": "D",
        "value": "System.out::print"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "76. B. Option A is incorrect because \"3\" is a String, which is not compatible\nwith the return type int required for IntSupplier. Option B is the correct\nanswer. Although this will result in a divide‐by‐zero issue at runtime, the\nlambda is valid and compatible with IntSupplier. Option C is incorrect\nbecause the lambda expression is invalid. The return statement is allowed\nonly inside a set of braces ({}). Finally, option D is incorrect. The method\nreference is used for Consumer, not Supplier, since it takes a value and\ndoes not return anything."
      }
    },
    "77": {
      "nbr": 77,
      "value": "What is the output of the following application?\npackage beach;\nimport java.util.function.*;\nclass Tourist {\npublic Tourist(double distance) {\nthis.distance = distance;\n}\npublic double distance;\n}\npublic class Lifeguard {\nprivate void saveLife(Predicate<Tourist> canSave,\nTourist tourist) {\nSystem.out.print(canSave.test(tourist)\n? \"Saved\" : \"Too far\");\n}\npublic final static void main(String… sand) {\nnew Lifeguard().saveLife(s -> s.distance<4,\nnew Tourist(2));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Saved"
      }, {
        "code": "B",
        "value": "Too far"
      }, {
        "code": "C",
        "value": "The code does not compile because of the main() method."
      }, {
        "code": "D",
        "value": "The code does not compile because of the saveLife() method."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "77. A. The code compiles without issue, so options C and D are incorrect. The\nvalue for distance is 2, which based on the lambda for the Predicate will\nresult in a true expression, and Saved will be printed, making option A\ncorrect."
      }
    },
    "78": {
      "nbr": 78,
      "value": "Given a LinkedList<E>, which method would you call to obtain a parallel\nstream that uses it as a data source?",
      "responses": [{
        "code": "A",
        "value": "getParallel()"
      }, {
        "code": "B",
        "value": "parallels()"
      }, {
        "code": "C",
        "value": "getParallelStream()"
      }, {
        "code": "D",
        "value": "parallel()"
      }, {
        "code": "E",
        "value": "parallelStream()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "78. E. The correct method to obtain a parallel stream from a Collection<E> is\nparallelStream(), making option E correct."
      }
    },
    "79": {
      "nbr": 79,
      "value": "How many lines does the following code output?\nimport java.util.*;\nclass Blankie {\nString color;\nString getColor() {\nreturn color;\n}\n}\npublic class PreSchool {\npublic static void main(String[] args) {\nvar b1 = new Blankie();\nvar b2 = new Blankie();\nb1.color = \"pink\";\nList<Blankie> list = Arrays.asList(b1, b2);\nlist.stream()\n.filter(Blankie::getColor) // line x\n.forEach(System.out::println); // line y\n}\n}",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "The code does not compile due to line x."
      }, {
        "code": "D",
        "value": "The code does not compile due to line y."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "79. C. The filter() method takes a Predicate, which requires a boolean\nreturn type from the lambda or method reference. The getColor() method\nreturns a String and is not compatible. This causes the code to not compile\nand option C to be the answer."
      }
    },
    "80": {
      "nbr": 80,
      "value": "Which are true statements? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "A source cannot return an infinite stream."
      }, {
        "code": "B",
        "value": "A source may return an infinite stream."
      }, {
        "code": "C",
        "value": "A source must return an infinite stream."
      }, {
        "code": "D",
        "value": "An intermediate operation cannot return an infinite stream."
      }, {
        "code": "E",
        "value": "An intermediate operation may return an infinite stream."
      }, {
        "code": "F",
        "value": "An intermediate operation must return an infinite stream."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "80. B,E. The generate() and iterate() sources return an infinite stream.\nFurther, the of() source returns a finite stream, which shows option B is\none of the answers.\nThe limit() intermediate operation returns a finite stream. When given an\ninfinite stream, the map() intermediate operations keeps the infinite stream,\nwhich means option E is the other correct answer."
      }
    },
    "81": {
      "nbr": 81,
      "value": "How many of these lines have compiler errors?\n14: Consumer<Object> c1 = ArrayList::new;\n15: Consumer<Object> c2 = String::new;\n16: Consumer<Object> c3 = System.out::println;\n17: var c4 = ArrayList::new;\n18: var c5 = String::new;\n19: var c6 = System.out::println;",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "Three."
      }, {
        "code": "D",
        "value": "Four."
      }, {
        "code": "E",
        "value": "Five."
      }, {
        "code": "F",
        "value": "The code compiles as is."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "81. E. Like a lambda, method references use type inference. When assigned to\na local variable, var cannot be used because there is not enough\ninformation to infer the type. Due to this, lines 17, 18, and 19 do not\ncompile.\nConsumer<Object> takes a single Object argument and does not return any\ndata. The classes ArrayList and String do not contain constructors that\ntake an Object, so lines 14 and 15 do not compile either. Line 16 does\nsupport an Object variable, since the System.out.println(Object)\nmethod exists. For these reasons, option E is the correct answer."
      }
    },
    "82": {
      "nbr": 82,
      "value": "What is the output of the following program?\nvar p = List.of(new StringBuilder(\"hello\"),\nnew StringBuilder(\"goodbye\"));\nvar q = p.parallelStream().reduce(0,\n(w,x) -> w.length() + x.length(),\n(y,z) -> y.length() + z.length());\nSystem.out.print(q);",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "12"
      }, {
        "code": "C",
        "value": "14"
      }, {
        "code": "D",
        "value": "One line does not compile."
      }, {
        "code": "E",
        "value": "Two lines do not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "82. E. Based on the reduction operation, the data types of w, y, and z are\nInteger, while the data type of x is StringBuilder. Since Integer does\nnot define a length() method, both the accumulator and combiner lambda\nexpressions are invalid, making option E correct."
      }
    },
    "83": {
      "nbr": 83,
      "value": "What is true of this code? (Choose two.)\nvar bools = Stream.of(Boolean.TRUE, null);\nvar map = bools\n.limit(1) // line k\n.collect(partitioningBy(b -> b));\nSystem.out.println(map);",
      "responses": [{
        "code": "A",
        "value": "It outputs {true=[true]}."
      }, {
        "code": "B",
        "value": "It outputs {false=null, true=[true]}."
      }, {
        "code": "C",
        "value": "It outputs {false=[], true=[true]}."
      }, {
        "code": "D",
        "value": "It outputs {false=[null], true=[true]}."
      }, {
        "code": "E",
        "value": "The output is the same if line k is removed."
      }, {
        "code": "F",
        "value": "The output is different after line k is removed."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "83. C,F. The first intermediate operation, limit(1), gets rid of the null. The\npartitioningBy() method returns a map with two keys, true and false,\nregardless of whether any elements actually match. If there are no matches,\nthe value is an empty list, making option C correct. If line k is removed, the\ncode throws a NullPointerException, since null is neither true nor\nfalse. Therefore, option F is the other answer."
      }
    },
    "84": {
      "nbr": 84,
      "value": "What is the output of the following code snippet?\nvar apples = List.of(1, 2);\nvar oranges = List.of(1, 2);\nfinal var count = Stream.of(apples, oranges)\n.flatMapToInt(List::stream)\n.peek(System.out::print)\n.count();\nSystem.out.print(count);",
      "responses": [{
        "code": "A",
        "value": "12124"
      }, {
        "code": "B",
        "value": "11224"
      }, {
        "code": "C",
        "value": "122"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but does not output anything at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "84. D. The code does not compile because flatMapToInt() requires a\nFunction with a return value of IntStream, not Stream, making option D\ncorrect."
      }
    },
    "85": {
      "nbr": 85,
      "value": "Which functional interface, when filled into the blank, prevents the class\nfrom compiling?\npackage morning;\nimport java.util.function.*;\npublic class Sun {\npublic static void dawn(___________ sunrise) {}\npublic void main(String… rays) {\ndawn(s -> s+1);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "DoubleUnaryOperator"
      }, {
        "code": "B",
        "value": "Function<String,String>"
      }, {
        "code": "C",
        "value": "IntToLongFunction"
      }, {
        "code": "D",
        "value": "UnaryOperator"
      }, {
        "code": "E",
        "value": "All of the above allow the code to compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "85. D. A lambda expression can match multiple functional interfaces. It\nmatches DoubleUnaryOperator, which takes a double value and returns a\ndouble value. Note that the data type of s+1 is double because one of the\noperands, in this case s, is double. It also matches\nFunction<String,String> since the addition (+) operator can be used for\nString concatenation. Finally, it matches IntToLongFunction, since the\nint value s+1 can be implicitly cast to long. On the other hand, the lambda\nexpression is not compatible with UnaryOperator without a generic type.\nWhen UnaryOperator is used without a generic argument, the type is\nassumed to be Object. Since the addition operator is not defined on Object,\nthe code does not compile due to the lambda expression body, making\noption D the correct answer. Note that if the lambda expression did not rely\non the addition operator, such as s ‐> s, then UnaryOperator would be\nallowed by the compiler, even without a generic type."
      }
    },
    "86": {
      "nbr": 86,
      "value": "Which statements about applying forEachOrdered() to a parallel ordered\nstream instead of using forEach() are correct? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "The operation will likely be faster."
      }, {
        "code": "B",
        "value": "The operation will likely be slower."
      }, {
        "code": "C",
        "value": "There is no expected change in performance."
      }, {
        "code": "D",
        "value": "It forces some stream operations in the pipeline to be performed in a\nserial manner."
      }, {
        "code": "E",
        "value": "It forces all stream operations in the pipeline to be performed in a\nserial manner."
      }, {
        "code": "F",
        "value": "All stream operations will continue to be performed in a parallel\nmanner."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "86. B,D. Applying forEachOrdered() to a parallel stream forces the terminal\noperation to be performed in a single‐threaded, rather than parallel, manner.\nFor this reason, it is likely that it will be slower, making option B correct.\nIntermediate operations can still take advantage of parallel processing, since\nforEachOrdered() is only applied at the end of the pipeline. For this\nreason, option D is correct."
      }
    },
    "87": {
      "nbr": 87,
      "value": "What is the true of the following? (Choose two.)\nIntegerSummaryStatistics stats = Stream.of(20, 40)\n.mapToInt(i -> i)\n.summaryStatistics();\nlong total = stats.getSum();\nlong count = stats.getCount();\nlong max = stats.getMax();\nSystem.out.println(total + \"-\" + count + \"-\" + max);",
      "responses": [{
        "code": "A",
        "value": "The output is 60‐0‐40"
      }, {
        "code": "B",
        "value": "The output is 60‐2‐40"
      }, {
        "code": "C",
        "value": "The code does not compile for one reason."
      }, {
        "code": "D",
        "value": "The code does not compile for two reasons."
      }, {
        "code": "E",
        "value": "Correct code could be written without summary statistics using a\nsingle stream pipeline."
      }, {
        "code": "F",
        "value": "Correct code could not be written without summary statics using a\nsingle stream pipeline."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "87. C,F. The code does not compile because the class should be\nIntSummaryStatistics, not IntegerSummaryStatistics. This makes\noption C correct. The purpose of using the summary statistics class is to\navoid multiple trips through the stream pipeline, making option F the other\nanswer."
      }
    },
    "88": {
      "nbr": 88,
      "value": "What is a difference between lambdas and method references?",
      "responses": [{
        "code": "A",
        "value": "Only one can take a method parameter."
      }, {
        "code": "B",
        "value": "Only one can reference an effectively final local variable."
      }, {
        "code": "C",
        "value": "Only one can make a method call where the method parameter is the\nhard‐coded number 3."
      }, {
        "code": "D",
        "value": "Only one can use deferred execution."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "88. C. Both lambda and method references can be passed to another method as\na parameter and executed later ruling out options A and D. One big\ndifference is with a lambda like: () ‐> s.charAt(3). The s variable must\nbe final or effectively final variable in both lambdas and method\nreferences, making option B incorrect. However, there isn't a way to use the\nhard‐coded number in a method reference. Therefore, option C is a\ndifference and the answer."
      }
    },
    "89": {
      "nbr": 89,
      "value": "Following the generate() method, which of the four method calls in this\ncode can be removed and have the method still compile and run without\nerror?\npublic static void main(String[] args) {\nStream.generate(() -> 'a')\n.limit(5)\n.filter(c -> c < 'b')\n.sorted()\n.findFirst()\n.ifPresent(System.out::print);\n}",
      "responses": [{
        "code": "A",
        "value": "filter()"
      }, {
        "code": "B",
        "value": "sorted()"
      }, {
        "code": "C",
        "value": "filter() and sorted()"
      }, {
        "code": "D",
        "value": "filter() and ifPresent()"
      }, {
        "code": "E",
        "value": "filter(), sorted(), and ifPresent()"
      }, {
        "code": "F",
        "value": "filter(), sorted(), findFirst(), and ifPresent()"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "89. E. A stream pipeline is allowed to have zero or more intermediate\noperations. This means both filter() and sorted() can be removed. The\nsource and terminal operations are required, so cannot be removed.\nTherefore, generate() and findFirst() must stay. The ifPresent() call\nis not part of the stream pipeline. It is a method on Optional."
      }
    },
    "90": {
      "nbr": 90,
      "value": "What is true of the following? (Choose three.)\nimport java.util.*;\npublic class Catch {\npublic static void main(String[] args) {\nOptional opt = Optional.empty();\nvar message = \"\";\ntry {\nmessage = _____ (opt);\n} catch (IllegalArgumentException e) {\nSystem.out.print(\"Caught it\");\n}\nSystem.out.print(message);\n}\nprivate static String x(Optional<String> opt) {\nreturn opt.orElseThrow();\n}\nprivate static String y(Optional<String> opt) {\nreturn\nopt.orElseThrow(IllegalArgumentException::new);\n}\nprivate static String z(Optional<String> opt) {\nreturn opt.orElse(\"Caught it\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "If filling in the blank with method x, the code outputs Caught it."
      }, {
        "code": "B",
        "value": "If filling in the blank with method x, the code prints a stack trace."
      }, {
        "code": "C",
        "value": "If filling in the blank with method y, the code outputs Caught it."
      }, {
        "code": "D",
        "value": "If filling in the blank with method y, the code prints a stack trace."
      }, {
        "code": "E",
        "value": "If filling in the blank with method z, the code outputs Caught it."
      }, {
        "code": "F",
        "value": "If filling in the blank with method z, the code prints a stack trace."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "E"
        ],
        "explanation": "90. B,C,E. The orElseThrow() method throws a NoSuchElementException\nwhen the Optional is empty. Since this exception is not caught, a stack\ntrace is printed. This matches option B. The overloaded method that takes a\nparameter throws the specified exception. Since we do catch an\nIllegalArgumentException, the code prints the message, which is option\nC. Finally, the orElse() method returns the specified string, and option E is\ncorrect."
      }
    },
    "91": {
      "nbr": 91,
      "value": "Which statement is not true of Predicate?",
      "responses": [{
        "code": "A",
        "value": "A boolean is returned from the method it declares."
      }, {
        "code": "B",
        "value": "It is an interface."
      }, {
        "code": "C",
        "value": "The method it declares accepts two parameters."
      }, {
        "code": "D",
        "value": "The method it declares is named test."
      }, {
        "code": "E",
        "value": "All of the above are true."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "91. C. Predicate is an interface with one method. The method signature is\nboolean test(T t). Option C is the answer because the method accepts\none parameter rather than two."
      }
    },
    "92": {
      "nbr": 92,
      "value": "Which functional interface does not have the correct number of generic\narguments? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "BiFunction<T,U,R>"
      }, {
        "code": "B",
        "value": "BinaryOperator<T, U>"
      }, {
        "code": "C",
        "value": "DoubleFunction<T,R>"
      }, {
        "code": "D",
        "value": "ToDoubleFunction<T>"
      }, {
        "code": "E",
        "value": "ToIntBiFunction<T,U>"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C"
        ],
        "explanation": "92. B,C. The BiFunction interface takes two different generic values and\nreturns a generic value, taking a total of three generic arguments. Next,\nToDoubleFunction takes exactly one generic value and returns a double\nvalue, requiring one generic argument. The ToIntBiFunction interface\ntakes two generic values and returns an int value, for a total of two generic\narguments. For these reasons, Options A, D, and E have the correct number\nof generics.\nBinaryOperator<T> takes two parameters of a generic type and returns the\nsame type. Therefore, only one generic is needed when declaring the type.\nDoubleFunction<R> takes a double value and returns a generic result,\ntaking exactly one generic argument, not two. This makes the answer\noptions B and C."
      }
    },
    "93": {
      "nbr": 93,
      "value": "How many changes need to be made to the following stream operation to\nexecute a parallel reduction?\nvar r = new Random();\nvar data = Stream.generate(() ->\nString.valueOf(r.nextInt()))\n.limit(50_000_000)\n.collect(Collectors.toSet());\nvar map = data.stream()\n.collect(Collectors.groupingBy(String::length));",
      "responses": [{
        "code": "A",
        "value": "None, it is already a parallel reduction."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "93. C. To execute a parallel reduction with the collect() method, the stream\nor Collector must be unordered, the Collector must be concurrent, and\nthe stream must be parallel. Since an unordered Set is used as the data\nsource, the first property is fulfilled. To be a parallel reduction, though,\nCollectors.groupByConcurrent() should be used instead of\nCollectors.groupingBy(). In addition, parallelStream() should be\ncalled on the Set, instead of stream(). For these two reasons, option C is\ncorrect."
      }
    },
    "94": {
      "nbr": 94,
      "value": "What is the output of this code?\nStream.of(\"one\", \"two\", \"bloat\")\n.limit(1)\n.map(String::toUpperCase) // line x\n.sorted()\n.forEach(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "bloat"
      }, {
        "code": "B",
        "value": "BLOAT"
      }, {
        "code": "C",
        "value": "one"
      }, {
        "code": "D",
        "value": "ONE"
      }, {
        "code": "E",
        "value": "The code does not compile due to line x."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "94. D. This is a correct stream pipeline. The source creates a stream of three\nelements. The first operation makes a stream of one element, one. Then that\nsingle element is made uppercase and sorted to complete the intermediate\noperations. Finally, the terminal operation prints ONE, which corresponds to\noption D."
      }
    },
    "95": {
      "nbr": 95,
      "value": "Which lambda expression can be passed to the magic() method?\npackage show;\nimport java.util.function.*;\npublic class Magician {\npublic void magic(BinaryOperator<Long> lambda) {\nlambda.apply(3L, 7L);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "(a) ‐> a"
      }, {
        "code": "B",
        "value": "(b,w) ‐> (long)w.intValue()"
      }, {
        "code": "C",
        "value": "(c,m) ‐> {long c=4; return c+m;}"
      }, {
        "code": "D",
        "value": "(Integer d, Integer r) ‐> (Long)r+d"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "95. B. BinaryOperator<Long> takes two Long arguments and returns a Long\nvalue. For this reason, option A, which takes one argument, and option D,\nwhich takes two Integer values that do not inherit from Long, are both\nincorrect. Option C is incorrect because the local variable c is re‐declared\ninside the lambda expression, causing the expression to fail to compile. The\ncorrect answer is option B because intValue() can be called on a Long\nobject. The result is then be cast to long, which is autoboxed to Long."
      }
    },
    "96": {
      "nbr": 96,
      "value": "Fill in the blank: ______________ is the only functional interface that does\nnot involve double, int, or long.",
      "responses": [{
        "code": "A",
        "value": "BooleanSupplier"
      }, {
        "code": "B",
        "value": "CharPredicate"
      }, {
        "code": "C",
        "value": "FloatUnaryOperator"
      }, {
        "code": "D",
        "value": "ShortConsumer"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "96. A. BooleanSupplier is the only functional interface that does not involve\ndouble, int, or long, making option A the correct answer. The rest of the\nfunctional interfaces are not found in java.util.function. Java does not\nhave built‐in support for primitive functional interfaces that include char,\nfloat, or short."
      }
    },
    "97": {
      "nbr": 97,
      "value": "Which statements about parallel streams are correct? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "A parallel stream is always faster than a serial stream."
      }, {
        "code": "B",
        "value": "The JVM will automatically apply a parallel stream operation to an\narbitrary stream in order to boost performance."
      }, {
        "code": "C",
        "value": "A parallel stream synchronizes its operations so that they are atomic."
      }, {
        "code": "D",
        "value": "All streams can be converted to a parallel stream."
      }, {
        "code": "E",
        "value": "If a stream uses a reduction method, the result will be the same\nregardless of whether the stream is parallel or serial."
      }, {
        "code": "F",
        "value": "Sometimes, a parallel stream will still operate in a single‐threaded\nmanner."
      }
      ],
      "answer": {
        "codes": [
          "D",
          "F"
        ],
        "explanation": "97. D,F. Certain stream operations, such as limit() or skip(), force a\nparallel stream to behave in a serial manner, so option A is incorrect, and\noption F is correct. Option B is also incorrect. The stream must be explicitly\nset to be parallel in order for the JVM to apply a parallel operation. Option\nC is incorrect because parallel stream operations are not synchronized. It is\nup to the developer to provide synchronization or use a concurrent\ncollection if required. Option D is also correct. The BaseStream interface,\nwhich all streams inherit, includes a parallel() method. Of course, the\nresults of an operation may change in the presence of a parallel stream, such\nas using a problematic (non‐associative) accumulator. For this reason,\noption E is incorrect."
      }
    },
    "98": {
      "nbr": 98,
      "value": "What is the output of the following?\nvar s = Stream.of(\"over the river\",\n\"through the woods\",\n\"to grandmother's house we go\");\ns.filter(n -> n.startsWith(\"t\"))\n.sorted(Comparator::reverseOrder)\n.findFirst()\n.ifPresent(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "over the river"
      }, {
        "code": "B",
        "value": "through the woods"
      }, {
        "code": "C",
        "value": "to grandmother's house we go"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "98. D. The sorted() method allows an optional Comparator to be passed as a\nreference. However, Comparator.reverseOrder() does not implement the\nComparator interface. It takes zero parameters instead of the required two.\nSince it cannot be used as a method reference, the code does not compile,\nand option D is correct."
      }
    },
    "99": {
      "nbr": 99,
      "value": "Which can fill in the blank to have the code print the single digit 9?\nvar stream = LongStream.of(9);\nstream.____________(p -> p).forEach(System.out::print);",
      "responses": [{
        "code": "A",
        "value": "Only mapToDouble"
      }, {
        "code": "B",
        "value": "Only mapToInt"
      }, {
        "code": "C",
        "value": "Only mapToLong"
      }, {
        "code": "D",
        "value": "Both mapToDouble and mapToInt"
      }, {
        "code": "E",
        "value": "mapToDouble, mapToInt, and mapToLong"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "99. F. The mapToDouble() method compiles. However, it converts 9 into 9.0\nrather than the single digit 9. The mapToInt() method does not compile\nbecause a long cannot be converted into an int without casting. The\nmapToLong() method is not available on LongStream so it does not compile.\nIt is available on DoubleStream, IntStream, and Stream implementations.\nSince none of the options outputs the single digit 9, option F is correct."
      }
    },
    "100": {
      "nbr": 100,
      "value": "What is the output of the following application?\npackage savings;\nimport java.util.function.*;\npublic class Bank {\nprivate int savingsInCents;\nprivate static class ConvertToCents {\nstatic DoubleToIntFunction f = p -> p*100;\n}\npublic static void main(String… currency) {\nBank creditUnion = new Bank();\ncreditUnion.savingsInCents = 100;\ndouble deposit = 1.5;\ncreditUnion.savingsInCents +=\nConvertToCents.f.applyAsInt(deposit); // j1\nSystem.out.print(creditUnion.savingsInCents);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "100"
      }, {
        "code": "B",
        "value": "200"
      }, {
        "code": "C",
        "value": "250"
      }, {
        "code": "D",
        "value": "The code does not compile because of line j1."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "100. E. The code does not compile because the lambda expression p ‐> p*100\nis not compatible with the DoubleToIntFunction functional interface. The\ninput to the functional interface is double, meaning p*100 is also double.\nThe functional interface requires a return value of int, and since double\ncannot be implicitly cast to int, the code does not compile, making option\nE the correct answer. If the correct cast was applied to make (p*100) an\nint, then the rest of the class would compile and 250 would be printed at\nruntime, making option C correct."
      }
    },
    "101": {
      "nbr": 101,
      "value": "Which statements about stateful lambda expressions are correct? (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "Stateful lambda expressions should be avoided on both serial and\nparallel streams."
      }, {
        "code": "B",
        "value": "Stateful lambda expressions should be avoided on only serial streams."
      }, {
        "code": "C",
        "value": "Stateful lambda expressions should be avoided on only parallel\nstreams."
      }, {
        "code": "D",
        "value": "One way to avoid modifying a List with a stateful lambda expression\nis to use a concurrent collection."
      }, {
        "code": "E",
        "value": "One way to avoid modifying a List with a stateful lambda expression\nis to use a collector that outputs a List."
      }, {
        "code": "F",
        "value": "One way to avoid modifying a List with a stateful lambda expression\nis to use a synchronized list."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "101. A,E. Stateful lambda expressions should be avoided with both serial and\nparallel streams because they can lead to unintended side effects, making\noption A correct. A common way to remove a stateful lambda expression\nthat modifies a List is to have the stream operation output a new List. For\nthis reason, option E is correct. Options D and F are incorrect because while\na concurrent or synchronized list may make the stream operation threadsafe,\nthey are still stateful lambda expressions."
      }
    },
    "102": {
      "nbr": 102,
      "value": "Which method reference can replace the lambda on the second line so the\noutput is the same?\nvar s = \"fish\";\nPredicate<String> pred = (a) -> s.contains(a);\nSystem.out.println(pred.test(\"fish\", \"is\"));",
      "responses": [{
        "code": "A",
        "value": "a::contains(b)"
      }, {
        "code": "B",
        "value": "a::contains"
      }, {
        "code": "C",
        "value": "String::contains(b)"
      }, {
        "code": "D",
        "value": "String::contains"
      }, {
        "code": "E",
        "value": "The supplied code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "102. E. The code does not compile, making option E the answer. In particular,\nthe call to test() should have one parameter instead of two."
      }
    },
    "103": {
      "nbr": 103,
      "value": "What is the best example of lazy evaluation?",
      "responses": [{
        "code": "A",
        "value": "The pipeline can execute before seeing all the data."
      }, {
        "code": "B",
        "value": "The pipeline does not begin until the terminal operation is executed."
      }, {
        "code": "C",
        "value": "The pipeline executes all operations as quickly as possible."
      }, {
        "code": "D",
        "value": "The pipeline loses data."
      }, {
        "code": "E",
        "value": "The pipeline takes a nap."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "103. B. Lazy evaluation delays execution until it is needed. Option B is the\nonly one that matches this requirement. While option A is true, this can be\ndone without lazy evaluation. Option C requires parallelization rather than\ndeferred execution. Option D is incorrect as data loss is bad. Finally,\npipelines are run by the computer, which does not get tired."
      }
    },
    "104": {
      "nbr": 104,
      "value": "Which method can be applied to an existing Stream<T> to return a stream\nwith a different generic type?",
      "responses": [{
        "code": "A",
        "value": "distinct()"
      }, {
        "code": "B",
        "value": "iterate()"
      }, {
        "code": "C",
        "value": "peek()"
      }, {
        "code": "D",
        "value": "sorted()"
      }, {
        "code": "E",
        "value": "filter()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "104. F. The distinct() and filter() methods can reduce the number of\nelements in a stream but do not change the generic type, making options A\nand E incorrect. The iterate() method creates a new stream and cannot be\napplied to an existing stream, making option B incorrect. The peek() and\nsorted() methods do not alter the generic type of the stream, making\noptions C and D incorrect. For these reasons, option F is correct."
      }
    },
    "105": {
      "nbr": 105,
      "value": "The ______________ functional interface has an apply() method, while\nthe ______________ functional interface has an applyAsDouble() method.\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "BiConsumer"
      }, {
        "code": "B",
        "value": "BiFunction"
      }, {
        "code": "C",
        "value": "BiPredicate"
      }, {
        "code": "D",
        "value": "DoubleConsumer"
      }, {
        "code": "E",
        "value": "DoublePredicate"
      }, {
        "code": "F",
        "value": "DoubleUnaryOperator"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "105. B,F. Option B fills in the first blank because BiFunction includes the\napply() method. DoubleUnaryOperator contains the applyAsDouble()\nmethod, making option F correct. For the exam, pay attention to methods\nthat have a different name for primitives."
      }
    },
    "106": {
      "nbr": 106,
      "value": "Given the following code snippet, what statement about the values printed\non lines q1 and q2 is correct?\nvar mitchsWorkout = new CopyOnWriteArrayList<Integer>();\nList.of(1,5,7,9).stream().parallel()\n.forEach(mitchsWorkout::add);\nmitchsWorkout\n.forEachOrdered(System.out::print); // q1\nList.of(1,5,7,9).stream().parallel()\n.forEachOrdered(System.out::print); // q2",
      "responses": [{
        "code": "A",
        "value": "They are always the same."
      }, {
        "code": "B",
        "value": "They are sometimes the same."
      }, {
        "code": "C",
        "value": "They are never the same."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code will produce a ConcurrentModificationException at\nruntime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "106. D. The forEachOrdered() method is available on streams, not collections.\nFor this reason, line q1 does not compile. and option D is correct. If the\nforEach() method was used instead, then the code would compile with the\nvalues printed on line q1 varying at runtime and the values printed on line\nq2 being consistent."
      }
    },
    "107": {
      "nbr": 107,
      "value": "Which of the following can fill in the blank to have the code print out *?\nStream.generate(() -> \"*\")\n.limit(3)\n.sorted(_______________)\n.distinct()\n.forEach(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "(s,t) ‐> s.length() ‐ t.length()"
      }, {
        "code": "B",
        "value": "String::isEmpty"
      }, {
        "code": "C",
        "value": "Both of these will produce the desired output."
      }, {
        "code": "D",
        "value": "Neither of these will allow the code to compile."
      }, {
        "code": "E",
        "value": "The code does not complete regardless of what goes in the blank."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "107. A. The sorted() method takes an optional Comparator as the parameter,\nwhich takes two String parameters and returns an int. Option A is correct\nbecause the lambda implements this interface. Option B is incorrect\nbecause the method reference doesn't take any parameters, nor does it return\nan int. While generate() starts with an infinite stream, the limit()\nintermediate operation immediately makes it finite. Finally, the distinct()\nintermediate operation gives us one star instead of three."
      }
    },
    "108": {
      "nbr": 108,
      "value": "Which statement about functional interfaces and lambda expressions is not\ntrue?",
      "responses": [{
        "code": "A",
        "value": "A lambda expression may be compatible with multiple functional\ninterfaces."
      }, {
        "code": "B",
        "value": "A lambda expression must be assigned to a functional interface when\nit is declared."
      }, {
        "code": "C",
        "value": "A method can return a lambda expression in the form of a functional\ninterface instance."
      }, {
        "code": "D",
        "value": "The compiler uses deferred execution to skip determining whether a\nlambda expression compiles or not."
      }, {
        "code": "E",
        "value": "All of these are true."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "108. D. Options A, B, and C are true statements about functional interfaces. A\nlambda may be compatible with multiple functional interfaces, but it must\nbe assigned to a functional interface when it is declared or passed as a\nmethod argument. Also, a method can be created with the return type that\nmatches a functional interface, allowing a lambda expression to be returned.\nOption D is the correct answer. Deferred execution means the lambda\nexpression is not evaluated until runtime, but it is compiled. Compiler\nerrors in the lambda expression will still prevent the code from compiling."
      }
    },
    "109": {
      "nbr": 109,
      "value": "Which can fill in the blank to have the code print true?\nvar stream = Stream.iterate(1, i -> i);\nvar b = stream.__________(i -> i> 5);\nSystem.out.println(b);",
      "responses": [{
        "code": "A",
        "value": "anyMatch"
      }, {
        "code": "B",
        "value": "allMatch"
      }, {
        "code": "C",
        "value": "noneMatch"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "109. D. This code generates an infinite stream of the number 1. The Predicate\nchecks if the element is greater than 5. This will never be true. With\nallMatch(), the stream pipeline ends after checking the first element. It\ndoesn't match, so the code prints false. Both anyMatch() and noneMatch()\nkeep checking and don't find any matches. However, they don't know if a\nfuture stream element will be different, so the code executes infinitely until\nthe process is terminated. Therefore, option D is correct."
      }
    },
    "110": {
      "nbr": 110,
      "value": "Given the following class, how many lines contain compilation errors?\n1: package showtimes;\n2: import java.util.*;\n3: import java.util.function.*;\n4: public class FindMovie {\n5: private Function<String> printer;\n6: protected FindMovie() {\n7: printer = s -> {System.out.println(s); return s;}\n8: }\n9: void printMovies(List<String> movies) {\n10: movies.forEach(printer);\n11: }\n12: public static void main(String[] screen) {\n13: List<String> movies = new ArrayList<>();\n14: movies.add(\"Stream 3\");\n15: movies.add(\"Lord of the Recursion\");\n16: movies.add(\"Silence of the Lambdas\");\n17: new FindMovie().printMovies(movies);\n18: }\n19: }",
      "responses": [{
        "code": "A",
        "value": "None. The code compiles as is."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "Five."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "110. D. To start with, line 5 does not compile because Function takes two\ngeneric arguments, not one. Second, the assignment statement on line 7\ndoes not end with a semicolon (;), so it also does not compile. Finally, the\nforEach() method on line 10 requires a Consumer, not a Function, so this\nline does not compile. For these three reasons, option D is the correct\nanswer."
      }
    },
    "111": {
      "nbr": 111,
      "value": "Which statements about the findFirst() method applied to a stream are\ncorrect? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "It always returns the first element on an ordered serial stream."
      }, {
        "code": "B",
        "value": "It may return any element on an ordered serial stream."
      }, {
        "code": "C",
        "value": "It always returns the first element on an unordered stream."
      }, {
        "code": "D",
        "value": "It may return any element on an unordered stream."
      }, {
        "code": "E",
        "value": "It always returns the first element on an ordered parallel stream."
      }, {
        "code": "F",
        "value": "It may return any element on an ordered parallel stream."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "E"
        ],
        "explanation": "111. A,D,E. The findFirst() method always returns the first element on an\nordered stream, regardless if it is serial or parallel, making options A and E\ncorrect. Option D is also correct, as it is free to return any element if the\nstream is unordered. Option C is actually invalid, as an unordered stream\ndoes not have a first element."
      }
    },
    "112": {
      "nbr": 112,
      "value": "Which method reference can replace the lambda in the first line of the\nmain() method to produce the same output?\ninterface Marsupial {\nvoid carryInPouch(int size);\n}\npublic class Opossum {\npublic static void main(String[] args) {\nMarsupial mar = x -> System.out.println(\"Carrying \" +\nx);\nmar.carryInPouch(1);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "System:out:println"
      }, {
        "code": "B",
        "value": "System::out:println"
      }, {
        "code": "C",
        "value": "System::out::println"
      }, {
        "code": "D",
        "value": "System.out::println"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "112. E. The only one of these references to compile is option D. However, the\noriginal code prints Carrying 1. The version with a method reference\nwould just print 1. Option E is the answer because this is not the same\noutput."
      }
    },
    "113": {
      "nbr": 113,
      "value": "What is true of the following code?\n21: Stream<Integer> s1 = Stream.of(8, 2);\n22: Stream<Integer> s2 = Stream.of(10, 20);\n23: s2 = s1.filter(n -> n> 4);\n24: s1 = s2.filter(n -> n < 1);\n25: System.out.println(s1.count());\n26: System.out.println(s2.count());",
      "responses": [{
        "code": "A",
        "value": "The code runs without error and prints 0."
      }, {
        "code": "B",
        "value": "The code runs without error and prints 1."
      }, {
        "code": "C",
        "value": "The code throws an exception on line 23."
      }, {
        "code": "D",
        "value": "The code throws an exception on line 24."
      }, {
        "code": "E",
        "value": "The code throws an exception on line 25."
      }, {
        "code": "F",
        "value": "The code throws an exception on line 26."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "113. F. A stream cannot be used again once it is executed. Line 21 creates a\nstream. Line 22 creates a second stream; however, the reference is lost on\nline 23. Lines 23 and 24 add intermediate operations to the stream that was\ncreated on line 21. Due to lazy evaluation, they do not run it. Line 25 does\nexecute the stream pipeline and prints 0. However, line 26 attempts to\nexecute the same stream and throws an IllegalStateException. This\nmatches option F."
      }
    },
    "114": {
      "nbr": 114,
      "value": "Which changes can be independently made to this code and have it still\ncompile? (Choose three.)\nPredicate<StringBuilder> p =\n(StringBuilder b) -> {return true;};",
      "responses": [{
        "code": "A",
        "value": "Change StringBuilder b to var b."
      }, {
        "code": "B",
        "value": "Change StringBuilder b to b."
      }, {
        "code": "C",
        "value": "Remove StringBuilder b."
      }, {
        "code": "D",
        "value": "Remove ‐>."
      }, {
        "code": "E",
        "value": "Remove { and ;}."
      }, {
        "code": "F",
        "value": "Remove { return and ;}."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "F"
        ],
        "explanation": "114. A,B,F. Options A and B are correct because the type may be var or\nomitted in a lambda. If there are multiple parameters, all must be handled\nthe same way. Option C is tricky but incorrect. While a lambda can have\nzero parameters, a Predicate cannot. A Predicate is defined as a type\nmapping to a boolean.\nOption D is clearly incorrect as ‐> separates the parts of a lambda. Options\nE and F are similar. Option E is incorrect because return is allowed only\nwhen the braces are present. Option F is correct."
      }
    },
    "115": {
      "nbr": 115,
      "value": "What does this code output?\nvar babies = Arrays.asList(\"chick\", \"cygnet\", \"duckling\");\nbabies.replaceAll(x -> { var newValue = \"baby\";\nreturn newValue; });\nSystem.out.println(newValue);",
      "responses": [{
        "code": "A",
        "value": "baby"
      }, {
        "code": "B",
        "value": "chick"
      }, {
        "code": "C",
        "value": "cygnet"
      }, {
        "code": "D",
        "value": "duckling"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "115. E. The newValue variable is locally scoped to the lambda. It is not\navailable outside the lambda, so the println() does not compile, and\noption E is the answer."
      }
    },
    "116": {
      "nbr": 116,
      "value": "Which lambda expression cannot be assigned to a DoubleToLongFunction\nfunctional interface?",
      "responses": [{
        "code": "A",
        "value": "a ‐> null==null ? 1 : 2L"
      }, {
        "code": "B",
        "value": "e ‐> (int)(10.0*e)"
      }, {
        "code": "C",
        "value": "(double m) ‐> {long p = (long)m; return p;}"
      }, {
        "code": "D",
        "value": "(Double s) ‐> s.longValue()"
      }, {
        "code": "E",
        "value": "All of these can be assigned."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "116. D. The DoubleToLongFunction interface takes a double argument and\nreturns a long value. Option A is compatible since the int value 1 can be\nimplicitly cast to long, and 2L is already a long. Option B is also\ncompatible, since the double value 10.0*e is explicitly cast to int then\nimplicitly cast to long. Next, option C is compatible because an explicit\ncast of the double to a long value is used. Option D cannot be assigned and\nis the correct answer. Although the Double class does have a longValue()\nmethod, the left‐hand side of the lambda expression must use the primitive\ndouble, not the wrapper Double. This lambda expression violates the\nsignature of the functional interface, since it allows Double values to be sent\nto the interface, including those that could be null."
      }
    },
    "117": {
      "nbr": 117,
      "value": "Given the following code snippet, which values of x will allow the call\ndivide(x) to compile and provide predictable results at runtime? (Choose\ntwo.)\nimport java.util.stream.*;\npublic class Divide {\nstatic float divide(Stream<Float> s) {\nreturn s.reduce(1.0f, (a,b) -> a/b, (a,b) -> a/b);\n} }",
      "responses": [{
        "code": "A",
        "value": "Set.of(1f,2f,3f,4f).stream()"
      }, {
        "code": "B",
        "value": "List.of(1f,2f,3f,4f).stream()"
      }, {
        "code": "C",
        "value": "List.of(1f,2f,3f,4f).parallel()"
      }, {
        "code": "D",
        "value": "List.of(1f).parallelStream()"
      }, {
        "code": "E",
        "value": "List.of(1f,2f,3f,4f).parallelStream()"
      }, {
        "code": "F",
        "value": "List.of(1f).parallel()"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "117. B,D. Option A is incorrect because sets are unordered. Options C and F\nare incorrect because the correct method call is parallelStream(). Option\nE is incorrect because the accumulator and combiner in the divide()\nmethod are not well‐behaved. In particular, they are not associative and in a\nparallel stream, could produce various results at runtime. On a serial\nordered stream, though, the results will be processed sequentially and in a\npredictable order, making option B correct. Option D is correct because the\nstream has only one element, so the identity is the only thing that will be\napplied."
      }
    },
    "118": {
      "nbr": 118,
      "value": "Which of the following produces different output than the others?",
      "responses": [{
        "code": "A",
        "value": "Stream.of(\"eeny\", \"meeny\", \"miny\", \"moe\")\n.collect(partitioningBy(x -> x.charAt(0) == 'e'))\n.get(false)\n.stream()\n.collect(groupingBy(String::length))\n.get(4)\n.forEach(System.out::println);"
      }, {
        "code": "B",
        "value": "Stream.of(\"eeny\", \"meeny\", \"miny\", \"moe\")\n.filter(x -> x.charAt(0) != 'e')\n.collect(groupingBy(String::length))\n.get(4)\n.forEach(System.out::println);"
      }, {
        "code": "C",
        "value": "Stream.of(\"eeny\", \"meeny\", \"miny\", \"moe\")\n.collect(groupingBy(x -> x.charAt(0) == 'e'))\n.get(false)\n.stream()\n.collect(partitioningBy(String::length))\n.get(4)\n.forEach(System.out::println);"
      }, {
        "code": "D",
        "value": "Stream.of(\"eeny\", \"meeny\", \"miny\", \"moe\")\n.collect(groupingBy(x -> x.charAt(0) == 'e'))\n.get(false)\n.stream()\n.collect(groupingBy(String::length))\n.get(4)\n.forEach(System.out::println);"
      }, {
        "code": "E",
        "value": "Stream.of(\"eeny\", \"meeny\", \"miny\", \"moe\")\n.collect(partitioningBy(x -> x.charAt(0) == 'e'))\n.get(false)\n.stream()\n.collect(partitioningBy(x -> x.length() == 4))\n.get(true)\n.forEach(System.out::println);"
      }, {
        "code": "F",
        "value": "They all produce the same output."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "118. C. Four of the five examples print miny. Option C does not compile. The\ndifference is that partitioningBy() requires a Predicate that returns a\nboolean. When getting a question like this on the exam, focus on the\ndifferences between the provided options."
      }
    },
    "119": {
      "nbr": 119,
      "value": "Given an IntStream, which method would you use to obtain an equivalent\nparallel IntStream?",
      "responses": [{
        "code": "A",
        "value": "parallelStream()"
      }, {
        "code": "B",
        "value": "parallels()"
      }, {
        "code": "C",
        "value": "getParallelStream()"
      }, {
        "code": "D",
        "value": "parallel()"
      }, {
        "code": "E",
        "value": "getParallel()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "119. D. The correct method to obtain an equivalent parallel stream of an\nexisting stream is parallel(), which is inherited by any class that\nimplements BaseStream<T> including the primitive streams. For this\nreason, option D is correct."
      }
    },
    "120": {
      "nbr": 120,
      "value": "Which statement is true?",
      "responses": [{
        "code": "A",
        "value": "All lambdas can be converted to method references, and vice versa."
      }, {
        "code": "B",
        "value": "All lambdas can be converted to method references, but not vice versa."
      }, {
        "code": "C",
        "value": "All method references can be converted to lambdas, but not vice versa."
      }, {
        "code": "D",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "120. C. Method references are a shorter way of writing lambdas, and all method\nreferences can be expanded to lambdas. However, this does not apply in\nreverse. Consider the lambda: () ‐> s.charAt(n). The n variable can only\nbe an effectively final variable in lambdas, but not in method references.\nSince only method references can always be converted, option C is correct."
      }
    },
    "121": {
      "nbr": 121,
      "value": "The following diagram shows input arguments being used in three\nfunctional interface methods of unknown type. Which three functional\ninterfaces, inserted in order from left to right, could be used to complete the\ndiagram?",
      "responses": [{
        "code": "A",
        "value": "DoubleBinaryOperator\nToDoubleBiFunction<Integer,Double>\nUnaryOperator<Integer>"
      }, {
        "code": "B",
        "value": "BinaryOperator<Double>\nBiFunction<Integer,Integer,Double>\nUnaryOperator<Integer>"
      }, {
        "code": "C",
        "value": "Function<Double,Integer>\nBiFunction<Integer,Integer,Double>\nDoubleToIntFunction"
      }, {
        "code": "D",
        "value": "BiFunction<Integer,Double,Integer>\nBinaryOperator<Integer>\nIntUnaryOperator"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "121. D. First, options A and B are incorrect because the second functions for\nboth return a double or Double value, respectively. Neither of these values\ncan be sent to a UnaryOperator<Integer> without an explicit cast. Next,\noption C is incorrect. The first functional interface\nFunction<Double,Integer> takes only one input, but the diagram shows\ntwo inputs for the first functional interface.\nThat leaves us with option D. The first functional interface\nBiFunction<Integer,Double,Integer> takes an int, which can be\nimplicitly autoboxed to Integer, and a Double and returns an Integer. The\nnext functional interface, BinaryOperator<Integer>, takes two Integer\nvalues and returns an Integer value. Finally, this Integer value can be\nimplicitly unboxed and sent to IntUnaryOperator, returning an int. Since\nthese behaviors match our diagram, option D is the correct answer."
      }
    },
    "122": {
      "nbr": 122,
      "value": "Which of the following is not a functional interface in the\njava.util.function package? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "DoublePredicate"
      }, {
        "code": "B",
        "value": "LongUnaryOperator"
      }, {
        "code": "C",
        "value": "ShortSupplier"
      }, {
        "code": "D",
        "value": "ToIntBiFunction"
      }, {
        "code": "E",
        "value": "ToStringOperator"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "122. C,E. The DoublePredicate interface takes a double value and returns a\nboolean value. LongUnaryOperator takes a long value and returns a long\nvalue. ToIntBiFunction takes two generic values and returns an int value.\nShortSupplier and ToStringOperator are not built‐in functional\ninterfaces. Recall that Java only includes primitive functional interfaces that\noperate on double, int, or long. For this reason, Options C and E are\ncorrect."
      }
    },
    "123": {
      "nbr": 123,
      "value": "What is the output of the following application?\npackage tps;\nimport java.util.*;\nclass Boss {\nprivate String name;\npublic Boss(String name) {\nthis.name = name;\n}\npublic String getName() {return name.toUpperCase();}\npublic String toString() {return getName();}\n}\npublic class Initech {\npublic static void main(String[] reports) {\nfinal List<Boss> bosses = new ArrayList(8);\nbosses.add(new Boss(\"Jenny\"));\nbosses.add(new Boss(\"Ted\"));\nbosses.add(new Boss(\"Grace\"));\nbosses.removeIf(s -> s.equalsIgnoreCase(\"ted\"));\nSystem.out.print(bosses);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "[JENNY, GRACE]"
      }, {
        "code": "B",
        "value": "[ted]"
      }, {
        "code": "C",
        "value": "[tps.Boss@4218224c, tps.Boss@815f19a]"
      }, {
        "code": "D",
        "value": "The code does not compile because of the lambda expression."
      }, {
        "code": "E",
        "value": "The code does not compile for a different reason."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "123. D. The lambda expression is invalid because the input argument is of type\nBoss, and Boss does not define an equalsIgnoreCase() method, making\noption D the correct answer. If the lambda was corrected to use\ns.getName() instead of s, the code would compile and run without issue,\nprinting [JENNY, GRACE] at runtime and making option A the correct\nanswer."
      }
    },
    "124": {
      "nbr": 124,
      "value": "Which lambda can implement this functional interface?\npublic interface Serval {\nstatic void printName(String name) {}\nboolean cat(String name) { return true; }\n}",
      "responses": [{
        "code": "A",
        "value": "() ‐> System.out.println()"
      }, {
        "code": "B",
        "value": "n ‐> System.out.println(n)"
      }, {
        "code": "C",
        "value": "() ‐> true"
      }, {
        "code": "D",
        "value": "n ‐> true"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "124. E. Serval is not a valid interface let alone a functional interface. The\ncat() method specifies an implementation, but does not have one of the\nmodifiers that allows a body: default, private, or static. For this reason,\noption E is correct. If cat() was made an abstract method, then Serval\nwould be a valid functional interface with n ‐> true being a valid lambda\nthat matches it."
      }
    },
    "125": {
      "nbr": 125,
      "value": "How many of these lines compile?\n17: Comparator<String> c1 = s -> false;\n18: Comparator<String, String> c2 = (s1, s2) -> false;\n19: Predicate<String> p1 = String s -> false;\n20: Predicate<String> p2 = (String s) -> false;\n21: Supplier<String> s1 = String s -> false;\n22: Supplier<String> s2 = (String s) -> false;",
      "responses": [{
        "code": "A",
        "value": "One"
      }, {
        "code": "B",
        "value": "Two"
      }, {
        "code": "C",
        "value": "Three"
      }, {
        "code": "D",
        "value": "Four"
      }, {
        "code": "E",
        "value": "Five"
      }, {
        "code": "F",
        "value": "Six"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "125. A. Let's use the process of elimination here. Comparator returns an int,\ncausing lines 17 and 18 to not compile. Supplier does not take any\nparameters further, ruling out lines 21 and 22.\nPredicate at least has the right number of parameters and the correct\nboolean return type. However, line 19 is not correct because the\nparentheses are missing around the type and variable. The parentheses can\nbe omitted only if no type declaration is present, making line 20 correct.\nSince only one of these lines of code compiles, option A is the answer."
      }
    },
    "126": {
      "nbr": 126,
      "value": "Which method is not available on the IntSummaryStatistics class?",
      "responses": [{
        "code": "A",
        "value": "getCountAsLong()"
      }, {
        "code": "B",
        "value": "getMax()"
      }, {
        "code": "C",
        "value": "toString()"
      }, {
        "code": "D",
        "value": "None of these methods is available."
      }, {
        "code": "E",
        "value": "All of these methods are available."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "126. A. Option A is the answer because there is a getCount() method that\nreturns a long rather than a method named getCountAsLong(). Option B is\nincorrect because there is in fact a getMax() method. Option C is incorrect\nbecause toString() is declared on Object, which means it is inherited by\nall classes."
      }
    },
    "127": {
      "nbr": 127,
      "value": "Which functional interface, when filled into the blank, allows the class to\ncompile?\npackage sleep;\nimport java.util.function.*;\nclass Sheep {}\npublic class Dream {\nint MAX_SHEEP = 10;\nint sheepCount;\npublic void countSheep(_______________ backToSleep) {\nwhile(sheepCount<MAX_SHEEP) {\n// TODO: Apply lambda\nsheepCount++;\n}\n}\npublic static void main(String[] dark) {\nnew Dream().countSheep(System.out::println);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Consumer<Sheep>"
      }, {
        "code": "B",
        "value": "Function<Sheep,void>"
      }, {
        "code": "C",
        "value": "Supplier<Sheep>"
      }, {
        "code": "D",
        "value": "UnaryOperator<Sheep>"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "127. A. The method reference System.out::println takes a single input and\ndoes not return any data. Consumer<Sheep> is compatible with this\nbehavior, making option A the correct answer. Note that option B does not\neven compile because void cannot be used as a generic argument.\nSimilarly, option C does not take a parameter. Option D is also incorrect,\nsince System.out::println() does not return any data, and\nUnaryOperator requires a return value."
      }
    },
    "128": {
      "nbr": 128,
      "value": "Given an instance of Stream s and Collection c, which of the following\nare valid ways of creating a parallel stream? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "c.parallel()"
      }, {
        "code": "B",
        "value": "c.parallel().parallelStream()"
      }, {
        "code": "C",
        "value": "c.parallelStream()"
      }, {
        "code": "D",
        "value": "s.parallelStream()"
      }, {
        "code": "E",
        "value": "c.parallelStream().parallel()"
      }, {
        "code": "F",
        "value": "s.parallel()"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E",
          "F"
        ],
        "explanation": "128. C,E,F. The correct method to obtain a parallel stream of an arbitrary\nstream is parallel(), while the correct method to obtain a parallel stream\nthat operates on a Collection is parallelStream(). For this reason,\noptions C, E, and F are correct. Note that option E retrieves a parallel\nstream of an already parallel stream, which is allowed."
      }
    },
    "129": {
      "nbr": 129,
      "value": "What is true of the following code? (Choose two.)\n3: public static void main(String[] args) {\n4: var prefix = \"r\";\n5: var pets = List.of(\"rabbit\", \"snake\", \"turtle\");\n6:\n7: // prefix = \"t\";\n8: pets.forEach(p -> {\n9: if (p.startsWith(prefix)) System.out.println(p);\n} );\n10: }",
      "responses": [{
        "code": "A",
        "value": "As written, the code prints one line."
      }, {
        "code": "B",
        "value": "As written, the code prints two lines."
      }, {
        "code": "C",
        "value": "As written the code does not compile."
      }, {
        "code": "D",
        "value": "If line 7 is uncommented, the code prints one line."
      }, {
        "code": "E",
        "value": "If line 7 is uncommented, the code prints two lines."
      }, {
        "code": "F",
        "value": "If line 7 is uncommented, the code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "F"
        ],
        "explanation": "129. A,F. The code, as written, prints rabbit, since it starts with the letter r.\nThis is option A. The prefix variable is effectively final and, therefore safe\nto use in a lambda. Uncommenting line 7 changes the prefix variable, and\nit is no longer effectively final. Since this causes a compiler error, option F\nis the other answer."
      }
    },
    "130": {
      "nbr": 130,
      "value": "What is the output of the following code snippet?\n10: var pears = List.of(1, 2, 3, 4, 5, 6);\n11: final var sum = pears.stream()\n12: .skip(1)\n13: .limit(3)\n14: .flatMapToInt(s -> IntStream.of(s))\n15: .skip(1)\n16: .boxed()\n17: .mapToDouble(s -> s)\n18: .sum();\n19: System.out.print(sum);",
      "responses": [{
        "code": "A",
        "value": "6"
      }, {
        "code": "B",
        "value": "7.0"
      }, {
        "code": "C",
        "value": "6.0"
      }, {
        "code": "D",
        "value": "7"
      }, {
        "code": "E",
        "value": "Exactly one line contains a compiler error."
      }, {
        "code": "F",
        "value": "More than one line contains a compiler error."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "130. B. The code compiles, so options E and F are incorrect. The stream\noperations on lines 12–13 reduce the stream to the values [2, 3, 4]. Line\n14 then converts the Stream<Integer> to an IntStream. On line 15, the\nfirst element of the IntStream is skipped, so the stream has only two\nelements [3, 4]. On line 16–17, the IntStream is converted to a\nStream<Integer>, then a DoubleStream. Finally, on lines 18–19 the sum of\nthe remaining elements is calculated and printed. Since 7.0 is printed,\noption B is correct."
      }
    },
    "131": {
      "nbr": 131,
      "value": "What is the minimum number of intermediate operations that can fill in\neach box [M, N, O, P] to have the pipeline complete given any\nintermediate operation?\nSource Intermediate Operation Terminal Operation\nFinite Stream Source Box M count()\nFinite Stream Source Box N findFirst()\nInfinite Stream Source Box O count()\nInfinite Stream Source Box P findFirst()",
      "responses": [{
        "code": "A",
        "value": "[0, 0, 0, 1]"
      }, {
        "code": "B",
        "value": "[0, 0, 1, 0]"
      }, {
        "code": "C",
        "value": "[0, 0, 1, 1]"
      }, {
        "code": "D",
        "value": "[1, 1, 0, 1]"
      }, {
        "code": "E",
        "value": "[1, 1,1, 0]"
      }, {
        "code": "F",
        "value": "[1, 1, 1, 1]"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "131. B. Since the first two rows are already finite streams, boxes M and N do\nnot require an intermediate operation to complete, so options D, E, and F\nare incorrect. Box P does not need an intermediate operation either, since\nfindFirst() will cause the stream to terminate, making options A and C\nincorrect. Box O does need to be filled in with code such as limit(1). This\nallows the code to terminate, and option B is the answer."
      }
    },
    "132": {
      "nbr": 132,
      "value": "Given the table in the previous question, how many of the boxes in the\nIntermediate Operation column will have the pipeline complete regardless\nof which intermediate operation is placed in the box?",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "132. C. Since the first two rows are already finite streams, boxes M and N meet\nthis criteria. The last two rows can be filled in with code such as sorted(),\nwhich does not terminate for an infinite stream. Therefore, neither allows\nthe code to terminate, and option C is the answer."
      }
    },
    "133": {
      "nbr": 133,
      "value": "Which of the following declares a Comparator where all objects are treated\nas equal?",
      "responses": [{
        "code": "A",
        "value": "Comparator<Character> comp = (c1) ‐> 0;"
      }, {
        "code": "B",
        "value": "Comparator<Character> comp = (c1) ‐> {0};"
      }, {
        "code": "C",
        "value": "Comparator<Character> comp = (c1, c2) ‐> 0;"
      }, {
        "code": "D",
        "value": "Comparator<Character> comp = (c1, c2) ‐> {0};"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "133. C. A Comparator takes two parameters, so options A and B are incorrect.\nOption D doesn't compile. When returning a value using braces, a return\nkeyword and semicolon are required. Option C is a correct implementation."
      }
    },
    "134": {
      "nbr": 134,
      "value": "Which can fill in the blank so this code outputs true?\nimport java.util.function.*;\nimport java.util.stream.*;\npublic class HideAndSeek {\npublic static void main(String[] args) {\nvar hide = Stream.of(true, false, true);\nvar found = hide.filter(b -> b).________();\nSystem.out.println(found);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Only anyMatch"
      }, {
        "code": "B",
        "value": "Only allMatch"
      }, {
        "code": "C",
        "value": "Both anyMatch and allMatch"
      }, {
        "code": "D",
        "value": "Only noneMatch"
      }, {
        "code": "E",
        "value": "The code does not compile with any of these options."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "134. E. The methods anyMatch(), allMatch(), and noneMatch() take a\nPredicate as a parameter. This code does not compile because the\nparameter is missing, making option E correct."
      }
    },
    "135": {
      "nbr": 135,
      "value": "Which method reference can replace the lambda on the second line so the\noutput is the same?\nvar s = \"fish\";\nPredicate<String> pred = (a) -> s.contains(a);\nSystem.out.println(pred.test(\"is\"));",
      "responses": [{
        "code": "A",
        "value": "s::contains(a)"
      }, {
        "code": "B",
        "value": "s::contains"
      }, {
        "code": "C",
        "value": "String::contains(a)"
      }, {
        "code": "D",
        "value": "String::contains"
      }, {
        "code": "E",
        "value": "The supplied code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "135. B. Since the lambda references an effectively final variable, the method\nreference needs to as well. Option B is a correct method reference that\nmeets this criteria. Options A and C use syntax that is not supported with\nmethod references. Option D is incorrect because the Predicate passes\nonly one value at runtime, so one of the instance variable or method\nparameter would need to be supplied."
      }
    },
    "136": {
      "nbr": 136,
      "value": "How many of these lines compile?\nPredicate<String> pred1 = (final String s) -> s.isEmpty();\nPredicate<String> pred2 = (final s) -> s.isEmpty();\nPredicate<String> pred3 = (final var s) -> s.isEmpty();\nPredicate<String> pred4 = (String s) -> s.isEmpty();\nPredicate<String> pred5 = (var s) -> s.isEmpty();",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }, {
        "code": "F",
        "value": "5"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "136. E. Both pred4 and pred5 are valid as they use a type or var without\nfinal. Both pred1 and pred3 are valid because the final modifier can only\nbe used if a type or var is specified. Since pred2 is missing a data type and\nis the only line that does not compile, option E is the answer."
      }
    },
    "137": {
      "nbr": 137,
      "value": "What is the output of the following application?\npackage pet;\nimport java.util.*;\nimport java.util.function.*;\npublic class DogSearch {\nvoid reduceList(List<String> names,\nPredicate<String> tester) {\nnames.removeIf(tester);\n}\npublic static void main(String[] treats) {\nint MAX_LENGTH = 2;\nDogSearch search = new DogSearch();\nList<String> names = new ArrayList<>();\nnames.add(\"Lassie\");\nnames.add(\"Benji\");\nnames.add(\"Brian\");\nsearch.reduceList(names, d -> d.length()>MAX_LENGTH);\nSystem.out.print(names.size());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "3"
      }, {
        "code": "D",
        "value": "The code does not compile because of the lambda expression."
      }, {
        "code": "E",
        "value": "The code does not compile for a different reason."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "137. A. This code does compile, making options D and E incorrect. It correctly\nuses a Predicate<String> and removes all the elements from names and\nprints out 0. Therefore, option A is the answer."
      }
    },
    "138": {
      "nbr": 138,
      "value": "What is the output of the following program?\nvar p = List.of(1,3,5);\nvar q = p.parallelStream().reduce(0f,\n(w,x) -> w.floatValue() + x.floatValue(),\n(y,z) -> y.floatValue() + z.floatValue());\nSystem.out.println(q);",
      "responses": [{
        "code": "A",
        "value": "0.0"
      }, {
        "code": "B",
        "value": "9.0"
      }, {
        "code": "C",
        "value": "11.0"
      }, {
        "code": "D",
        "value": "One line does not compile."
      }, {
        "code": "E",
        "value": "Two lines do not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "138. B. Since it's not a primitive stream, the underlying type is\nStream<Integer>, which means the data type of x is Integer. On the other\nhand, the data type of w, y, and z is Float. Because Integer and Float both\ndefine a floatValue() method, all of the lines compile. The code snippet\nprints 9.0 at runtime, making option B correct."
      }
    },
    "139": {
      "nbr": 139,
      "value": "What does the following output?\nSet<String> set = new HashSet<>();\nset.add(\"tire-\");\nList<String> list = new LinkedList<>();\nDeque<String> queue = new ArrayDeque<>();\nqueue.push(\"wheel-\");\nStream.of(set, list, queue)\n.flatMap(x -> x.stream())\n.forEach(System.out::print);",
      "responses": [{
        "code": "A",
        "value": "[tire‐][wheel‐]"
      }, {
        "code": "B",
        "value": "tire‐wheel‐"
      }, {
        "code": "C",
        "value": "None of the above."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "139. B. The flatMap() method is used to turn a stream of collections into a\none‐dimensional stream. This means it gets rid of the empty list and\nflattens the other two. Option A is incorrect because this is the output you'd\nget using the regular map() method. Option B is correct because it flattens\nthe elements. Notice how it doesn't matter that all three elements are\ndifferent types of Collection implementations."
      }
    },
    "140": {
      "nbr": 140,
      "value": "How many lines does this code output?\n1: import java.util.*;\n2:\n3: public class PrintNegative {\n4: public static void main(String[] args) {\n5: List<String> list = new ArrayList<>();\n6: list.add(\"-5\");\n7: list.add(\"0\");\n8: list.add(\"5\");\n9: list.removeIf(e -> e < 0);\n10: list.forEach(x -> System.out.println(x));\n11: }\n12: }",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "Three."
      }, {
        "code": "D",
        "value": "None. The code does not compile."
      }, {
        "code": "E",
        "value": "None. The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "140. D. Pay attention to the data types. The forEach() method is looping\nthrough a list of objects. This is a good example of using a lambda with\nlist. By contrast, the Predicate passed to removeIf() uses an Integer.\nSince Integer is not compatible with String, line 9 does not compile."
      }
    },
    "141": {
      "nbr": 141,
      "value": "How many of the following lines compile?\n8: IntFunction<Integer> f1 =(Integer f) -> f;\n9: IntFunction<Integer> f2 = (v) -> null;\n10: IntFunction<Integer> f3 = s -> s;\n11: IntFunction<Integer> f4 = () -> 5;\n12: IntFunction<Integer> f5 = () -> Integer.valueOf(9);",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "141. C. To start with, IntFunction<Integer> takes an int value and returns an\nInteger. Line 8 takes an Integer instead of int as the input argument, and\nis therefore not compatible. Line 9 is compatible, since the return type null\ncan be used as an Integer return type. Line 10 is also valid. An int can be\nautoboxed to Integer. Lines 11 and 12 do not compile because they do not\ntake a parameter. Since only two statements compile, option C is the correct\nanswer."
      }
    },
    "142": {
      "nbr": 142,
      "value": "Which statements about using a parallel stream instead of a serial stream\nare correct? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "The number of threads used is guaranteed to be higher."
      }, {
        "code": "B",
        "value": "It requires a stateful lambda expression."
      }, {
        "code": "C",
        "value": "The stream operation may execute faster."
      }, {
        "code": "D",
        "value": "The stream operation may execute slower."
      }, {
        "code": "E",
        "value": "The result of the stream operation will be the same."
      }, {
        "code": "F",
        "value": "The result of the stream operation may change."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D",
          "F"
        ],
        "explanation": "142. C,D,F. Using a parallel stream does not guarantee concurrent execution or\na specific number of threads, making option A incorrect. Option B is also\nincorrect, as stateful lambda expressions should be avoided with all\nstreams, serial or parallel. In fact, if a stateful lambda expression is used,\nthe result of the stream may change, making option F correct and option E\nincorrect. Option C is correct, as a parallel stream may improve\nperformance. Option D is also correct, though, as a parallel stream may add\nextra overhead to a stream that is forced into a serial operation, such as\nwhen the findFirst() method is called."
      }
    },
    "143": {
      "nbr": 143,
      "value": "Which is a possible output of the following code snippet?\nvar landmarks = Set.of(\"Eiffel Tower\", \"Statue of Liberty\",\n\"Stonehenge\", \"Mount Fuji\");\nvar result = landmarks\n.stream()\n.collect(Collectors.partitioningBy(b -> b.contains(\"\n\")))\n.entrySet()\n.stream()\n.flatMap(t -> t.getValue().stream())\n.collect(Collectors.groupingBy(s ->\n!s.startsWith(\"S\")));\nSystem.out.println(result);",
      "responses": [{
        "code": "A",
        "value": "{false=[Stonehenge, Statue of Liberty], true=[Eiffel Tower,\nMount Fuji]}"
      }, {
        "code": "B",
        "value": "{false=[Stonehenge], true=[Mount Fuji, Eiffel Tower, Statue\nof Liberty]}"
      }, {
        "code": "C",
        "value": "{false=[Mount Fuji, Stonehenge], true=[Eiffel Tower, Statue\nof Liberty]}"
      }, {
        "code": "D",
        "value": "Exactly one line contains a compiler error."
      }, {
        "code": "E",
        "value": "More than one line contains a compiler error."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "143. A. The code compiles, so options D and E are incorrect. The code first\nsplits the stream into a Map<Boolean, List<String> based on whether the\nlandmark contains a space. Using the flatMap() method, it then takes the\nList<String> values of the Map and reforms them as a Stream<String>.\nThis new stream is similar to the original stream, although with elements in\na possibly different order. Finally, the groupingBy() collector splits the\nstream based on whether it does not start with an \"S\". Since Set and Map\nwere used, the order may vary, but option A is one possible output."
      }
    },
    "144": {
      "nbr": 144,
      "value": "Which can independently fill in the blank to output No dessert today?\nimport java.util.*;\npublic class Dessert {\npublic static void main(String[] yum) {\neatDessert(Optional.of(\"Cupcake\"));\n}\nprivate static void eatDessert(Optional<String> opt) {\nSystem.out.println(opt._____________);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "get(\"No dessert today\")"
      }, {
        "code": "B",
        "value": "orElse(\"No dessert today\")"
      }, {
        "code": "C",
        "value": "orElseGet(() ‐> \"No dessert today\")"
      }, {
        "code": "D",
        "value": "orElseThrow()"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "144. E. Option A doesn't compile because the get() method on Optional\ndoesn't take any parameters. Options B, C, and D do compile, but print\nCupcake since the Optional is not empty. Therefore, option E is correct."
      }
    },
    "145": {
      "nbr": 145,
      "value": "What is the output of this code?\nList.of(\"one\", \"two\", \"bloat\")\n.limit(1)\n.map(String::toUpperCase) // line x\n.sorted()\n.forEach(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "bloat"
      }, {
        "code": "B",
        "value": "BLOAT"
      }, {
        "code": "C",
        "value": "one"
      }, {
        "code": "D",
        "value": "ONE"
      }, {
        "code": "E",
        "value": "The code does not compile due to line x."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "145. F. There is no source in this attempt at a stream pipeline. While a\nCollection does have some of the same methods as a stream, such as\nforEach(), the limit() method is not one of them, so the code as written\ncauses a compile error. Since this error is not on line x, option F is the\nanswer. If stream() were inserted before limit(), then ONE would be\nprinted."
      }
    },
    "146": {
      "nbr": 146,
      "value": "Which is one of the lines output by this code?\n10: var list = new ArrayList<Integer>();\n11: list.add(10);\n12: list.add(9);\n13: list.add(8);\n14:\n15: var num = 9;\n16: list.removeIf(x -> {int keep = num; return x ==\nkeep;});\n17: System.out.println(list);\n18:\n19: num = 8;\n20: list.removeIf(x -> {int keep = num; return x ==\nkeep;});\n21: System.out.println(list);",
      "responses": [{
        "code": "A",
        "value": "[]"
      }, {
        "code": "B",
        "value": "[8]"
      }, {
        "code": "C",
        "value": "[9]"
      }, {
        "code": "D",
        "value": "[10]"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "146. E. The num variable is not effectively final because the value changes. This\nmeans it cannot be used in a lambda and the code does not compile, which\nis option E."
      }
    },
    "147": {
      "nbr": 147,
      "value": "What is the output of the following?\nimport java.util.Comparator;\nimport java.util.stream.Stream;\npublic class Compete {\npublic static void main(String[] args) {\nStream<Integer> is = Stream.of(8, 6, 9);\nComparator<Integer> c = (a, b) -> a - b;\nis.sort(c).forEach(System.out::print);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "689"
      }, {
        "code": "B",
        "value": "986"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "147. C. There is not a stream pipeline method called sort(). There is one\ncalled sorted(). Since the code does not compile, option C is correct. If\nthis was fixed, option A would be correct since the Comparator sorts in\nascending order."
      }
    },
    "148": {
      "nbr": 148,
      "value": "What can a lambda implement?",
      "responses": [{
        "code": "A",
        "value": "All functional interfaces"
      }, {
        "code": "B",
        "value": "Any interface"
      }, {
        "code": "C",
        "value": "Only functional interfaces in the JDK"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "148. A. A lambda can only implement an interface with a single abstract\nmethod ruling out option B. Developers can write their own functional\ninterfaces, making option A correct."
      }
    },
    "149": {
      "nbr": 149,
      "value": "What is the output of the following application?\npackage lot;\nimport java.util.function.*;\npublic class Warehouse {\nprivate int quantity = 40;\nprivate final BooleanSupplier stock;\n{\nstock = () -> quantity>0;\n}\npublic void checkInventory() {\nif(stock.get())\nSystem.out.print(\"Plenty!\");\nelse {\nSystem.out.print(\"On Backorder!\");\n}\n}\npublic static void main(String… widget) {\nfinal Warehouse w13 = new Warehouse();\nw13.checkInventory();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Plenty!"
      }, {
        "code": "B",
        "value": "On Backorder!"
      }, {
        "code": "C",
        "value": "The code does not compile because of the checkInventory() method."
      }, {
        "code": "D",
        "value": "The code does not compile for a different reason."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "149. C. The primitive Supplier functional interfaces, such as\nBooleanSupplier and LongSupplier, do not have a get() method. Instead,\nthey have methods such as getAsBoolean() and getAsLong(), respectively.\nFor this reason, the first line of the checkInventory() method does not\ncompile, making option C the correct answer. If the method call was\nchanged to getAsBoolean(), then the rest of the code would compile\nwithout issue, print Plenty! at runtime, and option A would be the correct\nanswer."
      }
    },
    "150": {
      "nbr": 150,
      "value": "What is a possible output of the following application?\nimport java.util.*;\nimport java.util.stream.*;\npublic class Thermometer {\nprivate String feelsLike;\nprivate double temp;\n@Override public String toString() { return feelsLike; }\n// Constructor/Getters/Setters Omitted\npublic static void main(String… season) {\nvar readings = List.of(new Thermometer(\"HOT!\",72),\nnew Thermometer(\"Too Cold!\",0),\nnew Thermometer(\"Just right!\",72));\nreadings\n.parallelStream() // k1\n.collect(Collectors.groupingByConcurrent(\nThermometer::getTemp)) // k2\n.forEach(System.out::println); // k3\n} }",
      "responses": [{
        "code": "A",
        "value": "{0.0=[Cold!], 72.0=[HOT!, Just right!]}"
      }, {
        "code": "B",
        "value": "{0.0=[Cold!], 72.0=[Just right!], 72.0=[HOT!]}"
      }, {
        "code": "C",
        "value": "The code does not compile because of line k1."
      }, {
        "code": "D",
        "value": "The code does not compile because of line k2."
      }, {
        "code": "E",
        "value": "The code does not compile because of line k3."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "150. E. The code does not compile because the collector returns a\nConcurrentMap, which requires a BiConsumer in the forEach() method.\nFor this reason, option E is correct."
      }
    }
  }
}, {
  "name": "Java Platform Module System",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "What is the name of a file that declares a module?",
      "responses": [{
        "code": "A",
        "value": "mod.java"
      }, {
        "code": "B",
        "value": "mod‐data.java"
      }, {
        "code": "C",
        "value": "mod‐info.java"
      }, {
        "code": "D",
        "value": "module.java"
      }, {
        "code": "E",
        "value": "module‐data.java"
      }, {
        "code": "F",
        "value": "module‐info.java"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "1. F. The module‐info.java file is used to declare a module. You must\nmemorize the name of this file."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Suppose you have a module that contains a class with a call to\nexports(ChocolateLab.class). Which part of the module service contains\nthis class?",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "2. E. The service locator contains a load() method, not an exports()\nmethod, making option E the answer."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Which are considered part of a service? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "3. B,D. A service is comprised of the interface, any classes the interface\nreferences, and a way to look up implementations of the interface. Option B\ncovers the lookup, and option D covers the interface itself."
      }
    },
    "4": {
      "nbr": 4,
      "value": "Given the following diagram, how many of the following are named\nmodules?",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "4. B. A named module must be on the module path and contain a moduleinfo\nfile. Only dog.bark meets this criterion, making option B the answer."
      }
    },
    "5": {
      "nbr": 5,
      "value": "Given the diagram from the previous question, which is an automatic\nmodule?",
      "responses": [{
        "code": "A",
        "value": "dog.bark"
      }, {
        "code": "B",
        "value": "dog.fluffy"
      }, {
        "code": "C",
        "value": "dog.hair"
      }, {
        "code": "D",
        "value": "dog.husky"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "5. C. An automatic module must be on the module path but does not contain\na module‐info file. Option C is correct because dog.hair matches this\ndescription."
      }
    },
    "6": {
      "nbr": 6,
      "value": "Given the diagram from question 4, which is a default module?",
      "responses": [{
        "code": "A",
        "value": "dog.bark"
      }, {
        "code": "B",
        "value": "dog.fluffy"
      }, {
        "code": "C",
        "value": "dog.hair"
      }, {
        "code": "D",
        "value": "dog.husky"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "6. E. You need to know about three types of modules for the exam:\nautomatic, named, and unnamed. There is no such thing as a default\nmodule. The question was trying to trick you, and option E is correct."
      }
    },
    "7": {
      "nbr": 7,
      "value": "Given the diagram from question 4, how many are unnamed modules?",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "7. C. An unnamed module must be on the classpath. It is rare to have a\nmodule‐info file in an unnamed module, but it is allowed. Therefore, both\ndog.fluffy and dog.husky meet this criterion, making option C correct."
      }
    },
    "8": {
      "nbr": 8,
      "value": "Which of the following statements are true? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "It is a good practice to add the ‐‐add‐exports option to your java\ncommand."
      }, {
        "code": "B",
        "value": "It is permitted, but not recommended, to add the ‐‐add‐exports\noption to your java command."
      }, {
        "code": "C",
        "value": "There is no ‐‐add‐exports option on the java command."
      }, {
        "code": "D",
        "value": "It is a good practice to add the ‐‐add‐requires option to your java\ncommand."
      }, {
        "code": "E",
        "value": "It is permitted, but not recommended, to add the ‐‐add‐requires\noption to your java command."
      }, {
        "code": "F",
        "value": "There is no ‐‐add‐requires option on the java command."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "8. B,F. It is recommended to specify all exports directives in the moduleinfo\nfile. While it is legal to use the ‐‐add‐exports option, it is not\nrecommended, making option B correct. You do not need to know how to\nuse it for the exam, just that it is not a good idea. There is no equivalent\noption for requires, making option F correct."
      }
    },
    "9": {
      "nbr": 9,
      "value": "How many of the following are legal module‐info.java files?\nmodule com.koala {\nexports cute;\n}\nmodule com-koala {\nexports cute;\n}\npublic module com.koala {\nexports cute;\n}\npublic module com-koala {\nexports cute;\n}",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "9. B. Since Java does not allow dashes in identifier names, the second and\nfourth declarations are invalid. Additionally, access modifiers are not\npermitted in module declarations, making the third and fourth declarations\ninvalid. The only one that is legal is the first declaration, so option B is\ncorrect."
      }
    },
    "10": {
      "nbr": 10,
      "value": "Which two would be best to combine into a single module?",
      "responses": [{
        "code": "A",
        "value": "Consumer and service locator"
      }, {
        "code": "B",
        "value": "Consumer and service provider"
      }, {
        "code": "C",
        "value": "Consumer and service provider interface"
      }, {
        "code": "D",
        "value": "Service locator and service provider interface"
      }, {
        "code": "E",
        "value": "Service locator and service provider"
      }, {
        "code": "F",
        "value": "Service provider and service provider interface"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "10. D. The consumer is generally separate ruling out options A, B, and C. The\nservice provider is decoupled from the service provider interface ruling out\noption F. It is most logical to combine the service locator and service\nprovider interface because neither has a direct reference to the service\nprovider. Therefore, option D is correct."
      }
    },
    "11": {
      "nbr": 11,
      "value": "What command could you run to print output like the following?\njava.base@11.0.2\njava.compiler@11.0.2\njava.datatransfer@11.0.2\njava.desktop@11.0.2\n…",
      "responses": [{
        "code": "A",
        "value": "java ‐‐all‐modules"
      }, {
        "code": "B",
        "value": "java ‐‐describe‐modules"
      }, {
        "code": "C",
        "value": "java ‐‐list‐modules"
      }, {
        "code": "D",
        "value": "java ‐‐output‐modules"
      }, {
        "code": "E",
        "value": "java ‐‐show‐modules"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "11. C. The java command has an option to list all the modules that come with\nthe JDK. Option C is correct since that option is called ‐‐list‐modules.\nThe other options are not supported by the java command. Options B and E\nare similar to options that exist: ‐‐describe‐module and ‐‐show‐moduleresolution.\nBut neither gives a list of all the modules that come with the\nJDK."
      }
    },
    "12": {
      "nbr": 12,
      "value": "Suppose we have an automatic module on the module path named dogarthur2.\njar and no Automatic‐Module‐Name specified? What module\nname should named modules use to reference it?",
      "responses": [{
        "code": "A",
        "value": "dog‐arthur"
      }, {
        "code": "B",
        "value": "dog‐arthur2"
      }, {
        "code": "C",
        "value": "dog.arthur"
      }, {
        "code": "D",
        "value": "dog.arthur2"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "12. C. The rules for determining the name include removing the extension,\nremoving numbers, and changing special characters to periods (.). This\nleaves us with dog.arthur, which is option C."
      }
    },
    "13": {
      "nbr": 13,
      "value": "Given the dependencies in the diagram, which boxes represent the service\nprovider interface and service provider, respectively?",
      "responses": [{
        "code": "A",
        "value": "W and X"
      }, {
        "code": "B",
        "value": "W and Z"
      }, {
        "code": "C",
        "value": "X and Y"
      }, {
        "code": "D",
        "value": "X and Z"
      }, {
        "code": "E",
        "value": "Y and Z"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "13. C. All parts of a modules service must point to the service provider\ninterface. This tells us the service provider interface must be X, ruling out\noptions A, B, and E. Now, we have to decide if Y or Z are the service\nprovider interface. We can tell because nothing has a direct dependency on\nthe service provider. Since this makes the service provider Y, the answer is\noption C."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Using the diagram in the previous question, which boxes represent the\nconsumer and service locator, respectively?",
      "responses": [{
        "code": "A",
        "value": "W and X"
      }, {
        "code": "B",
        "value": "W and Z"
      }, {
        "code": "C",
        "value": "X and Y"
      }, {
        "code": "D",
        "value": "X and Z"
      }, {
        "code": "E",
        "value": "Y and Z"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "14. B. The consumer depends on the service provider interface and service\nlocator, but not the service provider. Only W has two arrows starting from\nit so, it must be the consumer. This rules out options C, D, and E. The\nservice locator references the service provider interface directly and the\nservice provider indirectly, making the service locator Z and option B the\nanswer."
      }
    },
    "15": {
      "nbr": 15,
      "value": "What is the minimum number of JAR files you need for a cyclic\ndependency?",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "15. C. A cyclic dependency is when two things directly or indirectly depend\non each other. If chicken.jar depends on egg.jar, and egg.jar depends\non chicken.jar, we have a cyclic dependency. Since only two JAR files\nare needed to create this situation, option C is the answer."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Fill in the blank with code to look up and call a service.\nString cheese = ServiceLoader.load(Mouse.class)\n.map(______________)\n.map(Mouse::favoriteFood)\n.findFirst() .orElse(\"\");",
      "responses": [{
        "code": "A",
        "value": "Mouse.get()"
      }, {
        "code": "B",
        "value": "Mouse::get"
      }, {
        "code": "C",
        "value": "Provider.get()"
      }, {
        "code": "D",
        "value": "Provider::get"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "16. E. The ServiceLoader class has a load() method that returns a\nCollection of Provider, not a stream. Since the call to stream() is\nmissing, option E is the answer. If the call to stream() were added, option\nD would be the answer."
      }
    },
    "17": {
      "nbr": 17,
      "value": "Suppose we want to have two modules: com.ny and com.sf. Which is true\nabout the placement of the module‐info.java file(s)?",
      "responses": [{
        "code": "A",
        "value": "One module‐info.java file is required in position Z."
      }, {
        "code": "B",
        "value": "Two module‐info.java files are required, in positions V and X."
      }, {
        "code": "C",
        "value": "Two module‐info.java files are required, in positions W and Y."
      }, {
        "code": "D",
        "value": "Three module‐info.java files are required, in positions V, X, and Z."
      }, {
        "code": "E",
        "value": "Three module‐info.java files are required, in positions W, Y, and Z."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "17. C. Each module is required to have its own module‐info.java file in the\nroot directory of the module. For module com.ny, that is location W, and for\nmodule com.sf, that is location Y. Therefore, option B is correct."
      }
    },
    "18": {
      "nbr": 18,
      "value": "Consider the modules in the previous diagram. Suppose we want the code\nin module com.sf to depend on code in module com.ny. Which of the\nfollowing directives goes into module com.sf's module‐info file to\nconfigure that behavior?",
      "responses": [{
        "code": "A",
        "value": "export com.ny;"
      }, {
        "code": "B",
        "value": "exports com.ny;"
      }, {
        "code": "C",
        "value": "require com.ny;"
      }, {
        "code": "D",
        "value": "require com.ny.city;"
      }, {
        "code": "E",
        "value": "requires com.ny;"
      }, {
        "code": "F",
        "value": "requires com.ny.city;"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "18. E. Options A, C, and D are incorrect because export and require are not\nkeywords in modules. Option B is incorrect because that directive goes in\nthe com.ny module, not the com.sf one. Option E is correct rather than\noption F because the requires directive references a module name rather\nthan a package."
      }
    },
    "19": {
      "nbr": 19,
      "value": "Consider the modules diagram in question 17. Suppose we want the code in\nmodule com.sf to depend on code in module com.ny. Which of the\nfollowing directives goes into module com.ny's module‐info file to\nconfigure that behavior?",
      "responses": [{
        "code": "A",
        "value": "export com.ny;"
      }, {
        "code": "B",
        "value": "export com.ny.city;"
      }, {
        "code": "C",
        "value": "exports com.ny;"
      }, {
        "code": "D",
        "value": "exports com.ny.city;"
      }, {
        "code": "E",
        "value": "requires com.ny;"
      }, {
        "code": "F",
        "value": "requires com.ny.city;"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "19. D. Options A and B are incorrect because export is not a keyword in\nmodules. Option E belongs in the com.sf module, not the com.ny one.\nOption F is incorrect because the requires directive references a module\nname rather than a package. Finally, option D is the answer rather than\noption C because the exports directive references a package name rather\nthan a module."
      }
    },
    "20": {
      "nbr": 20,
      "value": "Suppose the consumer, service locator, service provider, and service\nprovider interface are each in separate modules. Which of the following\nbest describes the following module‐info file?\nmodule nature.tree {\nprovides nature.sapling.Tree with nature.tree.Maple\n}",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "20. E. The Maple class is intended to be an implementation of the Tree\ninterface. However, this interface needs to be accessible. This module is\nmissing a requires nature.sapling; statement, making option E the\ncorrect answer."
      }
    },
    "21": {
      "nbr": 21,
      "value": "Which options are commonly used when compiling a module?",
      "responses": [{
        "code": "A",
        "value": "‐d and ‐m"
      }, {
        "code": "B",
        "value": "‐d and ‐p"
      }, {
        "code": "C",
        "value": "‐m and ‐p"
      }, {
        "code": "D",
        "value": "‐d, ‐m, and ‐p"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "21. B. The –d option specifies the directory. The –p option specifies the\nmodule path. The –m option is not available on the javac command."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Which of the following are modules supplied by the JDK? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "java.base"
      }, {
        "code": "B",
        "value": "java.basic"
      }, {
        "code": "C",
        "value": "java.desktop"
      }, {
        "code": "D",
        "value": "java.sdk"
      }, {
        "code": "E",
        "value": "java.sql"
      }, {
        "code": "F",
        "value": "java.swing"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "E"
        ],
        "explanation": "22. A,C,E. The java.base module is automatically available to any module\nwithout specifying it, making option A correct. Options C and E are also\ncorrect because java.desktop and java.sql are modules supplied with the\nJDK. You do need to be able to identify built‐in modules for the exam."
      }
    },
    "23": {
      "nbr": 23,
      "value": "Which best describes a top‐down migration? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "The first step is to move all the modules to the module path."
      }, {
        "code": "B",
        "value": "The first step is to move a single module to the module path."
      }, {
        "code": "C",
        "value": "Most steps consist of changing an automatic module to a named\nmodule."
      }, {
        "code": "D",
        "value": "Most steps consist of changing an automatic module to a unnamed\nmodule."
      }, {
        "code": "E",
        "value": "Most steps consist of changing an unnamed module to an automatic\nmodule."
      }, {
        "code": "F",
        "value": "Most steps consist of changing an unnamed module to a named\nmodule"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "23. A,C. Option A is correct because a top‐down migration starts by moving\nall the modules to the module path as automatic modules. Then, the\nmigration changes each module from an automatic module to a named\nmodule, making option C the other correct answer."
      }
    },
    "24": {
      "nbr": 24,
      "value": "Suppose the consumer, service locator, service provider, and service\nprovider interface are each in separate modules. Which of the following\nbest describes the following module‐info file?\nmodule nature.tree {\nrequires nature.sapling;\nrequires nature.bush;\n}",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "24. A. Option A is correct because a consumer has two dependencies. It\nrequires both the service provider interface and the service locator."
      }
    },
    "25": {
      "nbr": 25,
      "value": "Suppose you have these two JARs from Java 8. Which steps, when taken\ntogether, would be the best way to make them modules? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Add a module‐info.java to each."
      }, {
        "code": "B",
        "value": "Add them to the classpath."
      }, {
        "code": "C",
        "value": "Create a third module to contain the common code."
      }, {
        "code": "D",
        "value": "Merge them into one module to break the cyclic dependency."
      }, {
        "code": "E",
        "value": "Rename the modules to use dashes instead of dots."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "25. A,C. Option A is correct, and option B is incorrect as we want to create\nnamed modules when possible. We also need to be on the lookout for cyclic\ndependencies. While option D would work, it is better to be more granular\nand create a third module as in option C. Option E is incorrect because dots\nare used as separators in names."
      }
    },
    "26": {
      "nbr": 26,
      "value": "Which command produces output such as the following?\nanimal.puppy -> animal.dog",
      "responses": [{
        "code": "A",
        "value": "jdeps –d zoo.animal.puppy.jar"
      }, {
        "code": "B",
        "value": "jdeps –s zoo.animal.puppy.jar"
      }, {
        "code": "C",
        "value": "jmod –d zoo.animal.puppy.jar"
      }, {
        "code": "D",
        "value": "jmod –s zoo.animal.puppy.jar"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "26. B. The jdeps command lists information about dependencies within a\nmodule. The –s option provides a summary of output rather than verbose\noutput, making option B the correct answer. There is no –d option. The\njmod command is for working with JMOD files."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Suppose the consumer, service locator, service provider, and service\nprovider interface are each in separate modules. Which of the following\nbest describes the following module‐info file?\nmodule nature.tree{\nrequires nature.sapling;\nprovides nature.sapling.Tree with nature.tree.Maple\n}",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "27. C. Option C is correct because a service provider requires the interface.\nIt also provides the implementation."
      }
    },
    "28": {
      "nbr": 28,
      "value": "Suppose we have module com.bird that contains package com.bird.tweet\nand class Tweety with a main() method. Which of the following can fill in\nthe blank to run this program?\njava --module-path mods –module _____________",
      "responses": [{
        "code": "A",
        "value": "com.bird.Tweety"
      }, {
        "code": "B",
        "value": "com.bird.tweety.Tweety"
      }, {
        "code": "C",
        "value": "com.bird/Tweety"
      }, {
        "code": "D",
        "value": "com.bird.tweet/Tweety"
      }, {
        "code": "E",
        "value": "com.bird/com.bird.tweet.Tweety"
      }, {
        "code": "F",
        "value": "com.bird.tweet/com.bird.Tweety"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "28. E. When running a module, the module name is listed before the slash, and\nthe fully qualified class name is after the slash. Option E is the only one that\nmeets this criterion."
      }
    },
    "29": {
      "nbr": 29,
      "value": "Which types of modules are required to contain a module‐info file?",
      "responses": [{
        "code": "A",
        "value": "Automatic only"
      }, {
        "code": "B",
        "value": "Named only"
      }, {
        "code": "C",
        "value": "Unnamed only"
      }, {
        "code": "D",
        "value": "Automatic and named"
      }, {
        "code": "E",
        "value": "Automatic and unnamed"
      }, {
        "code": "F",
        "value": "Named and unnamed"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "29. B. An unnamed module is on the classpath. While it is permitted to have a\nmodule‐info file, the file is ignored if present. An automatic module is on\nthe module path and does not have a module‐info file. A named module is\nrequired to have a module‐info file, making option B the correct answer."
      }
    },
    "30": {
      "nbr": 30,
      "value": "Suppose the consumer, service locator, service provider, and service\nprovider interface are each in separate modules. Which of the following\nbest describes the following module‐info file?\nmodule nature.tree{\nexports nature.tree.leaf;\nrequires nature.sapling;\nuses nature.tree.Photosynthesis;\n}",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "30. B. Option B is correct because a service locator uses the interface. It also\nrequires the service provider interface module and exports the package\nwith the locator."
      }
    },
    "31": {
      "nbr": 31,
      "value": "What is a benefit of using modules? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Better access control"
      }, {
        "code": "B",
        "value": "Custom Java builds"
      }, {
        "code": "C",
        "value": "Elimination of JAR files"
      }, {
        "code": "D",
        "value": "Fewer .java files needed in your application"
      }, {
        "code": "E",
        "value": "Not necessary to specify types of local variables"
      }, {
        "code": "F",
        "value": "Write once, run anywhere"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B"
        ],
        "explanation": "31. A,B. Option A is correct because modules provide a mechanism to export\nspecific packages. This creates module‐level access since some packages\ncan be used only in a module. Option B is correct because jlink allows\ncreating a distribution with just the parts of the JDK that are needed. Option\nC is not correct because modules are usually distributed as a JAR file.\nOption D is incorrect because modules actually require one extra file:\nmodule‐info.java. Option E is incorrect because var can be used with or\nwithout modules. Finally, option F is incorrect because “write once, run\nanywhere” is a core benefit of Java independent of modules."
      }
    },
    "32": {
      "nbr": 32,
      "value": "Suppose the consumer, service locator, service provider, and service\nprovider interface are each in separate modules. Which of the following\nbest describes the following module‐info file?\nmodule nature.tree{\nrequires nature.sapling;\n}",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "32. E. A consumer requires both the service locator and service provider\ninterface. A service locator and service provider interface need to have an\nexports statement. A service provider needs a provides directive. Since\nnone of them matches, option E is the correct answer."
      }
    },
    "33": {
      "nbr": 33,
      "value": "Which types of modules are allowed to contain a module‐info file?",
      "responses": [{
        "code": "A",
        "value": "Automatic only"
      }, {
        "code": "B",
        "value": "Named only"
      }, {
        "code": "C",
        "value": "Unnamed only"
      }, {
        "code": "D",
        "value": "Automatic and named"
      }, {
        "code": "E",
        "value": "Automatic and unnamed"
      }, {
        "code": "F",
        "value": "Named and unnamed"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "33. F. An unnamed module is permitted to have a module‐info file, but the\nfile is ignored if present. An automatic module does not have a moduleinfo\nfile. A named module is required to have a module‐info file.\nTherefore, option F is correct."
      }
    },
    "34": {
      "nbr": 34,
      "value": "Which of the following is true of the following module declaration?\n1: class com.mammal {\n2: exports com.mammal.cat;\n3: exports cat.mammal.mouse to com.mice;\n4: uses com.animal;\n5: }",
      "responses": [{
        "code": "A",
        "value": "The first line that fails to compile is line 1."
      }, {
        "code": "B",
        "value": "The first line that fails to compile is line 2."
      }, {
        "code": "C",
        "value": "The first line that fails to compile is line 3."
      }, {
        "code": "D",
        "value": "The first line that fails to compile is line 4."
      }, {
        "code": "E",
        "value": "The code compiles."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "34. A. A module‐info file is required to start with module rather than class.\nTherefore, the first line doesn't compile, and option A is correct."
      }
    },
    "35": {
      "nbr": 35,
      "value": "How many of these keywords can be used in a module‐info.java file:\ncloses, export, import, require, and uses?",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "35. B. You need to know these keywords: exports, requires, requires\ntransitive, provides, opens, and uses. Of these, only uses is in the list of\ncandidates in the question. Note that export and require are invalid\nbecause they should be exports and requires, respectively."
      }
    },
    "36": {
      "nbr": 36,
      "value": "Suppose the consumer, service locator, service provider, and service\nprovider interface are each in separate modules. Which of the following\nbest describes the following module‐info file?\nmodule nature.tree{\nexports nature.tree.leaf;\n}",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "36. D. Option D is correct because a service provider interface exposes the\ninterface without depending on any of the other options."
      }
    },
    "37": {
      "nbr": 37,
      "value": "Which of the following are modules supplied by the JDK? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "jdk.base"
      }, {
        "code": "B",
        "value": "jdk.basic"
      }, {
        "code": "C",
        "value": "jdk.desktop"
      }, {
        "code": "D",
        "value": "jdk.javadoc"
      }, {
        "code": "E",
        "value": "jdk.jdeps"
      }, {
        "code": "F",
        "value": "jdk.net"
      }
      ],
      "answer": {
        "codes": [
          "D",
          "E",
          "F"
        ],
        "explanation": "37. D,E,F. The java.base module is automatically available to any module\nwithout specifying it. However, this question tries to trick you with option\nA by specifying jdk.base instead. Similarly, java.desktop exists, but not\njdk.deskop, making option C wrong. Options D, E, and F are correct\nbecause jdk.javadoc, jdk.jdeps, and jdk.net are modules supplied with\nthe JDK. You do need to be able to recognize the names of built‐in\nmodules."
      }
    },
    "38": {
      "nbr": 38,
      "value": "Which are true statements about types of migration? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "All modules are immediately moved to the module path in a bottom‐up\nmigration."
      }, {
        "code": "B",
        "value": "All modules are immediately moved to the module path in a top‐down\nmigration."
      }, {
        "code": "C",
        "value": "Modules migrate before the modules that depend on them in a bottomup\nmigration."
      }, {
        "code": "D",
        "value": "Modules migrate before the modules that depend on them in a topdown\nmigration."
      }, {
        "code": "E",
        "value": "Modules that are not yet named modules are automatic modules in a\nbottom‐up migration."
      }, {
        "code": "F",
        "value": "Modules that are not yet named modules are automatic modules in a\ntop‐down migration"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "F"
        ],
        "explanation": "38. B,C,F. A top‐down migration starts by moving all the modules to the\nmodule path as automatic modules, making options B and F correct. A\nbottom‐up migration moves each module after all modules it depends on\nhave been migrated, making option C correct."
      }
    },
    "39": {
      "nbr": 39,
      "value": "A class in which of the following parts of a module service should include a\nmethod call to load(ChocolateLab.class) that would allow callers to use\nit?",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "39. B. The service locator contains a load() method, making option B correct."
      }
    },
    "40": {
      "nbr": 40,
      "value": "How many of these module declarations are valid?\nmodule com.leaf {}\nmodule com.leaf2 {}\nmodule com-leaf { }\nmodule LEAF {}\nmodule leaf2 {}",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "40. E. Module names are permitted to be any valid variable name with the\naddition of dot separators (.). The only one that is problematic is com‐leaf\nbecause dashes are not allowed, making option E correct. As a reminder,\nnumbers are permitted as long as they are not the first character in a\nsegment. Capital letters are discouraged but allowed."
      }
    },
    "41": {
      "nbr": 41,
      "value": "Which is a benefit of ServiceLoader?",
      "responses": [{
        "code": "A",
        "value": "It allows you to add functionality without recompiling the application."
      }, {
        "code": "B",
        "value": "It allows you to load a service written in C++."
      }, {
        "code": "C",
        "value": "It is an interface."
      }, {
        "code": "D",
        "value": "When implementing a service, it references the ServiceLoader."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "41. A. Option A is correct because ServiceLoader allows you to make your\napplication extensible. A service can be added without recompiling the\nentire application. It is a class, but the service provider implementation does\nnot reference it, making options C and D incorrect. Option B is not a feature\nof Java."
      }
    },
    "42": {
      "nbr": 42,
      "value": "Which are true statements? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Code on the classpath can reference code in automatic, named, and\nunnamed modules."
      }, {
        "code": "B",
        "value": "Code on the classpath can reference code in named modules, but not\nautomatic and unnamed modules."
      }, {
        "code": "C",
        "value": "Code on the classpath can reference code in automatic and named\nmodules, but not unnamed modules."
      }, {
        "code": "D",
        "value": "Code on the module path can reference code in automatic, named, and\nunnamed modules."
      }, {
        "code": "E",
        "value": "Code on the module path can reference code in named modules, but\nnot automatic and unnamed modules."
      }, {
        "code": "F",
        "value": "Code on the module path can reference code in automatic and named\nmodules, but not unnamed modules."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "F"
        ],
        "explanation": "42. A,F. Code on the classpath has not yet been migrated to modules and can\nreference any code in the application. This is true whether that code is in\nautomatic, named, or unnamed modules, matching option A. Code on the\nmodule path operates in a stricter world and cannot reference code on the\nclasspath. Since unnamed modules cannot be accessed in this situation,\noption F is the second answer."
      }
    },
    "43": {
      "nbr": 43,
      "value": "Suppose we have the packages in the diagram. What could we add to the\nmodule‐info.java in com.duck to allow the com.park module to reference\nthe Duckling class but not allow the com.bread module to do the same?",
      "responses": [{
        "code": "A",
        "value": "exports com.duckling;"
      }, {
        "code": "B",
        "value": "exports com.duckling from com.park;"
      }, {
        "code": "C",
        "value": "exports com.duckling to com.park;"
      }, {
        "code": "D",
        "value": "exports com.park from com.duckling;"
      }, {
        "code": "E",
        "value": "exports com.park to com.duckling;"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "43. C. Option A is incorrect because it exports the package to all modules.\nOption C is correct because it limits package sharing to the com.park\nmodule. Option E is incorrect because a package must be exported from the\nmodule that contains it. Options B and D are incorrect because from is not\nvalid syntax."
      }
    },
    "44": {
      "nbr": 44,
      "value": "Given the diagram in the previous question, what could we add to moduleinfo.\njava in com.duck to allow the com.park package to reference the\nDuckling class, but not allow the Egg class to reference the Duckling class?",
      "responses": [{
        "code": "A",
        "value": "exports com.duckling;"
      }, {
        "code": "B",
        "value": "exports com.duckling from com.park;"
      }, {
        "code": "C",
        "value": "exports com.duckling to com.park;"
      }, {
        "code": "D",
        "value": "exports com.park from com.duckling;"
      }, {
        "code": "E",
        "value": "exports com.park to com.duckling;"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "44. F. It is not possible to provide access outside the module while also\nlimiting access within the com.duck module. Options A and C are tempting\nbecause they do provide access in com.park. However, they do not prevent\nthe Egg class in the com.egg package from accessing the com.duckling\npackage. Remember that the com.egg package is in the com.duck module,\nso the access cannot be restricted. Therefore, option F is correct."
      }
    },
    "45": {
      "nbr": 45,
      "value": "Given the diagram in question 43 and the correct export statement to share\nonly com.duckling, which of the following should be included in the\nmodule‐info.java file of com.park to specify that com.park should have\naccess to the com.duckling and com.bread packages, but not the com.egg\npackage?",
      "responses": [{
        "code": "A",
        "value": "require com.duck, com.bread;"
      }, {
        "code": "B",
        "value": "requires com.duck; com.bread;"
      }, {
        "code": "C",
        "value": "require com.duckling, com.bread;"
      }, {
        "code": "D",
        "value": "requires com.duckling; com.bread;"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "45. E. The correct way to specify this is requires com.duck; requires\ncom.bread;. There is no way to combine two module requires statements\ninto one. Additionally, note that the requires statement works with a\nmodule name, not a package name."
      }
    },
    "46": {
      "nbr": 46,
      "value": "Which is both part of the service and has a provides directive?",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "46. E. Only the service provider has a provides directive. Since it is not part\nof the service, option E is the correct answer."
      }
    },
    "47": {
      "nbr": 47,
      "value": "What command is the simplest way to list suggestions for classes in\njdk.unsupported?",
      "responses": [{
        "code": "A",
        "value": "jdeps cookie.jar"
      }, {
        "code": "B",
        "value": "jdeps –s cookie.jar"
      }, {
        "code": "C",
        "value": "jdeps –jdkinternals cookie.jar"
      }, {
        "code": "D",
        "value": "jdeps ‐‐jdkinternals cookie.jar"
      }, {
        "code": "E",
        "value": "jdeps ‐jdkunsupported cookie.jar"
      }, {
        "code": "F",
        "value": "jdeps ‐‐jdkunsupported cookie.jar"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "47. D. Both options A and B note that the JAR depends on the\njdk.unsupported module. However, they do not list suggested\nreplacements. Options C and E are invalid because flags of this format need\ntwo dashes. Option D is correct and option F is incorrect because the\ndesired flag is ‐‐jdkinternals. Note that ‐‐jdk‐internals is also\nacceptable."
      }
    },
    "48": {
      "nbr": 48,
      "value": "Which modules are on the classpath?",
      "responses": [{
        "code": "A",
        "value": "Automatic only"
      }, {
        "code": "B",
        "value": "Named only"
      }, {
        "code": "C",
        "value": "Unnamed only"
      }, {
        "code": "D",
        "value": "Automatic and named"
      }, {
        "code": "E",
        "value": "Automatic and unnamed"
      }, {
        "code": "F",
        "value": "Named and unnamed"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "48. C. Option C is correct because only unnamed modules are on the\nclasspath."
      }
    },
    "49": {
      "nbr": 49,
      "value": "Which line of code belongs in a service locator?",
      "responses": [{
        "code": "A",
        "value": "ServiceLoader loader = ServiceLoader.load();"
      }, {
        "code": "B",
        "value": "ServiceLoader loader = ServiceLoader.load(Mouse.class);"
      }, {
        "code": "C",
        "value": "ServiceLoader<Mouse> loader = ServiceLoader.load();"
      }, {
        "code": "D",
        "value": "ServiceLoader<Mouse> loader =\nServiceLoader.load(Mouse.class);"
      }, {
        "code": "E",
        "value": "Mouse loader = ServiceLoader.load();"
      }, {
        "code": "F",
        "value": "Mouse loader = ServiceLoader.load(Mouse .class);"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "49. D. The service locator contains a ServiceLoader call to look up the\nservice loader. It takes the type of class it looked up as a parameter and\nreturns a generic, making option D the correct answer."
      }
    },
    "50": {
      "nbr": 50,
      "value": "Which is true about a service? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Changing the service provider interface always requires recompiling\nthe service provider."
      }, {
        "code": "B",
        "value": "Changing the service provider interface sometimes requires\nrecompiling the service provider."
      }, {
        "code": "C",
        "value": "Changing the service provider interface never requires recompiling the\nservice provider."
      }, {
        "code": "D",
        "value": "If the service provider interface references other classes in the method\nsignatures, they are considered part of the service."
      }, {
        "code": "E",
        "value": "If the service provider interface references other classes in the method\nsignatures, they are not considered part of the service."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "50. B,D. Option B is correct because it depends on the change. If a method is\nadded to the service provider interface or a public method is changed, the\nservice providers must be recompiled. However, if a change is made that\ndoes not affect the service provider, such as a new static method,\nrecompilation is not needed. Option D is also correct because return types\nand parameter types are considered part of the service."
      }
    },
    "51": {
      "nbr": 51,
      "value": "Which modules are on the module path?",
      "responses": [{
        "code": "A",
        "value": "Automatic only"
      }, {
        "code": "B",
        "value": "Named only"
      }, {
        "code": "C",
        "value": "Unnamed only"
      }, {
        "code": "D",
        "value": "Automatic and named"
      }, {
        "code": "E",
        "value": "Automatic and unnamed"
      }, {
        "code": "F",
        "value": "Named and unnamed"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "51. D. Unnamed modules are on the classpath. Option D is correct because\nautomatic and named modules are on the module path."
      }
    },
    "52": {
      "nbr": 52,
      "value": "The service locator and service provider interface share a module. Which\nboxes represent the consumer and service provider, respectively?",
      "responses": [{
        "code": "A",
        "value": "X and Y"
      }, {
        "code": "B",
        "value": "X and Z"
      }, {
        "code": "C",
        "value": "Y and Z"
      }, {
        "code": "D",
        "value": "Z and Z"
      }, {
        "code": "E",
        "value": "Z and Y"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "52. F. The consumer needs to depend on the shared module, making it X. The\nshared module then has to be Z, and the service provider has to be Y.\nHowever, the service provider should not know about the consumer, and\nthe dotted line in the diagram does not make sense. This means none of the\noptions can create a valid scenario, and option F is the correct answer."
      }
    },
    "53": {
      "nbr": 53,
      "value": "What command is the simplest way to list what modules a JAR depends on\nwithout listing package names?",
      "responses": [{
        "code": "A",
        "value": "jdeps cookie.jar"
      }, {
        "code": "B",
        "value": "jdeps –s cookie.jar"
      }, {
        "code": "C",
        "value": "jdeps –jdkinternals cookie.jar"
      }, {
        "code": "D",
        "value": "jdeps ‐‐jdkinternals cookie.jar"
      }, {
        "code": "E",
        "value": "jdeps ‐jdk‐unsupported cookie.jar"
      }, {
        "code": "F",
        "value": "jdeps ‐‐jdk‐unsupported cookie.jar"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "53. B. Without any command line flags, jdeps lists packages and module\ndependencies. The ‐s flag provides a summary omitting the package name,\nwhich means option B is the correct answer."
      }
    },
    "54": {
      "nbr": 54,
      "value": "What is a benefit of using modules? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Ability to reuse code"
      }, {
        "code": "B",
        "value": "Clearer dependency management"
      }, {
        "code": "C",
        "value": "Improved performance"
      }, {
        "code": "D",
        "value": "Multithreading support"
      }, {
        "code": "E",
        "value": "Platform independence"
      }, {
        "code": "F",
        "value": "Unique package enforcement"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "F"
        ],
        "explanation": "54. B,C,F. Options A, D, and E are incorrect because they are benefits of Java\neven without modules. Option B is correct because the module‐info file\nclarifies dependencies. Option C is correct because a smaller deployment\npackage can be faster. Finally, option F is correct because the module\nsystem prevents the same package from being used from multiple JAR files."
      }
    },
    "55": {
      "nbr": 55,
      "value": "Fill in the blanks to list a way of getting a lot of information useful in\ndebugging modules:\n_______ -m x –p y --______________",
      "responses": [{
        "code": "A",
        "value": "jar and –show‐modules"
      }, {
        "code": "B",
        "value": "jar and –show‐module‐detail"
      }, {
        "code": "C",
        "value": "jar and –show‐module‐resolution"
      }, {
        "code": "D",
        "value": "java and –show‐modules"
      }, {
        "code": "E",
        "value": "java and –show‐module‐detail"
      }, {
        "code": "F",
        "value": "java and –show‐module‐resolution"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "55. F. The first clue is that the ‐m and ‐p options are on the java command.\nBeyond that, you need to memorize the name of the ‐‐show‐moduleresolution\noption."
      }
    },
    "56": {
      "nbr": 56,
      "value": "Suppose you have the following interface in a module named\nanimal.insect.api. What needs to be included in the module‐info file for\nit to be a service provider interface?\npackage animal.insect.api.bugs;\npublic interface Bug {\nint crawl();\n}",
      "responses": [{
        "code": "A",
        "value": "exports animal.insect.api;"
      }, {
        "code": "B",
        "value": "exports animal.insect.api.bugs;"
      }, {
        "code": "C",
        "value": "exports animal.insect.api.bugs.Bug;"
      }, {
        "code": "D",
        "value": "requires animal.insect.api;"
      }, {
        "code": "E",
        "value": "requires animal.insect.api.bugs;"
      }, {
        "code": "F",
        "value": "requires animal.insect.api.bugs.Bug;"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "56. B. This module is a service provider interface. The only requirement is\nthat the module needs to export the package containing the interface. In this\ncase, that is the animal.insect.api.bugs package, which matches option\nB."
      }
    },
    "57": {
      "nbr": 57,
      "value": "Suppose you have the following class in a module named\nanimal.insect.impl and the service provider interface module from\nquestion 56. What needs to be included in the module‐info for it to be a\nservice provider? (Choose two.)\npackage animal.insect.impl;\nimport animal.insect.api.bugs.Bug;\npublic class Worm implements Bug {\n@Override\npublic int crawl() {\nreturn 1;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "requires animal.insect.api.bugs;"
      }, {
        "code": "B",
        "value": "requires animal.insect.lookup;"
      }, {
        "code": "C",
        "value": "requires animal.printer;"
      }, {
        "code": "D",
        "value": "provides animal.insect.impl.Worm;"
      }, {
        "code": "E",
        "value": "provides animal.insect.api.bugs.Bug with\nanimal.insect.impl.Worm;"
      }, {
        "code": "F",
        "value": "provides animal.insect.impl.Worm with\nanimal.insect.api.bugs.Bug;"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "57. A,E. This module is a service provider. It needs a requires directive for\nthe service provider interface, which is option A. It also needs a provides\ndirective, which specifies both the interface and implementation. Option E\nhas both in the correct order."
      }
    },
    "58": {
      "nbr": 58,
      "value": "Suppose you have the following class in a module named\nanimal.insect.lookup, the service provider interface from question 56,\nand the service provider from question 57. What needs to be included in the\nmodule‐info file besides an exports directive for it to be a service locator?\n(Choose two.)\npackage animal.insect.lookup;\nimport animal.insect.api.bugs.Bug;\nimport java.util.List;\nimport java.util.ServiceLoader;\nimport java.util.stream.Collectors;\npublic class InsectFinder {\npublic static List<Bug> findAllBugs() {\nreturn ServiceLoader.load(Bug.class)\n.stream()\n.map(ServiceLoader.Provider::get)\n.collect(Collectors.toList());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "provides animal.insect.lookup;"
      }, {
        "code": "B",
        "value": "provides animal.insect.lookup.InsectFinder;"
      }, {
        "code": "C",
        "value": "requires animal.insect.api.bugs;"
      }, {
        "code": "D",
        "value": "requires animal.insect.api.Bug;"
      }, {
        "code": "E",
        "value": "uses animal.insect.api.bugs;"
      }, {
        "code": "F",
        "value": "uses animal.insect.api.bugs.Bug;"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "58. C,F. This module is a service locator. It needs three directives: exports,\nrequires, and uses. The requires directive specifies the module it\ndepends on, which is option C. The uses directive specifies the service\nprovider interface it references, which is option F."
      }
    },
    "59": {
      "nbr": 59,
      "value": "Suppose you have the following class in a module named\nanimal.insect.printer, the service provider interface from question 56,\nthe service provider from question 57, and the service locator from question\n58. What needs to be included in the module‐info for it to be a consumer?\n(Choose two.)\npackage animal.printer;\nimport animal.insect.lookup.InsectFinder;\npublic class Print {\npublic static void main(String[] args) {\nvar bugs = InsectFinder.findAllBugs();\nbugs.forEach(System.out::println);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "requires animal.insect.api.bugs;"
      }, {
        "code": "B",
        "value": "requires animal.insect.lookup;"
      }, {
        "code": "C",
        "value": "requires animal.printer;"
      }, {
        "code": "D",
        "value": "uses animal.insect.api.bugs;"
      }, {
        "code": "E",
        "value": "uses animal.insect.api.bugs.Bug;"
      }, {
        "code": "F",
        "value": "uses animal.insect.lookup.InsectFinder;"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B"
        ],
        "explanation": "59. A,B. This module is a consumer. It needs two requires directives. Option\nA represents the service provider interface, and option B represents the\nservice locator. The uses directive should be in the service locator, not the\nconsumer."
      }
    },
    "60": {
      "nbr": 60,
      "value": "What command is the simplest way to list what modules a JAR depends on\nincluding package names?",
      "responses": [{
        "code": "A",
        "value": "jdeps cookie.jar"
      }, {
        "code": "B",
        "value": "jdeps –s cookie.jar"
      }, {
        "code": "C",
        "value": "jdeps –jdkinternals cookie.jar"
      }, {
        "code": "D",
        "value": "jdeps ‐‐jdkinternals cookie.jar"
      }, {
        "code": "E",
        "value": "jdeps ‐jdk‐unsupported cookie.jar"
      }, {
        "code": "F",
        "value": "jdeps ‐‐jdk‐unsupported cookie.jar"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "60. A. Without any command line flags, jdeps lists packages and module\ndependencies, making option A correct. Option D will also list the\npackages; however, it is longer than option A."
      }
    },
    "61": {
      "nbr": 61,
      "value": "How many modules are part of the cyclic dependency?\nmodule com.light {\nexports com.light;\n}\nmodule com.animal {\nexports com.animal;\nrequires com.light;\nrequires com.plant;\n}\nmodule com.plant {\nexports com.plant;\nrequires com.light;\nrequires com.animal;\n}\nmodule com.worm {\nexports com.worm;\nrequires com.light;\nrequires com.animal;\nrequires com.plant;\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "61. C. The com.light module does not have any dependencies, so it is fine.\nHowever, com.animal and com.plant depend on each other giving us a\ncyclic dependency. Finally, com.worm depends on all the modules but does\nnot introduce any more problems. It will not compile until com.animal or\ncom.plant are fixed, but is not part of the cycle itself. Option C is correct,\nsince only two modules are part of the cycle."
      }
    },
    "62": {
      "nbr": 62,
      "value": "What is true about the ‐d option?",
      "responses": [{
        "code": "A",
        "value": "It can be used with the jar command, but not the java command."
      }, {
        "code": "B",
        "value": "It can be used with the java command, but not the jar command."
      }, {
        "code": "C",
        "value": "It can be used with the jar and java commands and serves the same\npurpose for both."
      }, {
        "code": "D",
        "value": "It can be used with the jar and java commands, but means “directory”\nfor the former and “describe module” for the later."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "62. C. The ‐d option is a shorthand for ‐‐describe‐module on both the jar\nand java commands. Therefore, option C is correct."
      }
    },
    "63": {
      "nbr": 63,
      "value": "Assuming all referenced files and directories exist and are correct, what\ndoes this code do?\njavac –m mods –d mouse mouse/com/mouse/*.java\nmouse/module-info.java\njar –cvf mods/com.mouse.jar –C mouse/ .",
      "responses": [{
        "code": "A",
        "value": "Creates a JAR file representing the com.mouse module"
      }, {
        "code": "B",
        "value": "Creates a JAR file that is not a module"
      }, {
        "code": "C",
        "value": "Fails on the javac command"
      }, {
        "code": "D",
        "value": "Fails on the jar command"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "63. C. The javac command takes ‐p for the module path rather than ‐m. Since\nthere is no –m on the javac command, option C is the correct answer."
      }
    },
    "64": {
      "nbr": 64,
      "value": "What module is always in the jdeps output?",
      "responses": [{
        "code": "A",
        "value": "java.base"
      }, {
        "code": "B",
        "value": "java.lang"
      }, {
        "code": "C",
        "value": "java.self"
      }, {
        "code": "D",
        "value": "jdk.base"
      }, {
        "code": "E",
        "value": "jdk.lang"
      }, {
        "code": "F",
        "value": "jdk.self"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "64. A. Option B is tempting because the java.lang package is available to all\nclasses. However, the question asks about modules. Option A is the correct\nanswer because the java.base module is available to all modules. The\nother options are incorrect because those modules do not exist."
      }
    },
    "65": {
      "nbr": 65,
      "value": "Which are valid modes on the jmod command? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "create"
      }, {
        "code": "B",
        "value": "list"
      }, {
        "code": "C",
        "value": "hash"
      }, {
        "code": "D",
        "value": "show"
      }, {
        "code": "E",
        "value": "verbose"
      }, {
        "code": "F",
        "value": "version"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "C"
        ],
        "explanation": "65. A,B,C. The jmod command has five possible modes: create, extract,\ndescribe, list, and hash."
      }
    },
    "66": {
      "nbr": 66,
      "value": "This diagram shows the second step of a migration to modules. What type\nof migration is this?",
      "responses": [{
        "code": "A",
        "value": "Bottom‐up."
      }, {
        "code": "B",
        "value": "Side‐to‐side."
      }, {
        "code": "C",
        "value": "Top‐down."
      }, {
        "code": "D",
        "value": "There is not enough information to determine which type it is."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "66. A. There is no such thing as a side‐to‐side migration, ruling out option B.\nIn a top‐down migration, all modules are moved to the module path first,\nmaking option C incorrect. In a bottom‐up migration, modules are moved,\nstarting with those without dependencies. Therefore, option A is correct."
      }
    },
    "67": {
      "nbr": 67,
      "value": "Which are true statements about the diagram and scenario in the previous\nquestion? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "butterfly is an automatic module."
      }, {
        "code": "B",
        "value": "butterfly is a named module."
      }, {
        "code": "C",
        "value": "butterfly is an unnamed module."
      }, {
        "code": "D",
        "value": "caterpillar is an automatic module."
      }, {
        "code": "E",
        "value": "caterpillar is a named module."
      }, {
        "code": "F",
        "value": "caterpillar is an unnamed module."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "67. C,E. In a bottom‐up migration, the lowest‐level modules are migrated to\nnamed modules on the module path first. This makes option E one of the\nanswers. The modules that remain on the classpath are unnamed modules,\nmaking option C the other answer."
      }
    },
    "68": {
      "nbr": 68,
      "value": "Suppose we have the two JARs in the diagram on the module path and the\nmodule‐info in the com.magic jar only exports one package:\ncom.magic.unicorn. There is no module‐info file in the com.science\nJAR. How many of the four packages in the diagram can a third module on\nthe module path access?",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "68. D. The com.magic module exports only one package. This makes the\ncom.magic.unicorn package accessible, but not the com.magic.dragon\npackage. Both packages in com.science are accessible because it is an\nautomatic module. When a module on the module path does not contain a\nmodule‐info file, all packages are exported. This gives us three packages\nthat are accessible and a correct answer of option D."
      }
    },
    "69": {
      "nbr": 69,
      "value": "Suppose the two JARs described in the previous question are on the\nclasspath. How many of the four packages in the diagram can a module on\nthe module path access?",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "69. A. Modules on the module path cannot access anything from the classpath,\nmaking option A the correct answer."
      }
    },
    "70": {
      "nbr": 70,
      "value": "What is true about the following module‐info.java file?\nmodule Book { }",
      "responses": [{
        "code": "A",
        "value": "It does not compile because it is empty."
      }, {
        "code": "B",
        "value": "It does not compile because the module name is uppercase."
      }, {
        "code": "C",
        "value": "It does not compile because the module name has only one component."
      }, {
        "code": "D",
        "value": "It does not compile for another reason."
      }, {
        "code": "E",
        "value": "It compiles."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "70. E. Option E is correct as this code does compile. While it is uncommon, a\nmodule is not required to have any directives in the body. Similarly, module\nnames are lowercase and have more than one component by convention.\nNone of these problems prevents the file from compiling, though."
      }
    },
    "71": {
      "nbr": 71,
      "value": "When adding a new service provider, which of these do you need to\nrecompile?",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Existing service providers"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "71. E. One of the benefits of services is not having to recompile existing code\nwhen adding a new implementation. This makes option E the correct\nanswer."
      }
    },
    "72": {
      "nbr": 72,
      "value": "When working with modules, what option names are equivalent to ‐m and\n‐s?",
      "responses": [{
        "code": "A",
        "value": "‐‐module and ‐‐short"
      }, {
        "code": "B",
        "value": "‐‐module and ‐‐statistics"
      }, {
        "code": "C",
        "value": "‐‐module and ‐‐summary"
      }, {
        "code": "D",
        "value": "‐‐module‐path and ‐‐short"
      }, {
        "code": "E",
        "value": "‐‐module‐path and ‐‐statistics"
      }, {
        "code": "F",
        "value": "‐‐module‐path and ‐‐summary"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "72. C. The java command uses ‐m and ‐‐module to supply the module name.\nThe jdeps command uses ‐s and ‐‐summary to specify the output should be\nlimited. Option C matches both of these."
      }
    },
    "73": {
      "nbr": 73,
      "value": "Which are considered part of a service?",
      "responses": [{
        "code": "A",
        "value": "Classes referenced by the implementation, but not the interface"
      }, {
        "code": "B",
        "value": "Classes referenced by the interface, but not the implementation"
      }, {
        "code": "C",
        "value": "Classes referenced by either the implementation or the interface"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "73. B. A service is comprised of the interface, any classes the interface\nreferences, and a way to look up implementations of the interface. It does\nnot include the implementation. This makes option A the correct answer."
      }
    },
    "74": {
      "nbr": 74,
      "value": "Which commands have the options ‐m and –s to represent modules and\nsummary, respectively?",
      "responses": [{
        "code": "A",
        "value": "javac and jar"
      }, {
        "code": "B",
        "value": "javac and jdeps"
      }, {
        "code": "C",
        "value": "javac and jmod"
      }, {
        "code": "D",
        "value": "java and jar"
      }, {
        "code": "E",
        "value": "java and jdeps"
      }, {
        "code": "F",
        "value": "java and jmod"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "74. E. Option E is correct because both java and jdeps meet the criteria. The\njar command does as well although the options mean different things than\nworking with modules."
      }
    },
    "75": {
      "nbr": 75,
      "value": "Suppose you have the following class in a module named\nanimal.insect.impl. Which two most likely go in the module‐info of the\nservice locator? (Choose two.)\npackage animal.insect.impl;\nimport animal.insect.api.bugs.Bug;\npublic class Worm implements Bug {\n@Override\npublic int crawl() {\nreturn 1;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "requires animal.insect.api.bugs;"
      }, {
        "code": "B",
        "value": "requires animal.insect.api.bugs.Bug;"
      }, {
        "code": "C",
        "value": "requires animal.insect.impl;"
      }, {
        "code": "D",
        "value": "uses animal.insect.api.bugs;"
      }, {
        "code": "E",
        "value": "uses animal.insect.api.bugs.Bug;"
      }, {
        "code": "F",
        "value": "uses animal.insect.api.bugs.Bug with\nanimal.insect.impl.Worm;"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "75. A,E. This question is tricky because the service provider code is shown,\nbut the question asks about the service locator, and you need to infer\ninformation about the service provider interface. The requires directive is\noption A due to process of elimination. Option B is incorrect because the\nrequires directive references a module name rather than an interface.\nOption C is incorrect because we need the service provider interface\nmodule, and it refers to the service provider module. Option E is easier,\nsince the uses directive works with an interface name."
      }
    },
    "76": {
      "nbr": 76,
      "value": "Which statements are true? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "A bottom‐up migration has more steps involving the classpath than a\ntop‐down migration."
      }, {
        "code": "B",
        "value": "A top‐down migration has more steps involving the classpath than a\nbottom‐up migration."
      }, {
        "code": "C",
        "value": "Both types of migration have the same number of steps involving the\nclasspath."
      }, {
        "code": "D",
        "value": "A bottom‐up migration has unnamed modules on the module path"
      }, {
        "code": "E",
        "value": "A top‐down migration has unnamed modules on the module path."
      }, {
        "code": "F",
        "value": "Neither migration type has unnamed modules on the module path."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "F"
        ],
        "explanation": "76. A,F. A bottom‐up migration leaves unnamed modules on the classpath\nuntil they are migrated to the module path, making option A correct and\noption D incorrect. A top‐down migration immediately moves all modules\nto the module path as automatic modules making options B and E incorrect.\nTherefore, option F is the other correct answer."
      }
    },
    "77": {
      "nbr": 77,
      "value": "Fill in the blank with code to look up and call a service.\nString cheese = ServiceLoader.load(Mouse.class)\n.stream()\n.map(______________)\n.map(Mouse::favoriteFood)\n.findFirst() .orElse(\"\");",
      "responses": [{
        "code": "A",
        "value": "Mouse.get()"
      }, {
        "code": "B",
        "value": "Mouse::get"
      }, {
        "code": "C",
        "value": "Provider.get()"
      }, {
        "code": "D",
        "value": "Provider::get"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "77. D. The ServiceLoader class has a load() method that returns a\nCollection of Provider. Option D is correct because we need to convert\nthe Provider into a Mouse."
      }
    },
    "78": {
      "nbr": 78,
      "value": "Given the diagram, what statements need to be in module‐info.java for\nthe mammal module? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "exports mammal;"
      }, {
        "code": "B",
        "value": "exports mammal.eat;"
      }, {
        "code": "C",
        "value": "requires animal;"
      }, {
        "code": "D",
        "value": "requires animal.util;"
      }, {
        "code": "E",
        "value": "requires milk;"
      }, {
        "code": "F",
        "value": "requires milk.store;"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "E"
        ],
        "explanation": "78. B,C,E. The mammal module depends on two other modules. Since\nrequires references module names, options C and E are correct. The\nmodule also has one package, which is referenced in the exports directive.\nThis makes option B correct as well."
      }
    },
    "79": {
      "nbr": 79,
      "value": "Given the previous diagram and the following module‐info.java for the\npanda module, what change can be made to the requires statement?\nmodule panda {\nrequires mammal;\n}",
      "responses": [{
        "code": "A",
        "value": "exports transitive mammal;"
      }, {
        "code": "B",
        "value": "exports transitive mammal.eat;"
      }, {
        "code": "C",
        "value": "requires transitive animal;"
      }, {
        "code": "D",
        "value": "requires transitive animal.util;"
      }, {
        "code": "E",
        "value": "transitive requires animal;"
      }, {
        "code": "F",
        "value": "transitive requires animal.util;"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "79. C. The transitive keyword goes after requires, ruling out all but\noptions C and D. Just like requires, requires transitive references a\nmodule name, narrowing it down to option C."
      }
    },
    "80": {
      "nbr": 80,
      "value": "Given the diagram in question 78 and the following module‐info.java for\nthe panda module, what is the result of including line m1?\nmodule panda {\nrequires mammal;\nrequires transitive mammal; // line m1\n}",
      "responses": [{
        "code": "A",
        "value": "Any modules that require mammal will automatically get panda as well."
      }, {
        "code": "B",
        "value": "Any modules that require panda will automatically get mammal as well."
      }, {
        "code": "C",
        "value": "There is no change in behavior."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "80. D. Any requires directives must reference unique modules. Using the\ntransitive keyword does not change this requirement, making option D\nthe correct answer."
      }
    },
    "81": {
      "nbr": 81,
      "value": "How many service providers are allowed to implement a service provider\ninterface and have the consumer reference the first one?",
      "responses": [{
        "code": "A",
        "value": "Exactly one"
      }, {
        "code": "B",
        "value": "Exactly two"
      }, {
        "code": "C",
        "value": "One or two"
      }, {
        "code": "D",
        "value": "One or more"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "81. D. There can be multiple service providers for a single service provider\ninterface, making option D the correct answer."
      }
    },
    "82": {
      "nbr": 82,
      "value": "Which of the following are modules supplied by the JDK? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "java.logging"
      }, {
        "code": "B",
        "value": "java.javadoc"
      }, {
        "code": "C",
        "value": "java.jdk"
      }, {
        "code": "D",
        "value": "java.management"
      }, {
        "code": "E",
        "value": "java.naming"
      }, {
        "code": "F",
        "value": "java.scripts"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "E"
        ],
        "explanation": "82. A,D,E. The java.logging, java.management, and java.naming modules\nexist, making options A, D, and E correct. Option B is tempting. However,\njdk.javadoc exists, not java.javadoc. Options C and F are completely\nmade up."
      }
    },
    "83": {
      "nbr": 83,
      "value": "Which are true of a JAR file that has only one module‐info.class file,\nplaced in the META‐INF directory? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "It is an automatic module if on the classpath."
      }, {
        "code": "B",
        "value": "It is an automatic module if on the module path."
      }, {
        "code": "C",
        "value": "It is a named module if on the classpath."
      }, {
        "code": "D",
        "value": "It is a named module if on the module path."
      }, {
        "code": "E",
        "value": "It is an unnamed module if on the classpath."
      }, {
        "code": "F",
        "value": "It is an unnamed module if on the module path."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "83. B,E. Option E is correct because all modules on the classpath are unnamed\nmodules. On the module path, we can have automatic or named modules. In\nthis case, it is an automatic module because there is no module‐info.class\nat the root of the JAR. Having that file in another directory is ignored. This\nmakes option B the other answer."
      }
    },
    "84": {
      "nbr": 84,
      "value": "The service locator and service provider interface share a module. Which\nboxes represent the consumer and service provider, respectively?",
      "responses": [{
        "code": "A",
        "value": "X and Y"
      }, {
        "code": "B",
        "value": "X and Z"
      }, {
        "code": "C",
        "value": "Y and Z"
      }, {
        "code": "D",
        "value": "Z and Z"
      }, {
        "code": "E",
        "value": "Z and Y"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "84. A. The consumer needs to depend on the shared module, making it X. The\nshared module then has to be Z, and the service provider has to be Y. This\nmakes option A correct."
      }
    },
    "85": {
      "nbr": 85,
      "value": "What statements are most accurate about the ServiceLoader class?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "load() does not take any parameters."
      }, {
        "code": "B",
        "value": "load() takes the class type as a parameter."
      }, {
        "code": "C",
        "value": "When looping through the results of load(), you need to call the\nget() method on Provider."
      }, {
        "code": "D",
        "value": "When using the results of load() in a Stream, you need to call the\nget() method on Provider."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "85. B,D. The method call of ServiceLoader.load(Poodle.class), takes a\nparameter making option B correct and option A incorrect. When using a\nStream, you call Provider::get, making option D the other answer. Option\nC is incorrect because you don't need to call the get() method when using\na loop."
      }
    },
    "86": {
      "nbr": 86,
      "value": "Suppose we have an automatic module on the module path named lizard‐\n^‐cricket‐^‐1.0.0‐SNAPSHOT.jar and no Automatic‐Module‐Name\nspecified. What module name should named modules use to reference it?",
      "responses": [{
        "code": "A",
        "value": "lizard‐cricket"
      }, {
        "code": "B",
        "value": "lizard.cricket"
      }, {
        "code": "C",
        "value": "lizard‐cricket‐SNAPSHOT"
      }, {
        "code": "D",
        "value": "lizard‐cricket.SNAPSHOT"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "86. B. The rules for determining the name include removing the extension,\nremoving numbers and changing special characters to periods (.).\nAdditionally, we remove the version information from the end, which is\n1.0.0‐SNAPSHOT. Finally, we normalize the duplicate dots, which gives us\noption B: lizard.cricket."
      }
    },
    "87": {
      "nbr": 87,
      "value": "What file formats are legal for a module to be distributed?",
      "responses": [{
        "code": "A",
        "value": "jar"
      }, {
        "code": "B",
        "value": "jmod"
      }, {
        "code": "C",
        "value": "zip"
      }, {
        "code": "D",
        "value": "jar and jmod"
      }, {
        "code": "E",
        "value": "jar and zip"
      }, {
        "code": "F",
        "value": "jmod and zip"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "87. D. The jar file format is most common. The JMOD jmod format is used\nas well. Therefore, option D is correct."
      }
    },
    "88": {
      "nbr": 88,
      "value": "Why is this module‐info incorrect for a service provider?\nmodule plant.flower {\nexports plant.flower.impl;\nrequires plant.flower.api;\nprovides plant.flower.api.Petal\nwith plant.flower.impl.PetalImpl;\n}",
      "responses": [{
        "code": "A",
        "value": "The exports directive should be export."
      }, {
        "code": "B",
        "value": "The exports directive should not be present because all calls to the\nservice provider should use the service locator."
      }, {
        "code": "C",
        "value": "The provides directive should be uses instead."
      }, {
        "code": "D",
        "value": "The provides directive has the implementation and interface in the\nwrong order."
      }, {
        "code": "E",
        "value": "The requires directive should be exports instead."
      }, {
        "code": "F",
        "value": "The requires directive should not be present because provides\nimplies it."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "88. B. Option B is correct because a service provider should not contain an\nexports directive. The service locator is used to reference any\nimplementation exposed by provides."
      }
    },
    "89": {
      "nbr": 89,
      "value": "How many modules are part of the cyclic dependency?\nmodule.com.light {\nexports com.light;\n}\nmodule com.plant {\nexports com.plant;\nrequires com.light;\nrequires com.animal;\n}\nmodule com.animal {\nexports com.animal;\nrequires com.light;\n}\nmodule com.worm {\nexports com.worm;\nrequires com.light;\nrequires com.animal;\nrequires com.plant;\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "89. A. The com.light module is a dependency for all the other modules but\ndoes not depend on them. Similarly, the com.animal module is a\ndependency for the two higher‐level modules but does not depend on them.\nFinally, the com.plant module is a dependency for the com.worm module\nbut does not depend on it. While the modules are not defined in this order,\nthe question is about cyclic dependencies rather than order of compilation.\nThere is no cyclic dependency, making option A correct."
      }
    },
    "90": {
      "nbr": 90,
      "value": "What statements are true about requires mandated java.base? (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "This output is expected when running the java ‐‐list‐modules\ncommand."
      }, {
        "code": "B",
        "value": "This output is expected when running the java ‐‐show‐moduleresolution\ncommand."
      }, {
        "code": "C",
        "value": "This output is expected when running the jdeps command."
      }, {
        "code": "D",
        "value": "This output is expected when running the jmod command."
      }, {
        "code": "E",
        "value": "All modules will include this in the output."
      }, {
        "code": "F",
        "value": "Some modules will include this in the output."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "90. C,E. The jdeps command outputs requires mandated java.base except\nwhen run in summary mode, making option C correct. Since this module is\nan implicit dependency in all modules, option E is also correct."
      }
    }
  }
}, {
  "name": "Concurrency",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "What is the output of the following code snippet?\nCallable c = new Callable() {\npublic Object run() {\nSystem.out.print(\"X\");\nreturn 10;\n}\n};\nvar s = Executors.newScheduledThreadPool(1);\nfor(int i=0; i<10; i++) {\nFuture f = s.submit(c);\nf.get();\n}\ns.shutdown();\nSystem.out.print(\"Done!\");",
      "responses": [{
        "code": "A",
        "value": "XXXXXXXXXXDone!"
      }, {
        "code": "B",
        "value": "Done!XXXXXXXXXX"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code hangs indefinitely at runtime."
      }, {
        "code": "E",
        "value": "The code throws an exception at runtime."
      }, {
        "code": "F",
        "value": "The output cannot be determined ahead of time."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "1. C. The code does not compile because Callable must define a call()\nmethod, not a run() method, so option C is the correct answer. If the code\nwas fixed to use the correct method name, then it would complete without\nissue, printing XXXXXXXXXXDone! at runtime. The f.get() call will block\nand wait for the results before moving on to the next iteration of the for\nloop."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Which of the following methods is not available on an ExecutorService\ninstance? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "execute(Callable)"
      }, {
        "code": "B",
        "value": "shutdownNow()"
      }, {
        "code": "C",
        "value": "submit(Runnable)"
      }, {
        "code": "D",
        "value": "exit()"
      }, {
        "code": "E",
        "value": "submit(Callable)"
      }, {
        "code": "F",
        "value": "execute(Runnable)"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D"
        ],
        "explanation": "2. A,D. Option A is correct, as ExecutorService does not define nor inherit\nan overloaded method execute() that takes a Callable parameter.\nExecutorService defines two shutdown methods, shutdown() and\nshutdownNow(), one of which is shown in option B. Option D is correct, as\nexit() does not exist and is not one of shutdown methods. The\nExecutorService interface defines the two submit() methods shown in\noptions C and E. Because ExecutorService extends Executor, it also\ninherits the execute(Runnable) method presented in option F."
      }
    },
    "3": {
      "nbr": 3,
      "value": "The following program simulates flipping a coin an even number of times.\nAssuming five seconds is enough time for all of the tasks to finish, what is\nthe output of the following application?\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\npublic class Luck {\nprivate AtomicBoolean coin = new AtomicBoolean(false);\nvoid flip() {\ncoin.getAndSet(!coin.get());\n}\npublic static void main(String[] gamble) throws\nException {\nvar luck = new Luck();\nExecutorService s = Executors.newCachedThreadPool();\nfor(int i=0; i<1000; i++) {\ns.execute(() -> luck.flip());\n}\ns.shutdown();\nThread.sleep(5000);\nSystem.out.println(luck.coin.get());\n} }",
      "responses": [{
        "code": "A",
        "value": "false"
      }, {
        "code": "B",
        "value": "true"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code hangs indefinitely at runtime."
      }, {
        "code": "E",
        "value": "The code throws an exception at runtime."
      }, {
        "code": "F",
        "value": "The output cannot be determined ahead of time."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "3. F. The code compiles and runs without issue. Even though the thread‐safe\nAtomicBoolean is used, it is not used in a thread‐safe manner. The flip()\nmethod first retrieves the value and then sets a new value. These two calls\nare not executed together in an atomic or synchronized manner. For this\nreason, the output could be true or false, with one or more of the flips\npossibly being lost, and making option F correct."
      }
    },
    "4": {
      "nbr": 4,
      "value": "Which of the following is a recommended way to define an asynchronous\ntask?",
      "responses": [{
        "code": "A",
        "value": "Create a Callable expression and pass it to an instance of an\nExecutor."
      }, {
        "code": "B",
        "value": "Create a class that extends Thread and override the start() method."
      }, {
        "code": "C",
        "value": "Create a Runnable lambda expression and pass it to a Thread\nconstructor."
      }, {
        "code": "D",
        "value": "Create an anonymous Runnable class that overrides the begin()\nmethod."
      }, {
        "code": "E",
        "value": "All of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "4. C. Option A is incorrect, although it would be correct if Executor were\nreplaced with ExecutorService. Option B is also incorrect, but it would be\ncorrect if start() were replaced with run(). Option C is correct and is a\ncommon way to define an asynchronous task using a lambda expression.\nOption D is incorrect, as Runnable does not inherit a begin() method."
      }
    },
    "5": {
      "nbr": 5,
      "value": "Given the following program, how many times is Locked! expected to be\nprinted? Assume 100 milliseconds is enough time for each task created by\nthe program to complete.\nimport java.util.concurrent.locks.*;\npublic class Padlock {\nprivate Lock lock = new ReentrantLock();\npublic void lockUp() {\nif (lock.tryLock()) {\nlock.lock();\nSystem.out.println(\"Locked!\");\nlock.unlock();\n}\n}\npublic static void main(String… unused) throws Exception\n{\nvar gate = new Padlock();\nfor(int i=0; i<5; i++) {\nnew Thread(() -> gate.lockUp()).start();\nThread.sleep(100);\n}\n} }",
      "responses": [{
        "code": "A",
        "value": "One time."
      }, {
        "code": "B",
        "value": "Five times."
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code hangs indefinitely at runtime."
      }, {
        "code": "E",
        "value": "The code throws an exception at runtime."
      }, {
        "code": "F",
        "value": "The output cannot be determined ahead of time."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "5. A. If the tryLock() method returns true, then a lock is acquired that must\nbe released. That means the lockUp() method actually contains two calls to\nlock the object and only one call to unlock it. For this reason, the first\nthread to reach tryLock() obtains a lock that is never released. For this\nreason, Locked! is printed only once, and option A is correct. If the call to\nlock() inside the if statement was removed, then the expected output\nwould be to print the statement five times."
      }
    },
    "6": {
      "nbr": 6,
      "value": "Given the original array, how many of the following for statements result\nin an exception at runtime, assuming each is executed independently?\nvar original = List.of(1,2,3,4,5);\nvar copy1 = new CopyOnWriteArrayList<Integer>(original);\nfor(Integer w : copy1)\ncopy1.remove(w);\nvar copy2 = Collections.synchronizedList(original);\nfor(Integer w : copy2)\ncopy2.remove(w);\nvar copy3 = new ArrayList<Integer>(original);\nfor(Integer w : copy3)\ncopy3.remove(w);\nvar copy4 = new ConcurrentLinkedQueue<Integer>(original);\nfor(Integer w : copy4)\ncopy4.remove(w);",
      "responses": [{
        "code": "A",
        "value": "Zero."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "6. C. CopyOnWriteArrayList makes a copy of the array every time it is\nmodified, preserving the original list of values the iterator is using, even as\nthe array is modified. For this reason, the for loop using copy1 does not\nthrow an exception at runtime. On the other hand, the for loops using\ncopy2 and copy3 both throw ConcurrentModificationException at\nruntime since neither allows modification while they are being iterated\nupon. Finally, the ConcurrentLinkedQueue used in copy4 completes\nwithout throwing an exception at runtime. For the exam, remember that the\nConcurrent classes order read/write access such that access to the class is\nconsistent across all threads and processes, while the synchronized classes\ndo not. Because exactly two of the for statements produce exceptions at\nruntime, option C is the correct answer."
      }
    },
    "7": {
      "nbr": 7,
      "value": "Fill in the blanks: ______________ is a special case of ______________, in\nwhich two or more active threads try to acquire the same set of locks and\nare repeatedly unsuccessful.",
      "responses": [{
        "code": "A",
        "value": "Deadlock, livelock"
      }, {
        "code": "B",
        "value": "Deadlock, resource starvation"
      }, {
        "code": "C",
        "value": "Livelock, resource starvation"
      }, {
        "code": "D",
        "value": "Resource starvation, race conditions"
      }, {
        "code": "E",
        "value": "Resource starvation, livelock"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "7. C. Resource starvation is when a single active thread is perpetually unable\nto gain access to a shared resource. Livelock is a special case of resource\nstarvation, in which two or more active threads are unable to gain access to\nshared resources, repeating the process over and over again. For these\nreasons, option C is the correct answer. Deadlock and livelock are similar,\nalthough in a deadlock situation the threads are stuck waiting, rather than\nbeing active or performing any work. Finally, a race condition is an\nundesirable result when two tasks that should be completed sequentially are\ncompleted at the same time."
      }
    },
    "8": {
      "nbr": 8,
      "value": "What is the output of the following application?\n3: public class TpsReport {\n4: public void submitReports() {\n5: var s = Executors.newCachedThreadPool();\n6: Future bosses = s.submit(() ->\nSystem.out.print(\"1\"));\n7: s.shutdown();\n8: System.out.print(bosses.get());\n9: }\n10: public static void main(String[] memo) {\n11: new TpsReport().submitReports();\n12: }\n13: }",
      "responses": [{
        "code": "A",
        "value": "null"
      }, {
        "code": "B",
        "value": "1null"
      }, {
        "code": "C",
        "value": "1"
      }, {
        "code": "D",
        "value": "Line 6 does not compile."
      }, {
        "code": "E",
        "value": "Line 8 does not compile."
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "8. E. The class does not compile because the Future.get() on line 8 throws\na checked InterruptedException and a checked ExecutionException,\nneither of which is handled nor declared by the submitReports() method.\nIf the submitReports() and accompanying main() methods were both\nupdated to declare these exceptions, then the application would print 1null\nat runtime. For the exam, remember that Future can be used with Runnable\nlambda expressions that do not have a return value but that the return value\nis always null when completed."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Which of the following static methods does not exist in the Executors\nclass? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "newFixedScheduledThreadPool()"
      }, {
        "code": "B",
        "value": "newThreadPool()"
      }, {
        "code": "C",
        "value": "newFixedThreadPool(int)"
      }, {
        "code": "D",
        "value": "newSingleThreadExecutor()"
      }, {
        "code": "E",
        "value": "newScheduledThreadPool(int)"
      }, {
        "code": "F",
        "value": "newSingleThreadScheduledExecutor()"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B"
        ],
        "explanation": "9. A,B. Options C, D, E, and F are all proper ways to obtain instances of\nExecutorService. Remember that newSingleThreadExecutor() is\nequivalent to calling newFixedThreadPool(int) with a value of 1. The\ncorrect answers are options A and B, as neither of these methods exist."
      }
    },
    "10": {
      "nbr": 10,
      "value": "How many times does the following application print Ready at runtime?\npackage parade;\nimport java.util.concurrent.*;\npublic class CartoonCat {\nprivate void await(CyclicBarrier c) {\ntry {\nc.await();\n} catch (Exception e) {}\n}\npublic void march(CyclicBarrier c) {\nvar s = Executors.newSingleThreadExecutor();\nfor(int i=0; i<12; i++)\ns.execute(() -> await(c));\ns.shutdown();\n}\npublic static void main(String… strings) {\nnew CartoonCat().march(new CyclicBarrier(4,\n() -> System.out.println(\"Ready\")));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Zero."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Three."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "10. A. The code compiles without issue but hangs indefinitely at runtime. The\napplication defines a thread executor with a single thread and 12 submitted\ntasks. Because only one thread is available to work at a time, the first thread\nwill wait endlessly on the call to await(). Since the CyclicBarrier\nrequires four threads to release it, the application waits endlessly in a frozen\ncondition. Since the barrier is never reached and the code hangs, the\napplication will never output Ready, making option A the correct answer. If\nnewCachedThreadPool() had been used instead of\nnewSingleThreadExecutor(), then the barrier would be reached three\ntimes, and option C would be the correct answer."
      }
    },
    "11": {
      "nbr": 11,
      "value": "Let's say you needed a thread executor to create tasks for a CyclicBarrier\nthat has a barrier limit of five threads. Which static method in\nExecutorService should you use to obtain it?",
      "responses": [{
        "code": "A",
        "value": "newSingleThreadExecutor()"
      }, {
        "code": "B",
        "value": "newSingleThreadScheduledExecutor()"
      }, {
        "code": "C",
        "value": "newCachedThreadPool()"
      }, {
        "code": "D",
        "value": "newFixedThreadPool(2)"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "11. E. Trick question! ExecutorService does not contain any of these\nmethods. To obtain an instance of a thread executor, you need to use the\nExecutors factory class. For this reason, option E is the correct answer. If\nthe question had instead asked which Executors method to use, then the\ncorrect answer would be option C. Options A, B, and D do not create\nenough threads for a CyclicBarrier expecting to reach a limit of five\nconcurrent threads. Option C, on the other hand, will create threads as\nneeded and is appropriate for use with a CyclicBarrier."
      }
    },
    "12": {
      "nbr": 12,
      "value": "The following diagrams represent the order of read/write operations of two\nthreads sharing a common variable. Each thread first reads the value of the\nvariable from memory and then writes a new value of the variable back to\nmemory. Which diagram demonstrates proper synchronization?",
      "responses": [{
        "code": "A",
        "value": ""
      }, {
        "code": "B",
        "value": ""
      }, {
        "code": "C",
        "value": ""
      }, {
        "code": "D",
        "value": ""
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "12. C. Part of synchronizing access to a variable is ensuring that read/write\noperations are atomic or happen without interruption. For example, an\nincrement operation requires reading a value and then immediately writing\nit. If any thread interrupts this process, then data could be lost. In this\nregard, option C shows proper synchronized access. Thread 2 reads a value\nand then writes it without interruption. Thread 1 then reads the new value\nand writes it. The rest of the answers are incorrect because one thread\nwrites data to the variable in‐between another thread reading and writing to\nthe same variable. Because a thread is writing data to a variable that has\nalready been written to by another thread, it may set invalid data. For\nexample, two increment operations running at the same time could result in\none of the increment operations being lost."
      }
    },
    "13": {
      "nbr": 13,
      "value": "What is the output of the following application?\nimport java.util.*;\nimport java.util.concurrent.*;\npublic class Race {\nExecutorService service =\nExecutors.newFixedThreadPool(8);\npublic static int sleep() {\ntry { Thread.sleep(1000); } catch (Exception e) {}\nreturn 1;\n}\npublic void hare() {\ntry {\nCallable<Integer> c = () -> sleep();\nfinal var r = List.of(c,c,c);\nvar results = service.invokeAll(r);\nSystem.out.println(\"Hare won the race!\");\n} catch (Exception e) {e.printStackTrace();}\n}\npublic void tortoise() {\ntry {\nCallable<Integer> c = () -> sleep();\nfinal var r = List.of(c,c,c);\nInteger result = service.invokeAny(r);\nSystem.out.println(\"Tortoise won the race!\");\n} catch (Exception e) {e.printStackTrace();}\n}\npublic static void main(String[] p) throws Exception {\nvar race = new Race();\nrace.service.execute(() -> race.hare());\nrace.service.execute(() -> race.tortoise());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Hare won the race! is printed first."
      }, {
        "code": "B",
        "value": "Tortoise won the race! is printed first."
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code hangs indefinitely at runtime."
      }, {
        "code": "E",
        "value": "The code throws an exception at runtime."
      }, {
        "code": "F",
        "value": "The output cannot be determined ahead of time."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "13. F. The code compiles and runs without issue. The two methods hare()\nand tortoise() are nearly identical, with one calling invokeAll() and the\nother calling invokeAny(). Calling the invokeAll() method causes the\ncurrent thread to wait until all tasks are finished, while calling the\ninvokeAny() method will cause the current thread to wait until at least one\ntask is complete. Both ExecutorService methods operate synchronously,\nwaiting for a result from one or more tasks, but each method call has been\nsubmitted to the thread executor as an asynchronous task. For this reason,\nboth methods will take about one second to complete, and since either can\nfinish first, the output will vary at runtime, making option F correct. Note\nthat this program does not terminate, since the ExecutorService is not shut\ndown."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Which of the following concurrent collections is sorted? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "ConcurrentSkipList"
      }, {
        "code": "B",
        "value": "ConcurrentSkipListSet"
      }, {
        "code": "C",
        "value": "CopyOnWriteArrayList"
      }, {
        "code": "D",
        "value": "ConcurrentSkipListMap"
      }, {
        "code": "E",
        "value": "ConcurrentLinkedQueue"
      }, {
        "code": "F",
        "value": "LinkedBlockingQueue"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "14. B,D. ConcurrentSkipList does not exist as a concurrent collection,\nmaking option A incorrect. ConcurrentSkipListSet implements the\nSortedSet interface, in which the elements are kept sorted, making option\nB correct. ConcurrentSkipListMap implements the SortedMap interface, in\nwhich the keys are kept sorted, making option D correct. The other options\ndefine structures that are ordered, but not sorted. Remember, if you see\nSkipList as part of a concurrent class name, it means it is sorted in some\nway."
      }
    },
    "15": {
      "nbr": 15,
      "value": "What is the output of the following application?\npackage taxes;\nimport java.util.concurrent.*;\npublic class Accountant {\npublic static void completePaperwork() {\nSystem.out.print(\"[Filing]\");\n}\npublic static double getPi() {\nreturn 3.14159;\n}\npublic static void main(String[] args) throws Exception\n{\nExecutorService x =\nExecutors.newSingleThreadExecutor();\nFuture<?> f1 = x.submit(() -> completePaperwork());\nFuture<Object> f2 = x.submit(() -> getPi());\nSystem.out.print(f1.get()+\" \"+f2.get());\nx.shutdown();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "[Filing]"
      }, {
        "code": "B",
        "value": "[Filing]3.14159"
      }, {
        "code": "C",
        "value": "[Filing]null 3.14159"
      }, {
        "code": "D",
        "value": "The declaration of f1 does not compile."
      }, {
        "code": "E",
        "value": "The declaration of f2 does not compile."
      }, {
        "code": "F",
        "value": "The output cannot be determined ahead of time."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "15. C. The code compiles without issue, so options D and E are incorrect. The\nf1 declaration uses the version of submit() in ExecutorService, which\ntakes a Runnable and returns a Future<?>, while the f2 declaration uses an\noverloaded version of submit(), which takes a Callable expression and\nreturns a generic Future object. The call f1.get() waits until the task is\nfinished and always returns null, since Runnable expressions have a void\nreturn type, so [Filing]null is printed first. The call to f2.get() returns\nthen prints 3.14159. For these reasons, option C is the correct answer."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Assuming 10 seconds is enough time for all of the tasks to finish, what\nstatements about the following program are correct? (Choose two.)\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\npublic class Clock {\nprivate AtomicLong bigHand = new AtomicLong(0);\nvoid incrementBy10() {\nbigHand.getAndSet(bigHand.get() + 10);\n}\npublic static void main(String[] c) throws Exception {\nvar smartWatch = new Clock();\nExecutorService s = Executors.newCachedThreadPool();\nfor(int i=0; i<100; i++) {\ns.submit(() -> smartWatch.incrementBy10()).get();\n}\ns.shutdown();\ns.awaitTermination(10, TimeUnit.SECONDS);\nSystem.out.println(smartWatch.bigHand.get());\n} }",
      "responses": [{
        "code": "A",
        "value": "The code does not compile."
      }, {
        "code": "B",
        "value": "The incrementBy10() method is thread‐safe."
      }, {
        "code": "C",
        "value": "The incrementBy10() method is not thread‐safe."
      }, {
        "code": "D",
        "value": "The output is 1000 on every execution."
      }, {
        "code": "E",
        "value": "The output cannot be determined ahead of time."
      }, {
        "code": "F",
        "value": "The code hangs indefinitely at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "16. C,D. The code compiles and runs without issue. While an AtomicLong is\nused, there are two calls on this variable, the first to retrieve the value and\nthe second to set the new value. These two calls are not executed together\nin an atomic or synchronized manner. For this reason, the incrementBy10()\nmethod is not thread‐safe, and option C is correct. That said, the code\nperforms in single‐threaded manner at runtime because the call to get() in\nthe main() method waits for each thread to finish. For this reason, the\noutput is consistently 1000, making option D correct."
      }
    },
    "17": {
      "nbr": 17,
      "value": "What is the most likely result of executing the following application?\npackage jokes;\nimport java.util.concurrent.*;\npublic class Riddle {\npublic void sleep() {\ntry { Thread.sleep(5000); } catch (Exception e) {}\n}\npublic String getQuestion(Riddle r) {\nsynchronized {\nsleep();\nif(r != null) r.getAnswer(null);\nreturn \"How many programmers does it take \"\n+ \"to change a light bulb?\";\n}\n}\npublic synchronized String getAnswer(Riddle r) {\nsleep();\nif(r != null) r.getAnswer(null);\nreturn \"None, that's a hardware problem\";\n}\npublic static void main(String… ununused) {\nvar r1 = new Riddle();\nvar r2 = new Riddle();\nvar s = Executors.newFixedThreadPool(2);\ns.submit(() -> r1.getQuestion(r2));\ns.execute(() -> r2.getAnswer(r1));\ns.shutdown();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "A deadlock is produced at runtime."
      }, {
        "code": "B",
        "value": "A livelock is produced at runtime."
      }, {
        "code": "C",
        "value": "The application completes successfully."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code hangs indefinitely at runtime."
      }, {
        "code": "F",
        "value": "The output cannot be determined ahead of time."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "17. D. The synchronized block used in the getQuestion() method requires\nan object to synchronize on. Without it, the code does not compile, and\noption D is the correct answer. What if the command was fixed to\nsynchronize on the current object, such as using synchronized(this)?\nEach task would obtain a lock for its respective object and then wait a\ncouple of seconds before requesting the lock for the other object. Since the\nlocks are already held, both wait indefinitely, likely resulting in a deadlock.\nWe say most likely because even with corrected code, a deadlock is not\nguaranteed. It is possible, albeit very unlikely, for the JVM to wait five\nseconds before starting the second task, allowing enough time for the first\ntask to finish and avoiding the deadlock completely."
      }
    },
    "18": {
      "nbr": 18,
      "value": "Which ScheduledExecutorService method can result in the same action\nbeing executed by two threads at the same time?",
      "responses": [{
        "code": "A",
        "value": "scheduleAtFixedDelay()"
      }, {
        "code": "B",
        "value": "scheduleAtFixedRate()"
      }, {
        "code": "C",
        "value": "scheduleWithFixedDelay()"
      }, {
        "code": "D",
        "value": "scheduleAtSameRate()"
      }, {
        "code": "E",
        "value": "scheduleWithRate()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "18. B. Options A, D, and E include method names that do not exist in\nScheduledExecutorService. The scheduleAtFixedRate() method creates\na new task for the associated action at a set time interval, even if previous\ntasks for the same action are still active. In this manner, it is possible\nmultiple threads working on the same action could be executing at the same\ntime, making option B the correct answer. On the other hand,\nscheduleWithFixedDelay() waits until each task is completed before\nscheduling the next task, guaranteeing at most one thread working on the\naction is active in the thread pool."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What is the output of the following application?\npackage olympics;\nimport java.util.concurrent.*;\npublic class Athlete {\nint stroke = 0;\npublic synchronized void swimming() {\nstroke++;\n}\nprivate int getStroke() {\nsynchronized(this) { return stroke; }\n}\npublic static void main(String… laps) {\nExecutorService s = Executors.newFixedThreadPool(10);\nAthlete a = new Athlete();\nfor(int i=0; i<1000; i++) {\ns.execute(() -> a.swimming());\n}\ns.shutdown();\nSystem.out.print(a.getStroke());\n} }",
      "responses": [{
        "code": "A",
        "value": "A deadlock is produced at runtime."
      }, {
        "code": "B",
        "value": "A livelock is produced at runtime."
      }, {
        "code": "C",
        "value": "1000"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The result is unknown until runtime because stroke is not written in a\nthread‐safe manner and a write may be lost."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "19. F. The application compiles, so option D is incorrect. The stroke variable\nis thread‐safe in the sense that no write is lost, since all writes are wrapped\nin a synchronized method, making option E incorrect. The issue here is\nthat the main() method reads the value of getStroke() while tasks may\nstill be executing within the ExecutorService. The shutdown() method\nstops new tasks from being submitted but does not wait for previously\nsubmitted tasks to complete. Therefore, the result may output 0, 1000, or\nanything in between, making option F the correct answer. If the\nExecutorService method awaitTermination() is called before the value\nof stroke is printed and enough time elapses, then the result would be 1000\nevery time."
      }
    },
    "20": {
      "nbr": 20,
      "value": "Which of the following is most likely to be caused by a race condition?",
      "responses": [{
        "code": "A",
        "value": "A thread perpetually denied access to a resource"
      }, {
        "code": "B",
        "value": "A program hanging indefinitely"
      }, {
        "code": "C",
        "value": "An int variable incorrectly reporting the number of times an operation\nwas performed"
      }, {
        "code": "D",
        "value": "Two threads actively trying to restart a blocked process that is\nguaranteed to always end the same way"
      }, {
        "code": "E",
        "value": "Two threads endlessly waiting on each other to release shared locks"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "20. C. A race condition is an undesirable result when two tasks that should be\ncompleted sequentially are completed at the same time. The result is often\ncorruption of data in some way. If two threads are both modifying the same\nint variable and there is no synchronization, then a race condition can\noccur with one of the writes being lost. For this reason, option C is the\ncorrect answer. Option A is the description of resource starvation. Options\nD and E are describing livelock and deadlock, respectively, while option B\nis the potential result of either of those events occurring."
      }
    },
    "21": {
      "nbr": 21,
      "value": "Which statement about the following class is correct?\npackage my;\nimport java.util.*;\npublic class ThreadSafeList {\nprivate List<Integer> data = new ArrayList<>();\npublic synchronized void addValue(int value) {\ndata.add(value);\n}\npublic int getValue(int index) {\nreturn data.get(index);\n}\npublic int size() {\nsynchronized(ThreadSafeList.class) {\nreturn data.size();\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code compiles and is thread‐safe."
      }, {
        "code": "B",
        "value": "The code compiles and is not thread‐safe."
      }, {
        "code": "C",
        "value": "The code does not compile because of the size() method."
      }, {
        "code": "D",
        "value": "The code does not compile because of the getValue() method."
      }, {
        "code": "E",
        "value": "The code does not compile for another reason."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "21. B. The class compiles without issue. The class attempts to create a\nsynchronized version of a List<Integer>. The size() and addValue()\nhelp synchronize the read/write operations. Unfortunately, the getValue()\nmethod is not synchronized so the class is not thread‐safe, and option B is\nthe correct answer. It is possible that one thread could add to the data\nobject while another thread is reading from the object, leading to an\nunexpected result."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Which two method names, when filled into the print2() method, produce\nthe same output as the print1() method? Assume the input arguments for\neach represent the same non‐null numeric value.\npublic static synchronized void print1(int counter) {\nSystem.out.println(counter--);\nSystem.out.println(++counter);\n}\npublic static synchronized void print2(AtomicInteger\ncounter) {\nSystem.out.println(counter._________________);\nSystem.out.println(counter._________________);\n}",
      "responses": [{
        "code": "A",
        "value": "decrementAndGet() and getAndIncrement()"
      }, {
        "code": "B",
        "value": "decrementAndGet() and incrementAndGet()"
      }, {
        "code": "C",
        "value": "getAndDecrement() and getAndIncrement()"
      }, {
        "code": "D",
        "value": "getAndDecrement() and incrementAndGet()"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "22. D. The post‐decrement operator (––) decrements a value but returns the\noriginal value. It is equivalent to the atomic getAndDecrement() method.\nThe pre‐increment operator (++) increments a value and then returns the\nnew value. It is equivalent to the incrementAndGet() atomic operation. For\nthese reasons, option D is the correct answer."
      }
    },
    "23": {
      "nbr": 23,
      "value": "How many lines of the following code snippet contain compilation errors?\n11: ScheduledExecutorService t = Executors\n12: .newSingleThreadScheduledExecutor();\n13: Future result = t.execute(System.out::println);\n14: t.invokeAll(null);\n15: t.scheduleAtFixedRate(() ->\n{return;},5,TimeUnit.MINUTES);",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "23. C. Line 13 does not compile because the execute() method has a return\ntype of void, not Future. Line 15 does not compile because\nscheduleAtFixedRate() requires four arguments that include an initial\ndelay and period value. For these two reasons, option C is the correct\nanswer."
      }
    },
    "24": {
      "nbr": 24,
      "value": "How many times does the following application print W at runtime?\npackage crew;\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class Boat {\nprivate void waitTillFinished(CyclicBarrier c) {\ntry {\nc.await();\nSystem.out.print(\"W\");\n} catch (Exception e) {}\n}\npublic void row(ExecutorService s) {\nvar cb = new CyclicBarrier(5);\nIntStream.iterate(1, i-> i+1)\n.limit(12)\n.forEach(i -> s.submit(() ->\nwaitTillFinished(cb)));\n}\npublic static void main(String[] oars) {\nExecutorService service = null;\ntry {\nservice = Executors.newCachedThreadPool();\nnew Boat().row(service);\n} finally {\nservice.isShutdown();\n} } }",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "10"
      }, {
        "code": "C",
        "value": "12"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The output cannot be determined ahead of time."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "24. B. When a CyclicBarrier goes over its limit, the barrier count is reset to\nzero. The application defines a CyclicBarrier with a barrier limit of 5\nthreads. The application then submits 12 tasks to a cached executor service.\nIn this scenario, a cached thread executor will use between 5 and 12\nthreads, reusing existing threads as they become available. In this manner,\nthere is no worry about running out of available threads. The barrier will\nthen trigger twice, printing five values for each of the sets of threads, for a\ntotal of ten W characters. For this reason, option B is the correct answer."
      }
    },
    "25": {
      "nbr": 25,
      "value": "Using the Boat class from the previous question, what is the final state of\nthe application?",
      "responses": [{
        "code": "A",
        "value": "The application produces an exception at runtime."
      }, {
        "code": "B",
        "value": "The application terminates successfully."
      }, {
        "code": "C",
        "value": "The application hangs indefinitely because the ExecutorService is\nnever shut down."
      }, {
        "code": "D",
        "value": "The application produces a deadlock at runtime."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "25. D. The application does not terminate successfully nor produce an\nexception at runtime, making options A and B incorrect. It hangs at runtime\nbecause the CyclicBarrier limit is 5, while the number of tasks submitted\nand awaiting activation is 12. This means that two of the tasks will be left\nover, stuck in a deadlocked state, waiting for the barrier limit to be reached\nbut with no more tasks available to trigger it. For this reason, option D is\nthe correct answer. If the number of tasks was a multiple of the barrier\nlimit, such as 15 instead of 12, then the application will still hang because\nthe ExecutorService is never shut down, and option C would be correct.\nThe isShutdown() call in the application finally block does not trigger a\nshutdown. Instead, shutdown() should have been used."
      }
    },
    "26": {
      "nbr": 26,
      "value": "Given the following program, how many times is TV Time expected to be\nprinted? Assume 10 seconds is enough time for each task created by the\nprogram to complete.\nimport java.util.concurrent.*;\nimport java.util.concurrent.locks.*;\npublic class Television {\nprivate static Lock myTurn = new ReentrantLock();\npublic void watch() {\ntry {\nif (myTurn.lock(5, TimeUnit.SECONDS)) {\nSystem.out.println(\"TV Time\");\nmyTurn.unlock();\n}\n} catch (InterruptedException e) {}\n}\npublic static void main(String[] t) throws Exception {\nvar newTv = new Television();\nfor (int i = 0; i < 3; i++) {\nnew Thread(() -> newTv.watch()).start();\nThread.sleep(10*1000);\n}\n} }",
      "responses": [{
        "code": "A",
        "value": "One time."
      }, {
        "code": "B",
        "value": "Three times."
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code hangs indefinitely at runtime."
      }, {
        "code": "E",
        "value": "The code throws an exception at runtime."
      }, {
        "code": "F",
        "value": "The output cannot be determined ahead of time."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "26. C. The Lock interface does not include an overloaded version of lock()\nthat takes a timeout value and returns a boolean. For this reason, the code\ndoes not compile, and option C is correct. If tryLock(long,TimeUnit) had\nbeen used instead of lock(), then the program would have been expected to\nprint TV Time three times at runtime."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Given the original array, how many of the following for statements enter\nan infinite loop at runtime, assuming each is executed independently?\nvar original = new ArrayList<Integer>(List.of(1,2,3));\nvar copy1 = new ArrayList<Integer>(original);\nfor(Integer q : copy1)\ncopy1.add(1);\nvar copy2 = new CopyOnWriteArrayList<Integer>(original);\nfor(Integer q : copy2)\ncopy2.add(2);\nvar copy3 = new LinkedBlockingQueue<Integer>(original);\nfor(Integer q : copy3)\ncopy3.offer(3);\nvar copy4 = Collections.synchronizedList(original);\nfor(Integer q : copy4)\ncopy4.add(4);",
      "responses": [{
        "code": "A",
        "value": "Zero."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "27. B. The for loops using copy1 and copy4 both throw a\nConcurrentModificationException at runtime, since neither allows\nmodification while they are being iterated upon. Next,\nCopyOnWriteArrayList makes a copy of the collection every time it is\nmodified, preserving the original list of values the iterator is using. For this\nreason, the for loop using copy2 completes without throwing an exception\nor creating an infinite loop. On the other hand, the loop with copy3 enters\nan infinite loop at runtime. Each time a new value is inserted, the iterator is\nupdated, and the process repeats. Since this is the only statement that\nproduces an infinite loop, option B is correct."
      }
    },
    "28": {
      "nbr": 28,
      "value": "Which ExecutorService method guarantees all running tasks are stopped\nin an orderly fashion?",
      "responses": [{
        "code": "A",
        "value": "shutdown()"
      }, {
        "code": "B",
        "value": "shutdownNow()"
      }, {
        "code": "C",
        "value": "halt()"
      }, {
        "code": "D",
        "value": "shutdownAndTerminate()"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "28. E. The shutdown() method prevents new tasks from being added but\nallows existing tasks to finish. In addition to preventing new tasks from\nbeing added, the shutdownNow() method also attempts to stop all running\ntasks. Neither of these methods guarantees any task will be stopped, making\noption E the correct answer. Options C and D are incorrect because they\nname methods that do not exist in ExecutorService."
      }
    },
    "29": {
      "nbr": 29,
      "value": "Assuming 10 seconds is enough time for all of the tasks to finish, what is\nthe output of the following application?\nimport java.util.concurrent.*;\npublic class Bank {\nstatic int cookies = 0;\npublic synchronized void deposit(int amount) {\ncookies += amount;\n}\npublic static synchronized void withdrawal(int amount) {\ncookies -= amount;\n}\npublic static void main(String[] amount) throws\nException {\nvar teller = Executors.newScheduledThreadPool(50);\nBank bank = new Bank();\nfor(int i=0; i<25; i++) {\nteller.submit(() -> bank.deposit(5));\nteller.submit(() -> bank.withdrawal(5));\n}\nteller.shutdown();\nteller.awaitTermination(10, TimeUnit.SECONDS);\nSystem.out.print(bank.cookies);\n} }",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "125"
      }, {
        "code": "C",
        "value": "‐125"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The result is unknown until runtime."
      }, {
        "code": "F",
        "value": "An exception is thrown."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "29. E. The program compiles and does not throw an exception at runtime. The\nclass attempts to add and remove values from a single cookie variable in a\nthread‐safe manner but fails to do so because the methods deposit() and\nwithdrawal() synchronize on different objects. The instance method\ndeposit() synchronizes on the bank object, while the static method\nwithdrawal() synchronizes on the static Bank.class object. Since the\ncompound assignment operators (+=) and (‐=) are not thread‐safe, it is\npossible for one call to modify the value of cookies while the other is\nalready operating on it, resulting in a loss of information. For this reason,\nthe output cannot be predicted, and option E is the correct answer. If the\ntwo methods were synchronized on the same object, then the cookies\nvariable would be protected from concurrent modifications, printing 0 at\nruntime."
      }
    },
    "30": {
      "nbr": 30,
      "value": "What is the output of the following application?\nimport java.util.*;\npublic class SearchList<T> {\nprivate List<T> data;\nprivate boolean foundMatch = false;\npublic SearchList(List<T> list) {\nthis.data = list;\n}\npublic void exists(T v,int start, int end) {\nif(end-start==0) {}\nelse if(end-start==1) {\nfoundMatch = foundMatch ||\nv.equals(data.get(start));\n} else {\nfinal int middle = start + (end-start)/2;\nnew Thread(() -> exists(v,start,middle)).run();\nnew Thread(() -> exists(v,middle,end)).run();\n}\n}\npublic static void main(String[] a) throws Exception {\nList<Integer> data = List.of(1,2,3,4,5,6);\nSearchList<Integer> t = new SearchList<Integer>\n(data);\nt.exists(5, 0, data.size());\nSystem.out.print(t.foundMatch);\n} }",
      "responses": [{
        "code": "A",
        "value": "true"
      }, {
        "code": "B",
        "value": "false"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The result is unknown until runtime."
      }, {
        "code": "E",
        "value": "An exception is thrown."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "30. A. The code attempts to search for a matching element in an array using\nmultiple threads. While it does not contain any compilation problems, it\ndoes contain an error. Despite creating Thread instances, it is not a\nmultithreaded program. Calling run() on a Thread runs the process as part\nof the current thread. To be a multithreaded execution, it would need to\ninstead call the start() method. For this reason, the code completes\nsynchronously, waiting for each method call to return before moving on to\nthe next and printing true at the end of the execution, making option A the\ncorrect answer. On the other hand, if start() had been used, then the\napplication would be multithreaded but not thread‐safe. The calls to update\nfoundMatch are not synchronized, and even if they were, the result might\nnot be available by the time print() in the main() method was called. For\nthis reason, the result would not be known until runtime."
      }
    }
  }
}, {
  "name": "Java I/O API",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "The following code snippet results in an exception at runtime. Which of the\nfollowing is the most likely type of exception to be thrown?\nvar oldHardDrivePath = Path.get(\"c://rodent/mouse.txt\");\nvar newHardDrivePath = Path.get(\"d://rodent/rat.txt\");\nFiles.move(oldHardDrivePath,newHardDrivePath,\nStandardCopyOption.REPLACE_EXISTING);",
      "responses": [{
        "code": "A",
        "value": "AtomicMoveNotSupportedException"
      }, {
        "code": "B",
        "value": "DirectoryNotEmptyException"
      }, {
        "code": "C",
        "value": "FileAlreadyExistsException"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "1. D. The code does not compile because Path.get() is not a valid NIO.2\nmethod, making option D correct. Either Paths.get() or Path.of() should\nbe used instead. If the correct method was used, then\nDirectoryNotEmptyException would be the correct answer. The\nAtomicMoveNotSupportedException in option A is possible only when the\nATOMIC_MOVE option is passed to the move() method. Similarly, the\nFileAlreadyExistsException in option C is possible only when the\nREPLACE_EXISTING option is not passed to the move() method."
      }
    },
    "2": {
      "nbr": 2,
      "value": "What is the result of compiling and executing the following program?\npackage vacation;\nimport java.io.*;\nimport java.util.*;\npublic class Itinerary {\nprivate List<String> activities = new ArrayList<>();\nprivate static Itinerary getItinerary(String name) {\nreturn null;\n}\npublic static void printItinerary() throws Exception {\nConsole c = new Console();\nfinal String name = c.readLine(\"What is your name?\");\nfinal var stuff = getItinerary(name);\nstuff.activities.forEach(s -> c.printf(s));\n}\npublic static void main(String[] h) throws Exception {\nprintItinerary();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code does not compile."
      }, {
        "code": "B",
        "value": "The code compiles and prints a NullPointerException at runtime."
      }, {
        "code": "C",
        "value": "The code compiles but does not print anything at runtime."
      }, {
        "code": "D",
        "value": "The code compiles and prints the value the user enters at runtime."
      }, {
        "code": "E",
        "value": "The behavior cannot be determined until runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "2. A. The constructor for Console is private. Therefore, attempting to call\nnew Console() outside the class results in a compilation error, making\noption A the correct answer. The correct way to obtain a Console instance\nis to call System.console(). Even if the correct way of obtaining a\nConsole had been used, and the Console was available at runtime, stuff is\nnull in the printItinerary() method. Referencing stuff.activities\nresults in a NullPointerException."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Assuming the file path referenced in the following class is accessible and\nwritable, what is the output of the following program? (Choose two.)\nString fn = \"icecream.txt\";\ntry (var w = new BufferedWriter(new FileOutputStream(fn));\nvar s = System.out) {\nw.write(\"ALERT!\");\nw.flush();\nw.write('!');\nSystem.out.print(\"1\");\n} catch (IOException e) {\nSystem.out.print(\"2\");\n} finally {\nSystem.out.print(\"3\");\n}",
      "responses": [{
        "code": "A",
        "value": "1"
      }, {
        "code": "B",
        "value": "23"
      }, {
        "code": "C",
        "value": "13"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "If the code compiles or the lines that do not compile are fixed, then the\nlast value output is 3."
      }, {
        "code": "F",
        "value": "If the code compiles or the lines that do not compile are fixed, then the\nlast value output is not 3."
      }
      ],
      "answer": {
        "codes": [
          "D",
          "F"
        ],
        "explanation": "3. D,F. BufferedWriter is a wrapper class that requires an instance of\nWriter to operate on. Since FileOutputStream does not inherit Writer, the\ncode does not compile, and option D is correct. If FileWriter was used\ninstead of FileOutputStream, then the code would compile without issue\nand print 1. The try‐with‐resources statement closes System.out before the\ncatch or finally blocks are called. When the finally block is executed,\nthe output has nowhere to go, which means the last value of 3 is not printed,\nmaking option F correct."
      }
    },
    "4": {
      "nbr": 4,
      "value": "What is the expected output of the following application? Assume the\ndirectories referenced in the class do not exist prior to the execution and\nthat the file system is available and able to be written.\npackage job;\nimport java.nio.file.*;\npublic class Resume {\npublic void writeResume() throws Exception {\nvar f1 = Path.of(\"/templates/proofs\");\nf1.createDirectories();\nvar f2 = Path.of(\"/templates\");\nf2.createDirectory(); // k1\ntry(var w = Files.newBufferedWriter(\nPath.of(f2.toString(), \"draft.txt\"))) {\nw.append(\"My dream job\");\nw.flush();\n}\nf1.delete(f1);\nf2.delete(f2); // k2\n}\npublic static void main(String… leads) {\ntry {\nnew Resume().writeResume();\n} catch (Exception e) {\ne.printStackTrace();\n} } }",
      "responses": [{
        "code": "A",
        "value": "One line of this application does not compile."
      }, {
        "code": "B",
        "value": "Two lines of this application do not compile."
      }, {
        "code": "C",
        "value": "The code compiles, but line k1 triggers an exception at runtime."
      }, {
        "code": "D",
        "value": "The code compiles, but line k2 triggers an exception at runtime."
      }, {
        "code": "E",
        "value": "The code compiles and runs without printing an exception."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "4. F. The code does not compile. There are no createDirectory(),\ncreateDirectories(), and delete() methods defined on the Path\ninterface. Instead, the NIO.2 Files class should be used. Since four lines of\ncode do not compile, option F is the correct answer. If the lines were\ncorrected to use the Files class, then the application would print an\nexception at line k1, as the directory already exists."
      }
    },
    "5": {
      "nbr": 5,
      "value": "Which classes are least likely to be marked Serializable. (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "A class that monitors the state of every thread in the application"
      }, {
        "code": "B",
        "value": "A class that holds data about the amount of rain that has fallen in a\ngiven year"
      }, {
        "code": "C",
        "value": "A class that manages the memory of running processes in an\napplication"
      }, {
        "code": "D",
        "value": "A class that stores information about apples in an orchard"
      }, {
        "code": "E",
        "value": "A class that tracks the amount of candy in a gumball machine"
      }, {
        "code": "F",
        "value": "A class that tracks which users have logged in"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "5. A,C. Generally speaking, classes should be marked with the\nSerializable interface if they contain data that we might want to save and\nretrieve later. Options B, D, E, and F describe the type of data that we\nwould want to store over a long period of time. Options A and C, though,\ndefine classes that manage transient or short‐lived data. Application\nprocesses change quite frequently, and trying to reconstruct a process is\noften considered a bad idea."
      }
    },
    "6": {
      "nbr": 6,
      "value": "What is the output of the following code snippet? Assume that the current\ndirectory is the root path.\nPath p1 = Path.of(\"./found/../keys\");\nPath p2 = Paths.get(\"/lost/blue.txt\");\nSystem.out.println(p1.resolve(p2));\nSystem.out.println(p2.resolve(p1));",
      "responses": [{
        "code": "A",
        "value": "/lost/blue.txt and /lost/blue.txt/keys"
      }, {
        "code": "B",
        "value": "/found/../keys/./lost/blue.txt and /lost/blue.txt/keys"
      }, {
        "code": "C",
        "value": "/found/../keys/./lost/blue.txt and keys"
      }, {
        "code": "D",
        "value": "/lost/blue.txt and /lost/blue.txt/./found/../keys"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "6. D. First, p2 is an absolute path, which means that p1.resolve(p2) just\nreturns p2. For this reason, options B and C are incorrect. Since p1 is a\nrelative path, it is appended onto p2, making option D correct and option A\nincorrect. Option A would be correct if normalize() was applied."
      }
    },
    "7": {
      "nbr": 7,
      "value": "Fill in the blanks: Writer is a(n) ______________ that related stream\nclasses ______________.",
      "responses": [{
        "code": "A",
        "value": "concrete class, extend"
      }, {
        "code": "B",
        "value": "abstract class, extend"
      }, {
        "code": "C",
        "value": "abstract class, implement"
      }, {
        "code": "D",
        "value": "interface, extend"
      }, {
        "code": "E",
        "value": "interface, implement"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "7. B. Writer is an abstract class, so options A, D, and E are incorrect.\nClasses extend abstract classes; they do not implement them, making option\nB correct. Note that InputStream, OutputStream, and Reader are also\nabstract classes."
      }
    },
    "8": {
      "nbr": 8,
      "value": "Assuming /away/baseball.txt exists and is accessible, what is the\nexpected result of executing the following code snippet?\nvar p1 = Path.of(\"baseball.txt\");\nvar p2 = Path.of(\"/home\");\nvar p3 = Path.of(\"/away\");\nFiles.createDirectories(p2);\nFiles.copy(p3.resolve(p1),p2);",
      "responses": [{
        "code": "A",
        "value": "A new file /home/baseball.txt is created."
      }, {
        "code": "B",
        "value": "A new file /home/away/baseball.txt is created."
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles, but an exception is printed at runtime."
      }, {
        "code": "E",
        "value": "The output cannot be determined until runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "8. D. After calling createDirectories(), the directory /home is guaranteed\nto exist if it does not already. The second argument of the copy() command\nshould be the location of the new file, not the folder the new file is placed\nin. Therefore, the program attempts to write the file to the path /home. Since\nthere is already a directory at that location, a\nFileAlreadyExistsException is thrown at runtime, making option D\ncorrect."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Assuming the file referenced in the following snippet exists and contains\nfive lines with the word eggs in them, what is the expected output?\nvar p = Path.of(\"breakfast.menu\");\nFiles.readAllLines(p)\n.filter(s -> s.contains(\"eggs\"))\n.collect(Collectors.toList())\n.forEach(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "No lines will be printed."
      }, {
        "code": "B",
        "value": "One line will be printed."
      }, {
        "code": "C",
        "value": "Five lines will be printed."
      }, {
        "code": "D",
        "value": "More than five lines will be printed."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "9. E. The code does not compile because readAllLines() returns a\nList<String>, not a stream, making option E the answer. If the correct\nmethod lines() was used instead, then five lines would be printed at\nruntime."
      }
    },
    "10": {
      "nbr": 10,
      "value": "What is the output of the following program? Assume the file paths\nreferenced in the class exist and are able to be written to and read from.\nimport java.io.*;\npublic class Vegetable implements Serializable {\nprivate Integer size = 1;\nprivate transient String name = \"Red\";\n{ size = 3; name = \"Purple\"; }\npublic Vegetable() { this.size = 2; name = \"Green\"; }\npublic static void main(String[] love) throws Throwable\n{\ntry (var o = new ObjectOutputStream(\nnew FileOutputStream(\"healthy.txt\"))) {\nfinal var v = new Vegetable();\nv.size = 4;\no.writeObject(v);\n}\ntry (var o = new ObjectInputStream(\nnew FileInputStream(\"healthy.txt\"))) {\nvar v = (Vegetable) o.readObject();\nSystem.out.print(v.size + \",\" + v.name);\n} } }",
      "responses": [{
        "code": "A",
        "value": "1,Red"
      }, {
        "code": "B",
        "value": "2,Green"
      }, {
        "code": "C",
        "value": "2,null"
      }, {
        "code": "D",
        "value": "3,Purple"
      }, {
        "code": "E",
        "value": "4,null"
      }, {
        "code": "F",
        "value": "null,null"
      }, {
        "code": "G",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "10. E. The size variable is properly serialized with a value of 4. Upon\ndeserialization, none of the class elements that assign a value to an instance\nvariable are run, leading to size being deserialized as 4. Since the name\nvariable is marked transient, this value is deserialized as null. For these\nreasons, option E is correct."
      }
    },
    "11": {
      "nbr": 11,
      "value": "Why does Console readPassword() return a char array rather than a\nString?",
      "responses": [{
        "code": "A",
        "value": "It improves performance."
      }, {
        "code": "B",
        "value": "It improves security."
      }, {
        "code": "C",
        "value": "Passwords must be stored as a char array."
      }, {
        "code": "D",
        "value": "String cannot hold the individual password characters."
      }, {
        "code": "E",
        "value": "It adds encryption."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "11. B. The readPassword() returns a char array for security reasons. If the\ndata was stored as a String, it would enter the shared JVM string pool,\npotentially allowing a malicious user to access it, especially if there is a\nmemory dump. By using a char array, the data can be immediately cleared\nafter it is written and removed from memory. For this reason, option B is\nthe correct answer."
      }
    },
    "12": {
      "nbr": 12,
      "value": "Given the following class inheritance diagram, which two classes can be\nplaced in the blank boxes?",
      "responses": [{
        "code": "A",
        "value": "BufferedOutputStream and PrintStream"
      }, {
        "code": "B",
        "value": "BufferedOutputStream and PrintOutputStream"
      }, {
        "code": "C",
        "value": "ByteArrayOutputStream and Stream"
      }, {
        "code": "D",
        "value": "FileOutputStream and OutputStream"
      }, {
        "code": "E",
        "value": "ObjectOutputStream and PrintOutputStream"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "12. A. While you might not be familiar with FilterOutputStream, the\ndiagram shows that the two classes must inherit from OutputStream.\nOptions B, C, and E can be eliminated as choices since PrintOutputStream\nand Stream are not the name of any java.io classes. Option D can also be\neliminated because OutputStream is already in the diagram, and you cannot\nhave a circular class dependency. That leaves us with the correct answer,\noption A, with BufferedOutputStream and PrintStream both extend\nFilterOutputStream. Note that ByteArrayOutputStream and\nFileOutputStream referenced in Options C and D, respectively, do not\nextend FilterOutputStream, although knowing this fact was not required\nto solve the problem."
      }
    },
    "13": {
      "nbr": 13,
      "value": "How many lines of the following code contain compiler errors?\n12: var path = Paths.get(new URI(\"ice.cool\"));\n13: var view = Files.readAttributes(path,\n14: BasicFileAttributes.class);\n15: Files.createDirectories(Path.relativize(\".backup\"));\n16: if(view.length()> 0 && view.isDirectory())\n17: view.setTimes(null,null,null);\n18: System.out.println(Files.deleteIfExists(path));",
      "responses": [{
        "code": "A",
        "value": "All of the lines compile"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four or more"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "13. D. Line 15 is the first line to not compile, as relativize() is an instance\nmethod, not a static method. Line 16 also does not compile, as size(),\nnot length(), should be used to retrieve a file size. Finally, line 17 does not\ncompile because view is an attribute class, not an attribute view. For line 17\nto compile, line 13–14 would have to use Files.getFileAttributeView()\nwith BasicFileAttributeView.class as the class. The rest of the lines do\nnot contain any compiler errors, making option D correct."
      }
    },
    "14": {
      "nbr": 14,
      "value": "What is the output of the following application?\nimport java.io.*;\npublic class TaffyFactory {\npublic int getPrize(byte[] luck) throws Exception {\ntry (InputStream is = new ByteArrayInputStream(luck))\n{\nis.read(new byte[2]);\nif (!is.markSupported()) return -1;\nis.mark(5);\nis.read(); is.read();\nis.skip(3);\nis.reset();\nreturn is.read();\n}\n}\npublic static void main(String[] x) throws Exception {\nfinal TaffyFactory p = new TaffyFactory();\nfinal var luck = new byte[] { 1, 2, 3, 4, 5, 6, 7 };\nSystem.out.print(p.getPrize(luck));\n} }",
      "responses": [{
        "code": "A",
        "value": "‐2"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "3"
      }, {
        "code": "D",
        "value": "5"
      }, {
        "code": "E",
        "value": "7"
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "14. C. The code compiles and runs without issue. The first two values of the\nByteArrayInputStream are read. Next, the markSupported() value is\ntested. Since ‐1 is not one of the possible options, we assume that\nByteArrayInputStream does support marks. Two values are read and three\nare skipped, but then reset() is called, putting the stream back in the state\nbefore mark() was called. In other words, everything between mark() and\nreset() can be ignored. The last value read is 3, making option C the\ncorrect answer."
      }
    },
    "15": {
      "nbr": 15,
      "value": "What is the output of the following program? Assume the file paths\nreferenced in the class exist and are able to be written to and read from.\npackage heart;\nimport java.io.*;\npublic class Valve implements Serializable {\nprivate int chambers = -1;\nprivate transient Double size = null;\nprivate static String color;\npublic Valve() {\nthis.chambers = 3;\ncolor = \"BLUE\";\n}\npublic static void main(String[] love) throws Throwable\n{\ntry (var o = new ObjectOutputStream(\nnew FileOutputStream(\"scan.txt\"))) {\nfinal Valve v = new Valve();\nv.chambers = 2;\nv.size = 10.0;\nv.color = \"RED\";\no.writeObject(v);\n}\nnew Valve();\ntry (var o = new ObjectInputStream(\nnew FileInputStream(\"scan.txt\"))) {\nValve v = (Valve)o.readObject();\nSystem.out.print(v.chambers+\",\"+v.size+\",\"+v.color);\n}\n}\n{ chambers = 4; }\n}",
      "responses": [{
        "code": "A",
        "value": "2,null,RED"
      }, {
        "code": "B",
        "value": "2,null,BLUE"
      }, {
        "code": "C",
        "value": "3,10.0,RED"
      }, {
        "code": "D",
        "value": "3,10.0,BLUE"
      }, {
        "code": "E",
        "value": "0,null,null"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "15. B. The class compiles and runs without issue, so option F is incorrect. The\nclass defines three variables, only one of which is serializable. The first\nvariable, chambers, is serializable, with the value 2 being written to disk\nand then read from disk. Note that constructors and instance initializers are\nnot executed when a class is deserialized. The next variable, size, is\ntransient. It is discarded when it is written to disk, so it has the default\nobject value of null when read from disk. Finally, the variable color is\nstatic, which means it is shared by all instances of the class. Even though\nthe value was RED when the instance was serialized, this value was not\nwritten to disk, since it was not part of the instance. The constructor call\nnew Valve() between the two try‐with‐resources blocks sets this value to\nBLUE, which is the value printed later in the application. For these reasons,\nthe class prints 2,null,BLUE, making option B the correct answer."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Given the following file system diagram, in which forward is a symbolic\nlink to the java directory, which values if inserted into the following code\ndo not print /java/Sort.java at runtime? (Choose two.)\nPath p = Path.of(\"/\", \"objC\", \"bin\");\nSystem.out.print(p.resolve(\"\").toRealPath());",
      "responses": [{
        "code": "A",
        "value": "objC/forward/Sort.java"
      }, {
        "code": "B",
        "value": "../backwards/../forward/Sort.java"
      }, {
        "code": "C",
        "value": "../forward/./Sort.java"
      }, {
        "code": "D",
        "value": "../java/./forward/Sort.java"
      }, {
        "code": "E",
        "value": "../../java/Sort.java"
      }, {
        "code": "F",
        "value": ".././forward/Sort.java"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D"
        ],
        "explanation": "16. A,D. Simplifying the path symbols, options B, C, and F become\n/objC/forward/Sort.java, which applying the symbol link becomes\n/java/Sort.java. Option E just becomes /java/Sort.java, without any\npath symbols involved. Option A is correct, as the resolve() method\nconcatenates the path to be /objC/bin/objC/forward/Sort.java. Option\nD is also correct, as the simplified path is /objC/java/forward/Sort.java.\nIn both of these cases, the symbolic link /objC/forward cannot be applied."
      }
    },
    "17": {
      "nbr": 17,
      "value": "Which method defined in Reader can be used in place of calling skip(1)?",
      "responses": [{
        "code": "A",
        "value": "jump()"
      }, {
        "code": "B",
        "value": "mark()"
      }, {
        "code": "C",
        "value": "markSupported()"
      }, {
        "code": "D",
        "value": "read()"
      }, {
        "code": "E",
        "value": "reset()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "17. D. The skip(1) method just reads a single byte and discards the value.\nThe read() method can be used for a similar purpose, making option D the\ncorrect answer. Option A is incorrect because there is no jump() method\ndefined in Reader. Options B, C, and E are incorrect because they cannot be\nused to skip data, only to mark a location and return to it later."
      }
    },
    "18": {
      "nbr": 18,
      "value": "The Rose application is run with an input argument of /flower. The\n/flower directory contains five subdirectories, each of which contains five\nfiles. What is the result of executing the following program?\nimport java.nio.file.*;\npublic class Rose {\npublic void tendGarden(Path p) throws Exception {\nFiles.walk(p,1)\n.map(q -> q.toRealPath())\n.forEach(System.out::println);\n}\npublic static void main(String… thorns) throws Exception\n{\nnew Rose().tendGarden(Paths.get(thorns[0]));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The program completes without outputting anything."
      }, {
        "code": "B",
        "value": "One Path value is printed."
      }, {
        "code": "C",
        "value": "Six Path values are printed."
      }, {
        "code": "D",
        "value": "Twenty‐five Path values are printed."
      }, {
        "code": "E",
        "value": "Twenty‐six Path values are printed."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "18. F. Trick question! The code does not compile; therefore, option F is\ncorrect. The toRealPath() interacts with the file system, and therefore\nthrows a checked IOException. Since this checked exception is not handled\ninside the lambda expression, the class does not compile. If the lambda\nexpression was fixed to handle the IOException, then the expected number\nof Path values printed would be six, and option C would be the correct\nanswer. A maxDepth value of 1 causes the walk() method to visit two total\nlevels, the original /flower, and the files it contains."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What may be the result of executing the following program?\npackage test;\nimport java.io.*;\npublic class Turing {\npublic static void main(String… robots) {\nConsole c = System.console();\nfinal String response = c.readLine(\"Are you human?\");\nSystem.err.print(response);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The program asks the user a question and prints the results to the error\nstream."
      }, {
        "code": "B",
        "value": "The program throws a NullPointerException at runtime."
      }, {
        "code": "C",
        "value": "The program does not terminate."
      }, {
        "code": "D",
        "value": "All of the above."
      }, {
        "code": "E",
        "value": "The class does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "19. D. The statements in options A, B, and C are each correct, making option\nD correct. If System.console() is available, then the program will ask the\nuser a question and then print the response to the error stream. On the other\nhand, if System.console() is not available, then the program will exit with\na NullPointerException. It is strongly recommended to always check\nwhether System.console() is null after requesting it. Finally, the user may\nchoose not to respond to the program's request for input, resulting in the\nprogram hanging indefinitely."
      }
    },
    "20": {
      "nbr": 20,
      "value": "What is the output of the following method applied to an InputStream that\ncontains the first four prime numbers, stored as bytes: 2, 3, 5, 7?\nprivate void jumpAround(InputStream is) throws IOException\n{\ntry (is) {\nis.skip(1);\nis.read();\nis.skip(1);\nis.mark(4);\nis.skip(1);\nis.reset();\nSystem.out.print(is.read());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "5"
      }, {
        "code": "B",
        "value": "7"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "E",
        "value": "The result cannot be determined until runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "20. E. The code compiles, so option C is incorrect. Not all InputStream\nclasses support the mark() operation. If mark() is supported, then 7 is\nprinted at runtime. Alternatively, if mark() is not supported, then an\nIOException will be printed at runtime. For this reason, option E is correct.\nAlways remember to call markSupported() before using a mark()\noperation on an InputStream."
      }
    },
    "21": {
      "nbr": 21,
      "value": "Which statement about the following method is correct? Assume the\ndirectory /tea/earlGrey/hot exists and is able to be read.\nvoid order() throws Exception {\nvar s = Path.of(\"/tea\",\"earlGrey\",\"hot\");\nFiles.find(s, (p,a) -> a.isDirectory());\n}",
      "responses": [{
        "code": "A",
        "value": "It does not compile."
      }, {
        "code": "B",
        "value": "It compiles but does not print anything at runtime."
      }, {
        "code": "C",
        "value": "It compiles and prints true exactly once at runtime."
      }, {
        "code": "D",
        "value": "It compiles and prints true at least once."
      }, {
        "code": "E",
        "value": "The answer cannot be determined without knowing the contents of the\ndirectory."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "21. A. The Files.find() method requires a maxDepth value as the second\nparameter. Since this parameter is missing, the method does not compile,\nand option A is correct. If a maxDepth parameter was added, then the\nmethod would compile but not print anything at runtime since the stream\ndoes not include a terminal operation."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Which method are classes that implement java.io.Serializable required\nto implement?",
      "responses": [{
        "code": "A",
        "value": "cereal()"
      }, {
        "code": "B",
        "value": "deserialize()"
      }, {
        "code": "C",
        "value": "serial()"
      }, {
        "code": "D",
        "value": "serialize()"
      }, {
        "code": "E",
        "value": "clone()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "22. F. Serializable is a marker interface, which means it does not contain\nany abstract methods that require implementation, making option F correct.\nThe interface is only meant to indicate the object is capable of serialization."
      }
    },
    "23": {
      "nbr": 23,
      "value": "What is the result of compiling and executing the following program?\nAssume the current directory is /stock and the path /stock/sneakers does\nnot exist prior to execution.\npackage shoe;\nimport java.io.*;\nimport java.nio.file.*;\npublic class Sneaker {\npublic void setupInventory(Path d) throws Exception {\nPath suggestedPath = Paths.get(\"sneakers\");\nif(Files.isSameFile(suggestedPath, d) // j1\n&& !Files.exists(suggestedPath))\nFiles.createDirectories(d); // j2\n}\npublic static void main(String[] socks) throws Exception\n{\nPath w = new File(\"/stock/sneakers\").toPath(); // j3\nnew Sneaker().setupInventory(w);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The directory /stock/sneakers is created."
      }, {
        "code": "B",
        "value": "Line j1 does not compile or produces an exception at runtime."
      }, {
        "code": "C",
        "value": "Line j2 does not compile or produces an exception at runtime."
      }, {
        "code": "D",
        "value": "Line j3 does not compile or produces an exception at runtime."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "23. B. First, the class compiles without issue. It is not without problems,\nthough. The Files.isSameFile() method call on line j1 first checks if the\nPath values are equivalent in terms of equals(). One is absolute, and the\nother is relative, so this test will fail. The isSameFile() method then moves\non to verify that the two Path values reference the same file system object.\nSince we know the directory does not exist, the call to isSameFile() on\nline j1 will produce a NoSuchFileException at runtime, making option B\nthe correct answer."
      }
    },
    "24": {
      "nbr": 24,
      "value": "Assuming the absolute path referenced in the code exists and its contents\nare accessible, which statement about the following code snippet is correct?\nPath p = Paths.get(\"/glasses/lens\");\nFiles.walk(p)\n.map(z -> z.toAbsolutePath().toString())\n.filter(s -> s.endsWith(\".java\"))\n.collect(Collectors.toList()).forEach(System.out::println);\nFiles.find(p,Integer.MAX_VALUE,\n(w,a) ->\nw.toAbsolutePath().toString().endsWith(\".java\"))\n.collect(Collectors.toList()).forEach(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "The first stream statement does not compile."
      }, {
        "code": "B",
        "value": "The second stream statement does not compile."
      }, {
        "code": "C",
        "value": "Neither statement compiles."
      }, {
        "code": "D",
        "value": "Both statements compile and produce the same result at runtime."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "24. D. Both stream statements compile without issue, making options A, B,\nand C incorrect. The two statements are equivalent to one another and print\nthe same values at runtime. For this reason, option D is correct. There are\nsome subtle differences between the two methods calls. The walk() call\ndoes not include a depth limit, but since Integer.MAX_VALUE is the default\nvalue, the two calls are equivalent. Furthermore, the walk() statement\nprints a stream of absolute paths stored as String values, while the find()\nstatement prints a stream of Path values. If the input p was a relative path,\nthen these two calls would have very different results, but since we are told\np is an absolute path, the application of toAbsolutePath() does not change\nthe results."
      }
    },
    "25": {
      "nbr": 25,
      "value": "When reading file information, what is an advantage of using an NIO.2\nattribute interface rather than reading the values individually using Files\nmethods? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Costs fewer round‐trips to the file system"
      }, {
        "code": "B",
        "value": "Guarantees performance improvement"
      }, {
        "code": "C",
        "value": "Has support for symbolic links"
      }, {
        "code": "D",
        "value": "Reduces memory leaks"
      }, {
        "code": "E",
        "value": "Supports file‐system dependent attributes"
      }, {
        "code": "F",
        "value": "Reduces resource leaks"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "25. A,E. An attribute view has the advantage of reading all of the file\ninformation on a single trip, rather than multiple trips to the file system\nmaking option A correct. Option B is incorrect because nothing guarantees\nit will perform faster, especially if the Files method is only being used to\nread a single attribute. Option C is also incorrect because both sets of\nmethods have built‐in support for symbolic links. Options D and F are\nincorrect because memory and resource leaks are not related to reading file\nattribute views. Finally, option E is correct, as NIO.2 supports file‐system\ndependent attribute view classes."
      }
    },
    "26": {
      "nbr": 26,
      "value": "Suppose that you need to read data that consists of serialized int, double,\nboolean, and String values from a file. You also want the program to be\nperformant on large files. Which three java.io stream classes can be\nchained together to best achieve this result? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "BufferedInputStream"
      }, {
        "code": "B",
        "value": "FileReader"
      }, {
        "code": "C",
        "value": "ObjectInputStream"
      }, {
        "code": "D",
        "value": "BufferedReader"
      }, {
        "code": "E",
        "value": "BufferedStream"
      }, {
        "code": "F",
        "value": "FileInputStream"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "F"
        ],
        "explanation": "26. A,C,F. Since you need to read primitives and String values, the\nInputStream classes are appropriate. Therefore, you can eliminate options\nB and D since they use Reader classes. Option E is incorrect, as this is not a\njava.io class. The data should be read from the file using an\nFileInputStream class, buffered with a BufferedInputStream class for\nperformance, and deserialized into Java‐accessible data types with an\nObjectInputStream class, making options A, C, and F correct."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Which statement about the following method is correct? Assume the\ndirectory coffee exists and is able to be read.\nvoid brew() throws Exception {\nfinal var m = Path.of(\"coffee\");\nFiles.walk(m)\n.filter(Files::isDirectory)\n.forEach(Files::isDirectory);\n}",
      "responses": [{
        "code": "A",
        "value": "It does not compile."
      }, {
        "code": "B",
        "value": "It compiles but does not print anything at runtime."
      }, {
        "code": "C",
        "value": "It compiles and prints true exactly once at runtime."
      }, {
        "code": "D",
        "value": "It compiles and prints true at least once."
      }, {
        "code": "E",
        "value": "The answer cannot be determined without knowing the contents of the\ndirectory."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "27. B. The method compiles, so option A is incorrect. The method reads all of\nthe elements of a directory tree, keeping only directories. The forEach()\nmethod does not print anything, though, making option B correct. If the\nlambda in the forEach() method was modified to print something, such as\ns ‐> System.out.println(Files.isDirectory(s)), then it would print\ntrue at least once for the coffee directory. It would then print true for each\ndirectory within the directory tree."
      }
    },
    "28": {
      "nbr": 28,
      "value": "Assuming the file referenced in the StudentManager class exists and\ncontains data, which statement about the following class is correct?\n(Choose two.)\npackage school;\nimport java.io.*;\nclass Student implements Serializable {\ntransient int score = -1;\nString name; public String toString() { return name +\n\":\" + score; }\n}\npublic class StudentManager {\npublic static void main(String[] grades) {\ntry(var ios = new ObjectInputStream(\nnew FileInputStream(new File(\"s.data\")))) {\nStudent record;\nwhile((record = (Student)ios.readObject()) !=\nnull)\nSystem.out.print(record);\n} catch (EOFException e) {\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code does not compile."
      }, {
        "code": "B",
        "value": "The code compiles but prints an exception at runtime."
      }, {
        "code": "C",
        "value": "The program runs and prints all students in the file."
      }, {
        "code": "D",
        "value": "The program runs but may only print some students in the files."
      }, {
        "code": "E",
        "value": "For any instance of Student that is correctly deserialized, the value of\nscore will be ‐1."
      }, {
        "code": "F",
        "value": "For any instance of Student that is correctly deserialized, the value of\nscore will not be ‐1."
      }
      ],
      "answer": {
        "codes": [
          "D",
          "F"
        ],
        "explanation": "28. D,F. The code compiles and runs without issue, so options A and B are\nincorrect. The problem with the implementation is that checking if\nios.readObject() is null is not the recommended way of iterating over an\nentire file. For example, the file could have been written with\nwriteObject(null) in between two non‐null records. In this case, the\nreading of the file would stop on this null value, before the end of the file\nhas been reached. For this reason, option D is the correct answer. Note that\nthe valid way to iterate over all elements of a file using ObjectInputStream\nis to continue to call readObject() until an EOFException is thrown.\nFinally, score is marked transient, which means the default int value of\n0 will be set when the class is deserialized, making option F correct."
      }
    },
    "29": {
      "nbr": 29,
      "value": "Given an instance of Console c, which of the following two method calls\nare invalid ways of retrieving input from the user? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "c.read()"
      }, {
        "code": "B",
        "value": "c.reader().read()"
      }, {
        "code": "C",
        "value": "c.reader().readLine()"
      }, {
        "code": "D",
        "value": "c.readLine()"
      }, {
        "code": "E",
        "value": "c.readPassword()"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "29. A,C. The Console class contains readLine() and readPassword()\nmethods, but not a read() method, making option A one of the correct\nanswers, and options D and E incorrect. It also contains a reader() method\nthat returns a Reader object. The Reader class defines a read() method, but\nnot a readLine() method. For this reason, option C is the other correct\nanswer, and option B is incorrect. Recall that a BufferedReader is required\nto call the readLine() method."
      }
    },
    "30": {
      "nbr": 30,
      "value": "What is the output of the following code snippet? Assume that the current\ndirectory is the root path /.\nPath p1 = Paths.get(\"./locks\");\nPath p2 = Paths.get(\"/found/red.zip\");\nSystem.out.println(p1.relativize(p2));\nSystem.out.println(p2.relativize(p1));",
      "responses": [{
        "code": "A",
        "value": "../found/red.zip and ../../locks"
      }, {
        "code": "B",
        "value": "/found/red.zip and /found/red.zip/./locks"
      }, {
        "code": "C",
        "value": "locks/../found/red.zip and ../found/locks"
      }, {
        "code": "D",
        "value": "../../locks and ../found/red.zip"
      }, {
        "code": "E",
        "value": "/found/red.zip and /found/red.zip/locks"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "30. F. The relativize() method requires that both path values be absolute or\nrelative. Based on the details provided, p1 is a relative path, while p2 is an\nabsolute path. For this reason, the code snippet produces an exception at\nruntime, making option F the correct answer. If the first path was modified\nto be absolute by dropping the leading dot (.) in the path expression, then\nthe output would match the values in option A."
      }
    },
    "31": {
      "nbr": 31,
      "value": "Assuming the current working directory is /home, then what is the output of\nthe following program?\n1: package magic;\n2: import java.nio.file.*;\n3: public class Magician {\n4: public String doTrick(Path path) {\n5: return path.subpath(2,3)\n6: .getName(1)\n7: .toAbsolutePath()\n8: .toString();\n9: }\n10: public static void main(String… cards) {\n11: final Magician m = new Magician();\n12: System.out.print(m.doTrick(\n13:\nPaths.get(\"/bag/of/tricks/.././disappear.txt\")));\n14: } }",
      "responses": [{
        "code": "A",
        "value": "/home/tricks"
      }, {
        "code": "B",
        "value": "/home"
      }, {
        "code": "C",
        "value": "tricks"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but prints an exception at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "31. E. The code compiles without issue. Even though tricks would be\ndropped in the normalized path /bag/of/disappear.txt, there is no\nnormalize() call, so path.subpath(2,3) returns tricks on line 5. On line\n6, the call to getName() throws an IllegalArgumentException at runtime.\nSince getName() is zero‐indexed and contains only one element, the call on\nline 6 throws an IllegalArgumentException, making option E the correct\nanswer. If getName(0) had been used instead of getName(1), then the\nprogram would run without issue and print /home/tricks."
      }
    },
    "32": {
      "nbr": 32,
      "value": "Which statements about the Files methods lines() and readAllLines()\nare correct? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "They have different return types."
      }, {
        "code": "B",
        "value": "The readAllLines() method is always faster."
      }, {
        "code": "C",
        "value": "The lines() may require more memory."
      }, {
        "code": "D",
        "value": "They have the same return type."
      }, {
        "code": "E",
        "value": "The lines() method is always faster."
      }, {
        "code": "F",
        "value": "The readAllLines() method may require more memory."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "F"
        ],
        "explanation": "32. A,F. The lines() method returns Stream<String>, while the\nreadAllLines() method returns List<String>, making option A correct\nand option D incorrect. Neither method is guaranteed to be faster or slower\nthan the other, making options B and E incorrect. The lines() method\nlazily reads the file as the stream is processed, while the readAllLines()\nmethod reads the entire file into memory at once. For this reason, the\nreadAllLines() method may require more memory to hold a large file,\nmaking option F correct and option C incorrect."
      }
    },
    "33": {
      "nbr": 33,
      "value": "Given the following application, in which a user enters bone twice, what is\nthe expected result?\nlong start = System.currentTimeMillis();\nvar retriever = new BufferedReader(new\nInputStreamReader(System.in));\ntry(retriever; var husky = System.err) {\nvar fetch = retriever.readLine();\nSystem.out.printf(\"%s fetched in %5.1f seconds\",fetch,\n// v1\n(System.currentTimeMillis()-start)/1000.0);\n}\nvar fetchAgain = retriever.readLine();\nSystem.out.println(fetchAgain + \" fetched again!\");",
      "responses": [{
        "code": "A",
        "value": "The program completes after printing a message once."
      }, {
        "code": "B",
        "value": "The program completes after printing a message twice."
      }, {
        "code": "C",
        "value": "An IOException is thrown."
      }, {
        "code": "D",
        "value": "The program prints an exception because the format of the String on\nline v1 is invalid."
      }, {
        "code": "E",
        "value": "A NullPointerException is thrown since System.in may be\nunavailable."
      }, {
        "code": "F",
        "value": "None of the above as the code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "33. A. First, the code compiles. The format of the String on line v1 is valid,\nmaking option D incorrect. While System.console() throws a\nNullPointerException if it is not available, System.in does not, making\noption E incorrect.\nThe first part of the code runs without issue, printing a message such as\nbone fetched in 1.8 seconds. The I/O stream System.in is closed at the\nend of the try‐with‐resources block. That means calling readLine() again\nresults in an operation on a closed stream, which would print an exception\nat runtime and make option C correct, except System.err is already closed\ndue to the try‐with‐resources block! Therefore, only one message is printed,\nand option A is correct."
      }
    },
    "34": {
      "nbr": 34,
      "value": "What is the expected result of calling deleteTree() on a directory?\nAssume the directory exists and is able to be modified.\nimport java.nio.file.*;\npublic class Exterminate {\npublic void deleteTree(Path q) {\nif (!Files.isDirectory(q))\nFiles.delete(q);\nelse {\nFiles.list(q).forEach(this::deleteTree);\nFiles.delete(q);\n} } }",
      "responses": [{
        "code": "A",
        "value": "It will delete the directory itself only."
      }, {
        "code": "B",
        "value": "It will delete the directory and its file contents only."
      }, {
        "code": "C",
        "value": "It will delete the entire directory tree."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but produces an exception at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "34. D. The Files.delete() and Files.list() declare a checked\nIOException that must be handled or declared. For this reason, the code\ndoes not compile, and option D is correct."
      }
    },
    "35": {
      "nbr": 35,
      "value": "Which code, if inserted into the method, will cause it to correctly copy any\nfile passed to it that is accessible? (Choose two.)\nvoid copyFile(String source, String target) throws\nException {\ntry (var is = new FileInputStream(source);\nOutputStream os = new FileOutputStream(target)) {\nbyte[] data = new byte[123];\nint chirps;\n// INSERT CODE HERE\n}\n}",
      "responses": [{
        "code": "A",
        "value": "while (is.read(data)> 0)\nos.write(data);"
      }, {
        "code": "B",
        "value": "while ((chirps = is.read(data))> 0)\nos.write(data, 0, chirps);"
      }, {
        "code": "C",
        "value": "while ((chirps = is.read(data))> 0)\nos.write(data);"
      }, {
        "code": "D",
        "value": "while ((chirps = is.read(data))> 0)\nos.write(data, chirps, data.length);"
      }, {
        "code": "E",
        "value": "String line;\nwhile ((line = is.readLine()) != null)\nos.write(line + \"\\n\");"
      }, {
        "code": "F",
        "value": "while ((chirps = is.read())> 0)\nos.write(chirps);"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "35. B,F. All of the options compile except option E, since FileInputStream\ndoes not have a readLine() method. A BufferedReader should be used\ninstead. Options A and C suffer from the same problem. If the file is not\nexactly a multiple of 123 bytes, then extra information will be written to the\nfile from the end of the data array. Option D is incorrect because the\nsecond argument should be an offset, and the third argument should be the\nnumber of bytes to read from the data array.\nOption B is correct and uses an array to read a fixed number of bytes and\nthen writes that exact number of bytes to the output file. Option F is also\nthen writes that exact number of bytes to the output file. Option F is also\ncorrect, although it does not use an array. Instead, a single byte is read and\nwritten on each iteration of the loop."
      }
    },
    "36": {
      "nbr": 36,
      "value": "Let's say we want to write an instance of Cereal to disk, having a name\nvalue of CornLoops and sugar value of 5. What is the value of name and\nsugar after this object has been read from disk using the\nObjectInputStream's readObject() method?\npackage breakfast;\nimport java.io.Serializable;\nclass Bowl {\nboolean spoon = true;\n// Getters/Setters Omitted\n}\npublic class Cereal implements Serializable {\nprivate String name = \"CocoaCookies\";\nprivate transient int sugar = 10;\nprivate Bowl bowl;\npublic Cereal() {\nsuper();\nthis.name = \"CaptainPebbles\";\nthis.bowl = new Bowl();\nsugar = 2;\n}\n{ name = \"SugarPops\"; }\n// Getters/Setters Omitted\n}",
      "responses": [{
        "code": "A",
        "value": "CaptainPebbles and 10"
      }, {
        "code": "B",
        "value": "CornLoops and 0"
      }, {
        "code": "C",
        "value": "SugarPops and 10"
      }, {
        "code": "D",
        "value": "SugarPops and 2"
      }, {
        "code": "E",
        "value": "CornLoops and ‐1"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "36. F. The Bowl class does not implement the Serializable interface;\ntherefore, attempting to write the instance to disk, or calling readObject()\nusing ObjectInputStream, will result in a NotSerializableException at\nruntime. Remember, all instance members of a class must be serializable or\nmarked transient for the class to properly implement the Serializable\ninterface and be used with Java serialization. For this reason, option F is the\ncorrect answer. If the Bowl class did implement Serializable, then the\nvalue of name and sugar would be CornLoops and 0, respectively, since\nnone of the constructors, initializers, or setters methods are used on\ndeserialization, making option B the correct answer."
      }
    },
    "37": {
      "nbr": 37,
      "value": "What is the output of the following code snippet?\n11: var halleysComet =\nPath.of(\"stars/./rocks/../m1.meteor\")\n12: .subpath(1, 5).normalize();\n13:\n14: var lexellsComet = Paths.get(\"./stars/../solar/\");\n15: lexellsComet.subpath(1, 3)\n16: .resolve(\"m1.meteor\").normalize();\n17:\n18: System.out.print(halleysComet.equals(lexellsComet) ?\n19: \"Same!\" : \"Different!\");",
      "responses": [{
        "code": "A",
        "value": "Same!"
      }, {
        "code": "B",
        "value": "Different!"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The class compiles but throws an exception at runtime."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "37. B. The program compiles and runs without issue, making options C and D\nincorrect. The first variable, halleysComet, is created with subpath(1,5)\nand normalize() being applied right away, leading to halleysComet being\nassigned a value of m1.meteor. The second variable, lexellsComet is\nassigned a value on line 14, but lines 15–16 do not include an assignment\noperation. Since Path instances are immutable, the changes are lost. For\nthis reason, the two objects are not equivalent on lines 18–19, and option B\nis correct. If lexellsComet was assigned the value created on line 15–16,\nthough, then the path value of lexellsComet would be m1.meteor and\noption A would be correct."
      }
    },
    "38": {
      "nbr": 38,
      "value": "During deserialization from an I/O stream, which element of the class can\nbe used to assign a value to the deserialized object?",
      "responses": [{
        "code": "A",
        "value": "Variable initializer"
      }, {
        "code": "B",
        "value": "Instance initializer"
      }, {
        "code": "C",
        "value": "Static initializer"
      }, {
        "code": "D",
        "value": "Constructor"
      }, {
        "code": "E",
        "value": "The restoreObject() method"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "38. F. When data is deserialized, none of variable initializers, instance\ninitializers, or constructors is called. The class can have static initializers,\nbut they are not called as part of deserialization. Finally, there is no\nrestoreObject() method that is used in standard deserialization. For these\nreasons, option F is correct."
      }
    },
    "39": {
      "nbr": 39,
      "value": "Assuming there are no symbolic links involved and file\n/nursery/sapling.seed exists, which statements about the following code\nsnippet are correct? (Choose three.)\nFiles.move(\nPaths.get(\"/nursery/sapling.seed\"),\nPaths.get(\"/forest\"),\nStandardCopyOption.ATOMIC_MOVE);",
      "responses": [{
        "code": "A",
        "value": "The code may throw an exception at runtime."
      }, {
        "code": "B",
        "value": "The code may complete without throwing an exception at runtime."
      }, {
        "code": "C",
        "value": "After it runs, the new location of the file would be\n/nursery/sapling.seed"
      }, {
        "code": "D",
        "value": "After it runs, the new location of the file would be\n/forest/sapling.seed"
      }, {
        "code": "E",
        "value": "If a process is monitoring the move, it will not see an incomplete file."
      }, {
        "code": "F",
        "value": "If a process is monitoring the move, it could see an incomplete file."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "E"
        ],
        "explanation": "39. A,B,E. The code moves a file from /nursery/sapling.seed to the new\nlocation of /forest, not /forest/sapling.seed. For this reason, options C\nand D are both incorrect. If there is no file or directory at /forest, then the\nprogram completes successfully. If a file already exists at that location, then\nan exception is thrown since the REPLACE_EXISTING flag is not set. For\nthese reasons, options A and B are both correct. Since the ATOMIC_MOVE flag\nis set, option E is correct, and option F is incorrect."
      }
    },
    "40": {
      "nbr": 40,
      "value": "What is the output of the following application? Assume /all‐data exists\nand is accessible within the file system.\n1: package sesame;\n2: import java.nio.file.*;\n3: import java.util.stream.*;\n4: public class TheCount {\n5: public static Stream<String> readLines(Path p) {\n6: try { return Files.lines(p); } catch (Exception\ne) {\n7: throw new RuntimeException(e);\n8: }\n9: }\n10: public static long count(Path p) throws Exception {\n11: return Files.list(p)\n12: .filter(w -> Files.isRegularFile(w))\n13: .flatMap(s -> readLines(s))\n14: .count();\n15: }\n16: public static void main(String[] d) throws Exception\n{\n17: System.out.print(count(Paths.get(\"/all-data\")));\n18: } }",
      "responses": [{
        "code": "A",
        "value": "The code does not compile."
      }, {
        "code": "B",
        "value": "The number of lines in all files in a directory tree."
      }, {
        "code": "C",
        "value": "The number of lines in all files in a single directory."
      }, {
        "code": "D",
        "value": "The code hangs indefinitely at runtime."
      }, {
        "code": "E",
        "value": "An exception is printed at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "40. C. The program compiles and runs without issue, making options A, D,\nand E incorrect. The program uses Files.list() to iterate over all files\nwithin a single directory. For each file, it then iterates over the lines of the\nfile and sums them. For this reason, option C is the correct answer. If the\ncount() method had used Files.walk() instead of Files.lines(), then\nthe class would still compile and run, and option B would be the correct\nanswer. Note that we had to wrap Files.lines() in a try/catch block,\nbecause using this method directly within a lambda expression without one\nleads to a compilation error."
      }
    }
  }
}, {
  "name": "Secure Coding in Java SE Application",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "Which statement best describes this class?\nimport java.util.*;\npublic final class Forest {\nprivate final int flora;\nprivate final List<String> fauna;\npublic Forest() {\nthis.flora = 5;\nthis.fauna = new ArrayList<>();\n}\npublic int getFlora() {\nreturn flora;\n}\npublic List<String> getFauna() {\nreturn fauna;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "It can be serialized."
      }, {
        "code": "B",
        "value": "It is well encapsulated."
      }, {
        "code": "C",
        "value": "It is immutable."
      }, {
        "code": "D",
        "value": "It is both well encapsulated and immutable."
      }, {
        "code": "E",
        "value": "None of the above as the code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "1. B. This class does not implement Serializable, so option A is incorrect.\nThis code is well encapsulated because the instance variables are private.\nWhile the instance variable references do not change after the object is\ncreated, the contents fauna can be modified, so it is not immutable. For\nthese reasons, option B is correct."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Fill in the blanks: The ___________ class variable defines a whitelist of\nfields that should be serialized, while the ___________ modifier is used to\nconstruct a blacklist of fields that should not be serialized. (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "serialVersionUID in the first blank"
      }, {
        "code": "B",
        "value": "serialFields in the first blank"
      }, {
        "code": "C",
        "value": "serialPersistentFields in the first blank"
      }, {
        "code": "D",
        "value": "ignore in the second blank"
      }, {
        "code": "E",
        "value": "transient in the second blank"
      }, {
        "code": "F",
        "value": "skip in the second blank"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "2. C,E. Options B, D, and F are not supported options in Java. The\nserialVersionUID class variable can be used in serialization, but it relates\nto the version of the class stored, not the choice in fields serialized, making\noption A incorrect. That leaves options C and E as the correct answers. The\nserialPersistentFields class variable defines a whitelist of fields to\nserialize, while the transient modifier constructs a blacklist of fields to\nskip."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Which statement best describes the following method?\npublic String findNewLego(String url, String type)\nthrows SQLException {\nvar query = \"SELECT name FROM sets WHERE \"\n+ \"type = \" + type + \" ORDER BY date DESC\";\nvar con = DriverManager.getConnection(url);\ntry(con;\nvar ps = con.createStatement();\nvar rs = ps.executeQuery(query)) {\nif(rs.next()) return rs.getString(1);\n}\nthrow new RuntimeException(\"None available, try\nlater\");\n}",
      "responses": [{
        "code": "A",
        "value": "It is not susceptible to any common attacks."
      }, {
        "code": "B",
        "value": "It is at risk of SQL injection attack only."
      }, {
        "code": "C",
        "value": "It is at risk of a denial of service attack only."
      }, {
        "code": "D",
        "value": "It is at risk of both SQL injection and denial of service attacks."
      }, {
        "code": "E",
        "value": "The method does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "3. B. The method compiles, so option E is incorrect. It is recommended to\nuse a PreparedStatement with bind variables, over a Statement, to avoid\nSQL injection. Since the data type of the variable is String, it needs to be\nescaped making this method at risk for SQL injection.\nFurther, there is no risk of a resource leak that could be exploited in a denial\nof service attack. The Connection object is declared immediately before the\ntry‐with‐resources block and closed by it, so it cannot be left open. For\nthese reasons, option B is correct."
      }
    },
    "4": {
      "nbr": 4,
      "value": "Fill in the blanks: ____________ means the state of an object cannot be\nchanged, while _____________ means that it can.",
      "responses": [{
        "code": "A",
        "value": "Encapsulation, factory method"
      }, {
        "code": "B",
        "value": "Immutability, mutability"
      }, {
        "code": "C",
        "value": "Rigidity, flexibility"
      }, {
        "code": "D",
        "value": "Static, instance"
      }, {
        "code": "E",
        "value": "Tightly coupled, loosely coupled"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "4. B. Option B is correct because mutability means the state can change, and\nimmutability means it cannot. The other options are invalid. In option C,\nrigidity is not a common programming term."
      }
    },
    "5": {
      "nbr": 5,
      "value": "Which of the following best protect against denial of service attacks?\n(Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Close resources with catch blocks."
      }, {
        "code": "B",
        "value": "Use PreparedStatement instead of Statement."
      }, {
        "code": "C",
        "value": "Close resources with try‐with‐resources statements."
      }, {
        "code": "D",
        "value": "Set a limit of the size of a file upload."
      }, {
        "code": "E",
        "value": "Set a limit on the size of a numeric input value."
      }, {
        "code": "F",
        "value": "Use immutable objects."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D",
          "E"
        ],
        "explanation": "5. C,D,E. A denial of service attack is about overloading the system with too\nmuch data or too many requests to process legitimate incoming requests.\nOption A is incorrect, and option C is correct because a try‐with‐resources\nor finally block should be used to close resources to prevent a resource\nleak. Option B is incorrect because SQL injection is a form of injection\nattack, not one based on volume or resources.\nOption D is correct because a malicious attack could send a lot of bad\nrequests with huge files. Option E is also correct as numeric overflow can\nbe used to overwhelm a system. Option F is incorrect because immutability\nbe used to overwhelm a system. Option F is incorrect because immutability\ndoes not usually play a part in DoS attacks."
      }
    },
    "6": {
      "nbr": 6,
      "value": "You ask to borrow one of your friend's recipe cards. Which statements\nabout these cards, represented as Java policy file grants, are correct?\n(Choose two.)\ngrant {\npermission java.io.FilePermission\n\"/dessert/icecream/rockyroad.yum\", \"read,write\";\npermission java.io.FilePermission\n\"/dessert/icecream/mintchip.yum\", \"read\";\n};",
      "responses": [{
        "code": "A",
        "value": "The policy syntax of the policy file is correct."
      }, {
        "code": "B",
        "value": "The policy syntax of the policy file is incorrect."
      }, {
        "code": "C",
        "value": "The policy is incorrect because read should not be included in the first\npermission."
      }, {
        "code": "D",
        "value": "The policy is incorrect because write should not be included in the\nfirst permission."
      }, {
        "code": "E",
        "value": "The policy is incorrect because read should not be included in the\nsecond permission."
      }, {
        "code": "F",
        "value": "The policy is incorrect because file permissions cannot be granted this\nway."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D"
        ],
        "explanation": "6. A,D. The policy compiles and uses correct syntax, making option A\ncorrect. However, it gives permissions that are too broad. The user needs to\nbe able to read a recipe, so write permissions should not be granted,\nmaking option D also correct."
      }
    },
    "7": {
      "nbr": 7,
      "value": "Which of the following best protect against inclusion attacks? (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "Encrypt user passwords."
      }, {
        "code": "B",
        "value": "Use immutable objects."
      }, {
        "code": "C",
        "value": "Limit the recursive depth of ZIP files."
      }, {
        "code": "D",
        "value": "Apply a blacklist to the input data."
      }, {
        "code": "E",
        "value": "Turn the computer off when not in use."
      }, {
        "code": "F",
        "value": "Restrict the number of parse levels of XML files."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "7. C,F. Inclusion attacks occur when multiple files or components are\nembedded within a single entity, such as a zip bomb or the billion laughs\nattack. Both can be thwarted with depth limits, making option C and F\ncorrect. The rest of the options are not related to inclusion attacks."
      }
    },
    "8": {
      "nbr": 8,
      "value": "What changes, taken together, would make the Tree class immutable?\n(Choose three.)\n1: public class Tree {\n2: String species;\n3: public Tree(String species) {\n4: this.species = species;\n5: }\n6: public String getSpecies() {\n7: return species;\n8: }\n9: private final void setSpecies(String newSpecies) {\n10: species = newSpecies;\n11: }\n12: }",
      "responses": [{
        "code": "A",
        "value": "Make all constructors private."
      }, {
        "code": "B",
        "value": "Change the access level of species to private."
      }, {
        "code": "C",
        "value": "Change the access level of species to protected."
      }, {
        "code": "D",
        "value": "Remove the setSpecies() method."
      }, {
        "code": "E",
        "value": "Mark the Tree class final."
      }, {
        "code": "F",
        "value": "Make a defensive copy of species in the Tree constructor."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "E"
        ],
        "explanation": "8. B,D,E. Immutable objects are ones that are not modified after they are\ncreated. Immutable objects can have public constructors. There is no need\nto change the access modifier to private, making option A incorrect. All\ninstance variables should be private in an immutable class to prevent\nsubclasses and classes within the package from modifying them outside the\nclass, making option B correct and option C incorrect. They should not\nhave any setter methods, making option D correct. The class should also\neither be marked final or contain final methods to prevent subclasses\nfrom altering the behavior of the class, making option E correct. Finally,\noption F is incorrect as String is immutable, so a defensive copy is not\nrequired. Note that if species were a mutable type, like List, a defensive\ncopy would be required."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Which techniques best prevent sensitive objects from being manipulated by\nan attacker who wants to create a malicious subclass? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Add final to the class declaration."
      }, {
        "code": "B",
        "value": "Set protected as the access level for all method declarations."
      }, {
        "code": "C",
        "value": "Add final to all method declarations."
      }, {
        "code": "D",
        "value": "Add final to all instance variable declarations."
      }, {
        "code": "E",
        "value": "Add final to all constructors."
      }, {
        "code": "F",
        "value": "Set private as the access level for all constructors."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "F"
        ],
        "explanation": "9. A,C,F. The best way to protect a sensitive class is to prevent the class\nfrom being extended or prevent any of its methods from being overridden.\nOptions A and C accomplish this. Option F also is appropriate. By marking\nall constructors private, only static methods that the class controls can be\nused to obtain instances of the object. Options B and D are incorrect\nbecause they do not prevent methods from being overridden that could\nchange the behavior of the class. Option E is incorrect because constructors\ncannot be marked final."
      }
    },
    "10": {
      "nbr": 10,
      "value": "Which statement best describes the following method?\npublic String findNewLego(String url, int type)\nthrows SQLException {\nvar query = \"SELECT name FROM sets WHERE \"\n+ \"type = \" + type + \" ORDER BY date DESC\";\nvar con = DriverManager.getConnection(url);\nvar ps = con.createStatement();\ntry(con; ps; var rs = ps.executeQuery(query)) {\nif(rs.next()) return rs.getString(1);\n}\nthrow new RuntimeException(\"None available, try\nlater\");\n}",
      "responses": [{
        "code": "A",
        "value": "It is not susceptible to any common attacks."
      }, {
        "code": "B",
        "value": "It is at risk of SQL injection attack only."
      }, {
        "code": "C",
        "value": "It is at risk of a denial of service attack only."
      }, {
        "code": "D",
        "value": "It is at risk of both SQL injection and denial of service attacks."
      }, {
        "code": "E",
        "value": "The method does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "10. C. The class compiles, so option E is incorrect. It is recommended to use a\nPreparedStatement over a Statement to avoid SQL injection although it is\nnot strictly necessary. In this case, because the data type of the variable is\nint, Java already prevents a malicious String from being entered into the\nquery. Therefore, this method is not at risk for SQL injection, making\noption B incorrect.\nOn the other hand, the code is a risk of a resource leak that could be\nexploited in a denial of service attack. While the Connection object doesn't\nneed to be declared in the try‐with‐resources block, it should be declared\nright before it. In this case, there's a line in between,\ncon.createStatement(), that could throw an exception, thereby preventing\nthe Connection from ever being closed. For these reasons, option C is\ncorrect."
      }
    },
    "11": {
      "nbr": 11,
      "value": "Which statements about executing the following program are correct?\n(Choose two.)\nimport java.security.*;\nimport java.util.*;\npublic class MagicTrick {\nprivate static final String WORD = \"abracadabra\";\nprivate static List<String> trick = new ArrayList<>();\npublic static List<String> castSpell(String magic) {\nreturn AccessController.doPrivileged(\nnew PrivilegedAction<List<String>>() {\npublic List<String> run() {\nif (magic.equalsIgnoreCase(WORD)) { //\np1\nif(trick.isEmpty())\ntrick.add(System.getProperty(magic)); //\np2\nreturn trick; //\np3\n}\nthrow new SecurityException(\"Incorrect code\");\n}\n});\n}\npublic static void main(String[] args) {\nif(args != null && args.length>0)\nSystem.out.print(MagicTrick.castSpell(args[0]));\n} }",
      "responses": [{
        "code": "A",
        "value": "Line p1 makes the code susceptible to tainted inputs from the user."
      }, {
        "code": "B",
        "value": "Line p2 makes the code susceptible to tainted inputs from the user."
      }, {
        "code": "C",
        "value": "Line p3 makes the code susceptible to tainted inputs from the user."
      }, {
        "code": "D",
        "value": "The code is not susceptible to tainted inputs from the user."
      }, {
        "code": "E",
        "value": "Line p1 exposes sensitive information."
      }, {
        "code": "F",
        "value": "Line p2 exposes sensitive information."
      }, {
        "code": "G",
        "value": "Line p3 exposes sensitive information."
      }, {
        "code": "H",
        "value": "The code does not expose any sensitive information."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "G"
        ],
        "explanation": "11. B,G. Line p1 only partially validates the input from the user, since it\nperforms a case insensitive match. Therefore, the code executed on line p2\ncould be any variant of the magic word such as Abracadabra, aBraCadAbra,\nabracaDABRA, etc. In this manner, the user has access to many system\nproperties to read from on line p2, making option B correct. The code also\ndoes not protect its input because trick is returned to the user, who is free\nto modify the List. Instead, an immutable collection should be returned on\nline p3, making option G correct."
      }
    },
    "12": {
      "nbr": 12,
      "value": "How do you change the value of an instance variable in an immutable\nclass?",
      "responses": [{
        "code": "A",
        "value": "Call the setter method."
      }, {
        "code": "B",
        "value": "Remove the final modifier and set the instance variable directly."
      }, {
        "code": "C",
        "value": "Create a new instance with an inner class."
      }, {
        "code": "D",
        "value": "Use a method other than Option A, B, or C."
      }, {
        "code": "E",
        "value": "You can't."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "12. E. By definition, you cannot change the value of an instance variable in an\nimmutable class. There are no setter methods, making option A incorrect.\nWhile option B would allow you to set the value, the class would no longer\nbe immutable. Option C is incorrect because that would not modify the\noriginal instance. Option E is correct. If you are an advanced developer,\nyou might know that you can use reflection to change the value. Don't read\ninto questions like this on the exam. Reflection isn't on the exam, so you\ncan pretend it doesn't exist."
      }
    },
    "13": {
      "nbr": 13,
      "value": "Let's say you want to serialize the following class, but only want the flour\nquantity saved. What changes, if any, are required to the following class for\nthis to occur?\nimport java.io.*;\npublic class Muffin {\nprivate Double flour;\nprivate Integer eggs;\nprivate Float sugar;\nprivate final ObjectStreamField[] serialPersistentFields\n=\n{ new ObjectStreamField(\"flour\", Double.class) };\n}",
      "responses": [{
        "code": "A",
        "value": "No changes are required."
      }, {
        "code": "B",
        "value": "Mark eggs and sugar as transient."
      }, {
        "code": "C",
        "value": "Remove the serialPersistentFields variable."
      }, {
        "code": "D",
        "value": "Remove the final modifier from the serialPersistentFields\nvariable."
      }, {
        "code": "E",
        "value": "Add a missing modifier to the serialPersistentFields variable."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "13. F. The class is not marked Serializable, meaning none of the changes\nwill work and making option F correct. If it was corrected to implement\nSerializable, then it would serialize all of the fields, not just flour as\nwritten. This is because serialPersistentFields is declared without the\nstatic modifier. Alternatively, all of the other fields besides flour could\nbe marked transient to achieve the desired result."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Which are true about closing resources to guard against a denial of service\nattack? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "The NIO.2 Files.lines() method does not require closing a resource\nwhen it is used in a stream pipeline."
      }, {
        "code": "B",
        "value": "The NIO.2 Files.lines() method requires closing a resource when it\nis used in a stream pipeline."
      }, {
        "code": "C",
        "value": "When locking a resource using an instance of the concurrent Lock\ninterface, the unlock() statement should be immediately before the\nfinally block."
      }, {
        "code": "D",
        "value": "When locking a resource using an instance of the concurrent Lock\ninterface, the unlock() statement should be in a finally block."
      }, {
        "code": "E",
        "value": "When locking a resource using an instance of the concurrent Lock\ninterface, the unlock() statement should be immediately after the\nfinally block."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "14. B,D. Ensuring resources are released helps prevent a denial of service\nattack. Stream methods, such as Files.lines(), do not automatically close\nthe file. Option B is correct since the programmer needs to do it. Without\nthis, the system could run out of file resource handles as part of a denial of\nservice attack.\nWhen a resource is locked using an instance of the concurrent Lock\ninterface, it should be unlocked in a finally block to ensure this step is not\nmissed. Therefore, option D is the other correct answer. Without this, it's\npossible an acquired lock is kept indefinitely, and a deadlock ensues as part\nof a denial of service attack."
      }
    },
    "15": {
      "nbr": 15,
      "value": "Which type of attack requires more than one source to initiate?",
      "responses": [{
        "code": "A",
        "value": "Billion laughs attack"
      }, {
        "code": "B",
        "value": "Million frowns attack"
      }, {
        "code": "C",
        "value": "Distributed denial of service attack"
      }, {
        "code": "D",
        "value": "SQL injection"
      }, {
        "code": "E",
        "value": "Inclusion attack"
      }, {
        "code": "F",
        "value": "Denial of service attack"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "15. C. A distributed denial of service attack is a denial of service attack that\ncomes from multiple sources, making option C correct. There is no such\nthing as a million frowns attack. The rest of the answers are real attacks but\ncan be executed from a single source."
      }
    },
    "16": {
      "nbr": 16,
      "value": "What is this class an example of?\nimport java.util.*;\npublic class Nightclub {\nprivate List<String> approved = // IMPLEMENTATION\nOMITTED\nprivate List<String> rejected = // IMPLEMENTATION\nOMITTED\npublic boolean checkAccess(String name) {\nvar grantAccess = approved.contains(name)\n|| rejected.contains(name);\nreturn grantAccess;\n} }",
      "responses": [{
        "code": "A",
        "value": "Turquoiselist"
      }, {
        "code": "B",
        "value": "Whitelist"
      }, {
        "code": "C",
        "value": "Orangelist"
      }, {
        "code": "D",
        "value": "Blacklist"
      }, {
        "code": "E",
        "value": "Both blacklist and whitelist"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "16. B. The method only grants someone access if they appear in either the\napproved or rejected list. The combined data set forms a conceptual\nwhitelist, making option B correct. The variable names chosen were meant\nto be tricky. If the code was checked to block people from the rejected list\nas well, then it would be both a whitelist and blacklist implementation."
      }
    },
    "17": {
      "nbr": 17,
      "value": "Which statements about the clone() method are correct? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Calling clone() on a class that does not implement Cloneable results\nin a compiler error."
      }, {
        "code": "B",
        "value": "Calling clone() on a class that does not implement Cloneable results\nin an exception at runtime."
      }, {
        "code": "C",
        "value": "If a class implements Cloneable and does not override the clone()\nmethod, then the code does not compile."
      }, {
        "code": "D",
        "value": "If a class implements Cloneable and does not override the clone()\nmethod, then an exception is thrown at runtime."
      }, {
        "code": "E",
        "value": "Overriding the clone() method in a class that implements Cloneable\nguarantees at least a shallow copy will be performed."
      }, {
        "code": "F",
        "value": "Overriding the clone() method in a class that implements Cloneable\nmay result in a deep copy."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "17. B,F. The clone() method is inherited from the Object class. For this\nreason, it can be called on any Object without resulting in a compiler error,\nmaking options A and C incorrect. Option B is correct and defines the\ndefault behavior of clone() if the class does not implement Cloneable. On\nthe other hand, if a class implements Cloneable but does not override\nclone(), then Java will perform a shallow copy by default, making option\nD incorrect. Finally, if the class implements Cloneable and overrides\nclone(), then the behavior of the clone() method is entirely dependent on\nthe implementation. For this reason, option F is correct, and option E is\nincorrect."
      }
    },
    "18": {
      "nbr": 18,
      "value": "Which statements about securing confidential information are correct?\n(Choose three.)",
      "responses": [{
        "code": "A",
        "value": "When writing to System.out, you should not include sensitive\ninformation."
      }, {
        "code": "B",
        "value": "When reading sensitive data from a Console, you should use\nreadLine()."
      }, {
        "code": "C",
        "value": "When throwing an exception, it is acceptable to include sensitive\ninformation in the message."
      }, {
        "code": "D",
        "value": "A String is not a good object type for sensitive data."
      }, {
        "code": "E",
        "value": "A Java policy should only grant the permission lock to prevent a user\nfrom modifying the file."
      }, {
        "code": "F",
        "value": "A Java policy should only grant the permission read to prevent a user\nfrom modifying the file."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "F"
        ],
        "explanation": "18. A,D,F. Sensitive information should not be written to System.out,\nSystem.err, or a stack trace. For this reason, option A is correct, and option\nC is incorrect. It is preferable to use char[] instead of String for sensitive\ndata so that it does not enter the String pool and become available as part\nof a memory dump. For this reason, option D is correct, and option B is\nincorrect. Note that Console does have a readPassword() method that\nreturns char[]. Finally, the correct Java policy permission to prevent write\naccess is to only grant read access, making option F correct and option E\nincorrect."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What are the best scenarios for customizing the serialization process?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "To prevent SQL injection."
      }, {
        "code": "B",
        "value": "To shuffle data among users."
      }, {
        "code": "C",
        "value": "It is the only way to prevent a sensitive field like birthdate from being\nwritten to disk."
      }, {
        "code": "D",
        "value": "To improve performance by applying advanced optimization\ntechniques."
      }, {
        "code": "E",
        "value": "To encrypt a password before it is saved to disk."
      }, {
        "code": "F",
        "value": "To customize the handling of certain user sensitive data like a Social\nSecurity number."
      }
      ],
      "answer": {
        "codes": [
          "E",
          "F"
        ],
        "explanation": "19. E,F. Encrypting or customizing the handling of certain sensitive fields are\ngood reasons to customize the serialization process via methods, making\noptions E and F correct. Options A, B, and D are invalid and are not reasons\nto customize the process. Option C is incorrect as the transient modifier\nor serialPersistentFields can be used to exclude fields from\nserialization without the need to add any serialization methods."
      }
    },
    "20": {
      "nbr": 20,
      "value": "Select a good strategy for handling input validation failures?",
      "responses": [{
        "code": "A",
        "value": "Use the assert statement."
      }, {
        "code": "B",
        "value": "Throw an Error."
      }, {
        "code": "C",
        "value": "Log an error but allow the user to continue."
      }, {
        "code": "D",
        "value": "Throw an Exception."
      }, {
        "code": "E",
        "value": "Shut down the computer."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "20. D. A good solution when input validation fails is to stop processing a\nrequest and throw an Exception to the calling method to deal with the\nproblem, making option D correct. Options A and B are incorrect because\nthrowing Error should be avoided for situations where the application can\nrecover. Also, assertions are often disabled at runtime. Option C is incorrect\nas the user should not be allowed to continue if they have provided invalid\ninput. Finally, option E is incorrect for obvious reasons."
      }
    },
    "21": {
      "nbr": 21,
      "value": "Which statements about executing the following program are correct?\n(Choose two.)\nimport java.security.*;\npublic class PrintScores {\nprivate static final String CODE = \"12345\";\nprivate static final String SCORES = \"test.scores\";\npublic static String getScores(String accessCode) {\nreturn AccessController.doPrivileged(\nnew PrivilegedAction<String>() {\npublic String run() {\nif(accessCode.equals(CODE)) // m1\nreturn System.getProperty(SCORES); // m2\nthrow new SecurityException(\"Incorrect code\");\n}\n});\n}\npublic static void main(String[] args) {\nif(args != null && args.length>0)\nSystem.out.print(PrintScores.getScores(args[0]));\n} }",
      "responses": [{
        "code": "A",
        "value": "Line m1 makes the code susceptible to tainted inputs from the user."
      }, {
        "code": "B",
        "value": "Line m2 makes the code susceptible to tainted inputs from the user."
      }, {
        "code": "C",
        "value": "The code is not susceptible to tainted inputs from the user."
      }, {
        "code": "D",
        "value": "The code is susceptible to an injection attack."
      }, {
        "code": "E",
        "value": "The code is not susceptible to an injection attack."
      }, {
        "code": "F",
        "value": "The code is susceptible to an injection only if executed with a number\nas input."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "21. C,E. When invoking doPrivileged(), make sure there is no chance for a\nuser to pass their own, unprotected values into the request. Since a constant\nSCORES is used to read the system property on line m2, rather than user\nprovided input, the code is safe from tainted inputs from the user. The code\nvalidates its inputs enough that an injection attack is not possible, making\noption E correct."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Which can fill in the blank to make this code compile?\nimport java.io.*;\npublic class Pony implements Serializable {\nprivate static final ObjectStreamField[]\nserialPersistentFields = { new\nObjectStreamField(\"name\",\nString.class) };\nprivate String name;\nprivate Integer age;\nprivate void readObject(ObjectInputStream s)\nthrows Exception {\nObjectInputStream._________ fields = s.readFields();\nthis.name = (String) fields.get(\"name\", null);\n} }",
      "responses": [{
        "code": "A",
        "value": "GetObject"
      }, {
        "code": "B",
        "value": "ReadField"
      }, {
        "code": "C",
        "value": "FetchItem"
      }, {
        "code": "D",
        "value": "ReadItem"
      }, {
        "code": "E",
        "value": "GetField"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "22. E. The GetField class is used with the readObject() method, making\noption E correct. There is also a PutField class used with the\nwriteObject() method that you should be familiar with for the exam."
      }
    },
    "23": {
      "nbr": 23,
      "value": "Which statement about the following classes is correct?\nimport java.util.*;\npublic class Flower {\nprivate final String name;\nprivate final List<Integer> counts;\npublic Flower(String name, List<Integer> counts) {\nthis.name = name;\nthis.counts = new ArrayList<>(counts);\n}\npublic final String getName() { return name; }\npublic final List<Integer> getCounts() {\nreturn new ArrayList<>(counts);\n} }\nclass Plant {\nprivate final String name;\nprivate final List<Integer> counts;\npublic Plant(String name, List<Integer> counts) {\nthis.name = name;\nthis.counts = new ArrayList<>(counts);\n}\npublic String getName() { return name; }\npublic List<Integer> getCounts() {\nreturn new ArrayList<>(counts);\n} }",
      "responses": [{
        "code": "A",
        "value": "Only Flower is immutable."
      }, {
        "code": "B",
        "value": "Only Plant is immutable."
      }, {
        "code": "C",
        "value": "Both classes are immutable."
      }, {
        "code": "D",
        "value": "Neither class is immutable."
      }, {
        "code": "E",
        "value": "None of the above as one of the classes does not compile."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "23. A. An immutable class must not allow the state to change. The Flower\nclass does this correctly. While the class isn't final, the getters are, so\nsubclasses can't change the value returned. The Plant class lacks this\nprotection, which makes it mutable. Option A is correct."
      }
    },
    "24": {
      "nbr": 24,
      "value": "Which of the following can cause an injection attack? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Access control"
      }, {
        "code": "B",
        "value": "Command line input"
      }, {
        "code": "C",
        "value": "Constants in the program"
      }, {
        "code": "D",
        "value": "Mutable code"
      }, {
        "code": "E",
        "value": "Serialization"
      }, {
        "code": "F",
        "value": "XML parsing"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "24. B,F. Option A is incorrect because access control restricts who can do\nsomething rather than preventing an injection attack. Option B is correct\nbecause unsanitized input from the command line can do something\nundesirable like delete a file. Option C is incorrect because the programmer\ntyped those constants rather than a hostile party.\nOption D is incorrect because changing the values of an object is not an\ninjection attack. Option E is incorrect because serialization is writing data\nto disk rather than executing. Option F is correct because XML parsing can\nload hostile values into your program."
      }
    },
    "25": {
      "nbr": 25,
      "value": "Assuming this class is passed a valid non‐negative integer, which\nstatements best describe the following class? (Choose two.)\npublic class Charity {\nprivate int numberRequests = 0;\npublic synchronized int getNumberOfRequests() {\nreturn numberRequests;\n}\nprivate void callDatabaseToDonateADollar() {\n// IMPLEMENTATION OMITTED\n}\npublic synchronized void donateDollar(int numDollars) {\nnumberRequests++;\nfor(int i=0; i<numDollars; i++) {\ncallDatabaseToDonateADollar();\n}\n}\npublic static void main(String[] args) {\nfinal var humanFund = new Charity();\nhumanFund.donateDollar(Integer.valueOf(args[0]));\nSystem.out.print(humanFund.getNumberOfRequests());\n} }",
      "responses": [{
        "code": "A",
        "value": "It is well encapsulated."
      }, {
        "code": "B",
        "value": "It is susceptible to a denial of service attack."
      }, {
        "code": "C",
        "value": "It creates an immutable object."
      }, {
        "code": "D",
        "value": "It is susceptible to an inclusion attack."
      }, {
        "code": "E",
        "value": "It is not thread‐safe."
      }, {
        "code": "F",
        "value": "It is susceptible to an exploit attack."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B"
        ],
        "explanation": "25. A,B. The code is well encapsulated because all instance variables are\nprivate, making option A correct. It is susceptible to a denial of service\nattack since there is no input validation. For example, if the maximum\ninteger value of 2,147,483,647 is passed, then it will make a huge number\nof calls to the database, potentially tying up the system and blocking valid\nrequests. For this reason, option B is correct. To fix this code, a limit on the\ninputted value should be used. Option E is incorrect because the class is\nthread‐safe since the instance methods are all synchronized. The rest of the\noptions do not apply to this class."
      }
    },
    "26": {
      "nbr": 26,
      "value": "In which scenario is it appropriate for confidential information to be used?",
      "responses": [{
        "code": "A",
        "value": "Writing to a log file"
      }, {
        "code": "B",
        "value": "Printing a stack trace"
      }, {
        "code": "C",
        "value": "Outputting to System.err"
      }, {
        "code": "D",
        "value": "Storing in a String"
      }, {
        "code": "E",
        "value": "Writing an unsecure email"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "26. F. Confidential information includes things like credit card numbers and\npasswords. Options A, B, and C are incorrect because they expose\nconfidential information to the environment in which the application is\nrunning. Option D is incorrect because it allows the data to enter the String\npool, where it can get printed if a memory dump occurs. Option E is\nincorrect, as passwords should not be sent over email. For these reasons,\noption F is correct."
      }
    },
    "27": {
      "nbr": 27,
      "value": "What statements about the following method are correct? (Choose three.)\npublic String checkAlarm(String connectionStr, boolean\nalarmed)\nthrows SQLException {\nvar query = \"SELECT * FROM office WHERE alarmed = true\";\nvar con = DriverManager.getConnection(connectionStr);\nvar stmt = con.createStatement();\ntry (con;\nstmt;\nvar rs = stmt.executeQuery(query)) {\nreturn rs.next() ? rs.getString(\"address\") : null;\n} }",
      "responses": [{
        "code": "A",
        "value": "It protects against a denial of service attack."
      }, {
        "code": "B",
        "value": "It does not protect against denial of service attacks."
      }, {
        "code": "C",
        "value": "It protects against SQL injection."
      }, {
        "code": "D",
        "value": "It does not protect against SQL injection because it does not use a\nPreparedStatement."
      }, {
        "code": "E",
        "value": "Even if the method completes without throwing an exception, a\nresource leak might occur."
      }, {
        "code": "F",
        "value": "If the method completes without throwing an exception, then no\nresource leak can occur."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "F"
        ],
        "explanation": "27. B,C,F. While it is permitted to declare a resource outside a try‐withresources\nstatement and still have it be protected, declaring two is not\nrecommended. In particular, if con.createStatement() fails, then the\nConnection is not closed. For this reason, the code is susceptible to denial\nof service attacks, making option B correct.\nWhile it does not use a PreparedStatement, the code is safe from SQL\ninjection because the query does not take any parameters, making option C\ncorrect. Finally, if the method completes without throwing an exception,\nthen that means the try‐with‐resources block was successfully entered. In\nthis case, all resources would have been closed properly making option F\ncorrect."
      }
    },
    "28": {
      "nbr": 28,
      "value": "Which statement best describes this class?\nimport java.util.*;\npublic final class Ocean {\nprivate final List<String> algae;\nprivate final double wave;\nprivate int sun;\npublic Ocean(double wave) {\nthis.wave = wave;\nthis.algae = new ArrayList<>();\n}\npublic int getSun() {\nreturn sun;\n}\npublic void setSun(int sun) {\nsun = sun;\n}\npublic double getWave() {\nreturn wave;\n}\npublic List<String> getAlgae() {\nreturn new ArrayList<String>(algae);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "It can be serialized."
      }, {
        "code": "B",
        "value": "It is well encapsulated."
      }, {
        "code": "C",
        "value": "It is immutable."
      }, {
        "code": "D",
        "value": "It is both well encapsulated and immutable."
      }, {
        "code": "E",
        "value": "None of the above as the code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "28. D. This class does not implement Serializable, so option A is incorrect.\nThis code is well encapsulated because the instance variables are private.\nThe algae and wave variables are immutable because they are marked\nfinal, and there are no methods that can change them. The getAlgae()\nmethod creates a defensive copy, preventing direct access to the algae\nobject. Finally, the sun variable is initialized to 0 and is not able to be\nchanged after its creation. The setSun() method is missing a this\nreference, so the assignment sun = sun assigns the method parameter sun\nto itself. For these reasons, the class is immutable, and option D is correct."
      }
    },
    "29": {
      "nbr": 29,
      "value": "Which are true about this class? (Choose three.)\nimport java.io.*;\nimport java.util.*;\npublic final class Forest implements Serializable {\npublic final int flora;\npublic final List<String> fauna;\npublic Forest() {\nthis.flora = 5;\nthis.fauna = new ArrayList<>();\n}\npublic int getFlora() {\nreturn flora;\n}\npublic List<String> getFauna() {\nreturn new ArrayList<>(fauna);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "It is able to be serialized."
      }, {
        "code": "B",
        "value": "It is not able to be serialized."
      }, {
        "code": "C",
        "value": "It is well encapsulated."
      }, {
        "code": "D",
        "value": "It is not well encapsulated."
      }, {
        "code": "E",
        "value": "It is immutable."
      }, {
        "code": "F",
        "value": "It is not immutable."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "F"
        ],
        "explanation": "29. A,D,F. This class implements Serializable and contains serializable\ninstance variables making option A correct. This code is not well\nencapsulated because the instance variables are public, which matches\noption D. While a defensive copy of fauna is made in the getter, the\ninstance variable is public, and elements can be added or removed directly.\nTherefore, the object is not immutable, and option F is correct."
      }
    },
    "30": {
      "nbr": 30,
      "value": "You've been hired by Charlie Sweets to perform a security audit of their\nlogin system. After reviewing the following code, what recommendations\nwould best improve the security of their system? (Choose three.)\n1: public class CandyFactory {\n2: boolean check(String username, String password) {\n3: // IMPLEMENTATION OMITTED\n4: }\n5: public void login() {\n6: var c = System.console();\n7: if(c != null) {\n8: var username = c.readLine(\"Username: \");\n9: var password = c.readLine(\"Password: \");\n10: System.out.println(\"\n[\"+username+\",\"+password+\"]\");\n11: System.out.println(check(username,password)\n12: ? \"Here is your candy\"\n13: : \"No candy for you\");\n14: } } }",
      "responses": [{
        "code": "A",
        "value": "Mark the check() method final on line 2."
      }, {
        "code": "B",
        "value": "Remove the null check on line 7."
      }, {
        "code": "C",
        "value": "Rewrite to not use var on lines 6, 8, and 9, as it is inherently unsafe."
      }, {
        "code": "D",
        "value": "Rewrite to use readPassword() on line 8."
      }, {
        "code": "E",
        "value": "Rewrite to use readPassword() on line 9."
      }, {
        "code": "F",
        "value": "Change or remove line 10."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E",
          "F"
        ],
        "explanation": "30. A,E,F. A malicious attacker could extend this class and override the\nsecurity check() method, so marking it final is a good idea, making\noption A correct. Next, the Console class offers a readPassword() method\nthat does not echo what the user types and uses char[] instead of String to\navoid a password entering the String pool. For these reasons, option E is\ncorrect. Finally, line 10 prints the user's password to the System.out log\nfile, which is a terrible security idea. It should be changed or removed,\nmaking option F correct. The rest of the options are incorrect and do not\nimprove the security of this class."
      }
    },
    "31": {
      "nbr": 31,
      "value": "Fill in the blanks with the proper method names to serialize an object.\n(Choose two.)\nimport java.io.*;\npublic class DeliSandwich implements Serializable {\npublic Object __________() throws ObjectStreamException\n{\n// IMPLEMENTATION OMITTED\n}\nprivate void __________(ObjectOutputStream out)\nthrows IOException {\n// IMPLEMENTATION OMITTED\n}\n}",
      "responses": [{
        "code": "A",
        "value": "readResolve in the first blank"
      }, {
        "code": "B",
        "value": "writeReplace in the first blank"
      }, {
        "code": "C",
        "value": "writeObject in the first blank"
      }, {
        "code": "D",
        "value": "writeObject in the second blank"
      }, {
        "code": "E",
        "value": "readObject in the second blank"
      }, {
        "code": "F",
        "value": "writeReplace in the second blank"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "31. B,D. The read methods are used as part of deserialization, not\nserialization, making options A and E incorrect. Option B and D are correct\nbecause they use the correct method parameters and return types for\nwriteReplace() and writeObject()."
      }
    },
    "32": {
      "nbr": 32,
      "value": "Your co‐worker has called you in the middle of the night to report all the\nservers have been compromised and have run out of memory. After some\ndebugging, it seems like the attacker exploited a file upload resource, but\nyou aren't sure how since the endpoint has a small maximum file size limit.\nWhat is the most likely type of attack perpetrated against the system?",
      "responses": [{
        "code": "A",
        "value": "Denial of service attack"
      }, {
        "code": "B",
        "value": "Inclusion attack"
      }, {
        "code": "C",
        "value": "Distributed denial of service attack"
      }, {
        "code": "D",
        "value": "Exploit attack"
      }, {
        "code": "E",
        "value": "SQL injection"
      }, {
        "code": "F",
        "value": "Injection attack"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "32. B. An inclusion attack is one in which multiple components are embedded\nwithin a single file, such as zip bomb or XML exploit (billion laughs\nattack). Since the maximum file size is given to be small, this would be the\nmost likely type of attack used, making option B correct. Note that if the\nfile size was not limited, then this could be a regular denial of service attack\nin which a large file is sent repeatedly to overwhelm the system."
      }
    },
    "33": {
      "nbr": 33,
      "value": "Which statements about the following class are correct? (Choose three.)\nimport java.security.*;\nimport java.util.*;\npublic class UserProfile {\nprivate static class UserEntry {\nprivate final UserProfile value;\nprivate final Permission permission;\n// Constructors/Getters Omitted\n}\npublic static Permission getPermission(String check) {\n// Implementation Omitted\n}\nprivate static Map<String,UserEntry> data = new\nHashMap<>();\npublic static UserProfile getProfile(String check) {\nvar securityRecord = data.get(check);\nif (securityRecord != null)\nreturn securityRecord.getValue(); //\nh1\nvar permission = getPermission(check);\nvar permCol = permission.newPermissionCollection();\npermCol.add(permission);\nvar prof = AccessController.doPrivileged( //\nh2\nnew PrivilegedAction<UserProfile>() {\npublic UserProfile run() {\nreturn new UserProfile();\n}},\nnew AccessControlContext(\nnew ProtectionDomain[] {\nnew ProtectionDomain(null, permCol)\n}));\ndata.put(check, new UserEntry(prof, permission)); //\nh3\nreturn prof;\n} }",
      "responses": [{
        "code": "A",
        "value": "Line h1 properly validates security."
      }, {
        "code": "B",
        "value": "Line h1 presents an unacceptable security risk."
      }, {
        "code": "C",
        "value": "Line h2 elevates security privileges."
      }, {
        "code": "D",
        "value": "Line h2 does not elevate security privileges."
      }, {
        "code": "E",
        "value": "Line h3 violates security guidelines by allowing security information\nto be cached."
      }, {
        "code": "F",
        "value": "Line h3 does not violate security guidelines."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "F"
        ],
        "explanation": "33. B,C,F. Caching permissions for a user is allowed, so option F is correct.\nThat said, the security on using the cached data must be checked. The class\nis missing calls to AccessController.checkPermission() before lines h1\nand h2. On line h1, this can result in a user reading a cached permission\nthey do not have access to, making option B correct. On line h2, security\npermissions could be elevated since access is not checked, making option C\ncorrect."
      }
    },
    "34": {
      "nbr": 34,
      "value": "For which value of name will this code result in a successful SQL injection\nattack?\npublic Integer getScore(String connectionStr, String name)\nthrows SQLException {\nvar query = \"SELECT score FROM records WHERE name = ?\";\nvar con = DriverManager.getConnection(connectionStr);\ntry (con; var stmt = con.prepareStatement(query)) {\nstmt.setString(1, name);\ntry(var rs = stmt.executeQuery()) {\nif(rs.next()) return rs.getInt(\"score\");\n}\n}\nreturn null;\n}",
      "responses": [{
        "code": "A",
        "value": "DELETE TABLE records;"
      }, {
        "code": "B",
        "value": "'Olivia'; DELETE TABLE records"
      }, {
        "code": "C",
        "value": "'Sophia; DELETE TABLE records"
      }, {
        "code": "D",
        "value": "'Elysia'; DELETE TABLE records"
      }, {
        "code": "E",
        "value": "?; DELETE TABLE records;"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "34. F. The query uses a PreparedStatement so that the name is properly\nescaped. For this reason, SQL injection is not possible, and option F is\ncorrect. For the exam, you don't need to know how to write a query to cause\nSQL injection, just how to prevent it."
      }
    },
    "35": {
      "nbr": 35,
      "value": "Which are requirements for a class to be immutable? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "A private constructor is provided."
      }, {
        "code": "B",
        "value": "Any instance variables are private."
      }, {
        "code": "C",
        "value": "Any instance variables are initialized in a constructor."
      }, {
        "code": "D",
        "value": "Methods cannot be overridden."
      }, {
        "code": "E",
        "value": "There are no setter methods."
      }, {
        "code": "F",
        "value": "Any instance variables are marked final."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "E"
        ],
        "explanation": "35. B,D,E. An immutable class can have public constructors, so option A is\nincorrect. Options B, D, and E make up the requirements for an immutable\nclass. Option D can be fulfilled by making the class final or marking the\nmethods final. Option C is incorrect because instance variables can still be\ndeclared with a value or set by an instance initializer. Option F is also\nincorrect. While it is common to mark instance variables final, as long as\nthere is no way for them to be changed after the constructor is executed, the\nclass can still be considered immutable."
      }
    },
    "36": {
      "nbr": 36,
      "value": "Which of the following are not typically considered denial of service\nattacks? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Downloading confidential information from a log file"
      }, {
        "code": "B",
        "value": "Uploading a very large file"
      }, {
        "code": "C",
        "value": "Performing SQL injection"
      }, {
        "code": "D",
        "value": "Passing invalid numbers to trigger overflow or underflow"
      }, {
        "code": "E",
        "value": "Exploiting a database resource leak"
      }, {
        "code": "F",
        "value": "Uploading a zip bomb"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "36. A,C. A denial of service attack is one in which one or more requests\nattempt to overwhelm the system and disrupt legitimate requests. Option A\nis an access or confidentiality problem. Option C is about gaining access or\nchanging data that the user should not be permitted to. Options B, D, E, and\nF are all denial of service attacks because they increase load in an attempt\nto bring a system down. Remember, a zip bomb is when a small file is\nexpanded to become a much larger file."
      }
    },
    "37": {
      "nbr": 37,
      "value": "The following code prints false. Which statements best describe the Fruit\nclass? (Choose three.)\nvar original = new Fruit();\noriginal.sweet = new ArrayList<>();\nvar cloned = (Fruit) original.clone();\nSystem.out.print(original.sweet == cloned.sweet);",
      "responses": [{
        "code": "A",
        "value": "It does not implement Cloneable."
      }, {
        "code": "B",
        "value": "It performs a deep copy."
      }, {
        "code": "C",
        "value": "It performs a shallow copy."
      }, {
        "code": "D",
        "value": "It overrides clone()."
      }, {
        "code": "E",
        "value": "It implements Cloneable."
      }, {
        "code": "F",
        "value": "It does not override clone()."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "E"
        ],
        "explanation": "37. B,D,E. The Fruit class must implement Cloneable; otherwise, an\nexception would be thrown at runtime, making option E correct. The Fruit\nclass must also override the clone() method. If it did not, then a shallow\ncopy would be performed on the sweet object, resulting in the code printing\ntrue at runtime. Since this is not the case, option D is correct. Finally,\nwe've already ruled out a shallow copy, so by process of elimination it must\nperform a deep copy. For this reason, option B is correct."
      }
    },
    "38": {
      "nbr": 38,
      "value": "What are the best ways to prevent SQL injection? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Avoid SQL statements that take query parameters."
      }, {
        "code": "B",
        "value": "Log an error anytime a SQL injection attack is successful."
      }, {
        "code": "C",
        "value": "Avoid concatenating user input into a query string."
      }, {
        "code": "D",
        "value": "Ensure database resources are closed."
      }, {
        "code": "E",
        "value": "Always use a PreparedStatement instead of a Statement."
      }, {
        "code": "F",
        "value": "Do not use a relational database."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "38. C,E. The primary way SQL injection occurs is from concatenating SQL\nqueries without properly escaping the values. Avoiding concatenation and\nusing a PreparedStatement with bind variables are the commonly accepted\nways to prevent this. For these reasons, options C and E are correct.\nOption A is incorrect because a database that takes no query parameters of\nany kind would be pretty limited in its capabilities. For example, it would\nbe challenging to log a user in if you couldn't search for that user. Option B\nis also incorrect, as you can't prevent a SQL injection after it is already\nsuccessful. Option D is incorrect, as a resource leak is more susceptible to a\ndenial of service attack in which resources are exploited, rather than SQL\ninjection in which data is manipulated. Finally, option F is incorrect, as\navoiding using a relational database is not a commonly accepted practice\nfor avoiding SQL injection."
      }
    },
    "39": {
      "nbr": 39,
      "value": "Given the following two classes, what change to the StealSecret class\nwould allow it to read and email the password to a hacker?\npublic class Secret {\nprivate String mySecret;\npublic void setSecret(String secret) {\nmySecret = secret;\n}\npublic void printSecret() {\nthrow new UnsupportedOperationException(\"Nope!\");\n}\nprivate void saveToDisk() {\n// IMPLEMENTATION OMITTED\n}\n}\npublic class StealSecret extends Secret {\n// DO BAD STUFF\n}",
      "responses": [{
        "code": "A",
        "value": "There are no changes, as the Secret class is secure."
      }, {
        "code": "B",
        "value": "Override the mySecret variable."
      }, {
        "code": "C",
        "value": "Override the setSecret() method."
      }, {
        "code": "D",
        "value": "Override the printSecret() method."
      }, {
        "code": "E",
        "value": "Override the saveToDisk() method."
      }, {
        "code": "F",
        "value": "Add a constructor."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "39. C. Option C is the correct answer. A hacker could override the\nsetSecret() method to first steal the inputted secret value and email it\nherself and then pass the data along to the parent by calling\nsuper.setSecret() without anyone noticing any difference. One fix would\nbe to mark this method final in the Secret class or make the Secret class\nfinal.\nOption B is incorrect because variables can only be hidden, not overridden,\nso declaring a new mySecret variable would not grant access to the parent\nvariable. Option D is incorrect as overriding this method won't allow the\nattacker to access the mySecret variable directly. Option E is trivially\nincorrect, as private methods cannot be overridden. Finally, option F is\nincorrect as adding a constructor does not grant access to private members\nin the parent class."
      }
    },
    "40": {
      "nbr": 40,
      "value": "Which statement about the following classes is correct?\nimport java.util.*;\nfinal class Faucet {\nprivate final String water;\nprivate final List<Double> pipes;\npublic Faucet(String water, List<Double> pipes) {\nthis.water = water;\nthis.pipes = pipes;\n}\npublic String getWater() { return water; }\npublic List<Double> getPipes() { return pipes; } }\npublic final class Spout {\nprivate final String well;\nprivate final List<Boolean> buckets;\npublic Spout(String well, List<Boolean> buckets) {\nthis.well = well;\nthis.buckets = new ArrayList<>(buckets);\n}\npublic String getWell() { return well; }\npublic List<Boolean> getBuckets() {\nreturn new ArrayList<>(buckets);\n} }",
      "responses": [{
        "code": "A",
        "value": "Only Faucet is immutable."
      }, {
        "code": "B",
        "value": "Only Spout is immutable."
      }, {
        "code": "C",
        "value": "Both classes are immutable."
      }, {
        "code": "D",
        "value": "Neither class is immutable."
      }, {
        "code": "E",
        "value": "None of the above as one of the classes does not compile."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "40. B. An immutable class must not allow the state to change. In the Faucet\nclass, the caller has a reference to the List being passed in and can change\nthe size or elements in it. Similarly, any class with a reference to the object\ncan get the List by calling get() and make these changes. The Faucet\nclass is not immutable. The Spout class shows how to fix these problems\nand is immutable, making option B correct."
      }
    }
  }
}, {
  "name": "Database Applications with JDBC",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "How many of Connection, Driver, DriverManager, PreparedStatement,\nand ResultSet are JDBC interfaces included with the JDK?",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "1. E. Connection is a JDK interface for communicating with the database.\nPreparedStatement and ResultSet are typically used to write queries and\nare also in the JDK. Driver is tricky because you don't write code that\nreferences it directly. However, you are still required to know it is a JDBC\ninterface. DriverManager is used in JDBC code to get a Connection.\nHowever, it is a concrete class rather than an interface. Since only four out\nof the five are JDBC interfaces, option E is correct."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Which is found in the java.sql package that come with the standard JDK?",
      "responses": [{
        "code": "A",
        "value": "Only DerbyDriver"
      }, {
        "code": "B",
        "value": "Only MySqlDriver"
      }, {
        "code": "C",
        "value": "Only OracleDriver"
      }, {
        "code": "D",
        "value": "DerbyDriver, MySqlDriver, OracleDriver"
      }, {
        "code": "E",
        "value": "Only DerbyDriver and MySqlDriver"
      }, {
        "code": "F",
        "value": "None of these"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "2. F. Database‐specific implementation classes are not in the java.sql\npackage. The implementation classes are in database drivers and have\npackage names that are specific to the database. Therefore, option F is\ncorrect. The Driver interface is in the java.sql package. Note that these\nclasses may or may not exist. You are not required to know the names of\nany database‐specific classes, so the creators of the exam are free to make\nup names."
      }
    },
    "3": {
      "nbr": 3,
      "value": "What must be the first characters of a database URL?",
      "responses": [{
        "code": "A",
        "value": "db,"
      }, {
        "code": "B",
        "value": "db:"
      }, {
        "code": "C",
        "value": "jdbc,"
      }, {
        "code": "D",
        "value": "jdbc:"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "3. D. All JDBC URLs begin with the protocol jdbc followed by a colon as a\ndelimiter. Option D is the only one that does both of these, making it the\ncorrect answer."
      }
    },
    "4": {
      "nbr": 4,
      "value": "Which is responsible for getting a connection to the database?",
      "responses": [{
        "code": "A",
        "value": "Driver"
      }, {
        "code": "B",
        "value": "Connection"
      }, {
        "code": "C",
        "value": "PreparedStatement"
      }, {
        "code": "D",
        "value": "Statement"
      }, {
        "code": "E",
        "value": "ResultSet"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "4. A. The Driver interface is responsible for getting a connection to the\ndatabase, making option A the answer. The Connection interface is\nresponsible for communication with the database but not making the initial\nconnection. The Statement interface knows how to run the SQL query, and\nthe ResultSet interface knows what was returned by a SELECT query."
      }
    },
    "5": {
      "nbr": 5,
      "value": "Which of these obtains a Connection?",
      "responses": [{
        "code": "A",
        "value": "Connection.getConnection(url)"
      }, {
        "code": "B",
        "value": "Driver.getConnection(url)"
      }, {
        "code": "C",
        "value": "DriverManager.getConnection(url)"
      }, {
        "code": "D",
        "value": "new Connection(url)"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "5. C. Connection is an interface. Since interfaces do not have constructors,\noption D is incorrect.The Connection class doesn't have a static method\nto get a Connection either, making option A incorrect. The Driver class is\nalso an interface without static methods, making option B incorrect.\nOption C is the answer because DriverManager is the class used in JDBC to\nget a Connection."
      }
    },
    "6": {
      "nbr": 6,
      "value": "Which method in DriverManager is overloaded to allow passing a\nusername and password?",
      "responses": [{
        "code": "A",
        "value": "conn()"
      }, {
        "code": "B",
        "value": "connect()"
      }, {
        "code": "C",
        "value": "forName()"
      }, {
        "code": "D",
        "value": "getStatement()"
      }, {
        "code": "E",
        "value": "open()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "6. F. The DriverManager.getConnection() method can be called with just a\nURL. It is also overloaded to take the URL, username, and password. Since\nthis is not one of the options, the answer is option F."
      }
    },
    "7": {
      "nbr": 7,
      "value": "What is the output if the clowns database exists and contains an empty\nclowns table?\nvar url = \"jdbc:derby:clowns;create=true\";\nvar sql = \"SELECT count(*) FROM clowns\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.prepareStatement(sql);\nvar rs = stmt.executeQuery()) {\nSystem.out.println(rs.getInt(1));\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "7. D. This code is missing a call to rs.next(). As a result, rs.getInt(1)\nthrows a SQLException with the message Invalid cursor state – no\ncurrent row. Therefore, option D is the answer."
      }
    },
    "8": {
      "nbr": 8,
      "value": "Consider the three methods execute(), executeQuery(), and\nexecuteUpdate(). Fill in the blanks: _______ of these methods is/are\nallowed to run a DELETE SQL statement while ________ of these methods\nis/are allowed to run an UPDATE SQL statement.",
      "responses": [{
        "code": "A",
        "value": "None, one"
      }, {
        "code": "B",
        "value": "One, none"
      }, {
        "code": "C",
        "value": "One, one"
      }, {
        "code": "D",
        "value": "One, two"
      }, {
        "code": "E",
        "value": "Two, two"
      }, {
        "code": "F",
        "value": "Three, three"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "8. E. The execute() method is allowed to run any type of SQL statements.\nThe executeUpdate() method is allowed to run any type of the SQL\nstatement that returns a row count rather than a ResultSet. Both DELETE\nand UPDATE SQL statements are allowed to be run with either execute() or\nexecuteUpdate(). They are not allowed to be run with executeQuery()\nbecause they do not return a ResultSet. Therefore, option E is the answer."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Suppose the pandas table has one row with the name Mei Xiang and the\nlocation DC. What does the following code output?\nvar url = \"jdbc:derby:pandas\";\nvar sql = \"SELECT name FROM pandas WHERE location = 'DC'\";\ntry (var conn = DriverManager.getConnection(url); // s1\nvar stmt = conn.prepareStatement(sql); // s2\nvar rs = stmt.executeQuery()) {\nif (rs.next())\nSystem.out.println(rs.getString(\"name\"));\nelse\nSystem.out.println(\"No match\");\n}",
      "responses": [{
        "code": "A",
        "value": "Mei Xiang"
      }, {
        "code": "B",
        "value": "No match"
      }, {
        "code": "C",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "E",
        "value": "The code does not compile due to another line."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "9. A. This code uses a PreparedStatement without bind variables (?). While\nit would be better to use bind variables, this code does run. The ResultSet\nhas one value and does print Mei Xiang successfully. Therefore, option A is\nthe answer."
      }
    },
    "10": {
      "nbr": 10,
      "value": "Suppose we have a peacocks table with two columns: name and rating.\nWhat does the following code output if the table is empty?\nvar url = \"jdbc:derby:birds\";\nvar sql = \"SELECT name FROM peacocks WHERE name = ?\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.prepareStatement(sql)) { // s1\nstmt.setString(1, \"Feathers\");\nstmt.setString(2, \"Nice\");\nboolean result = stmt.execute(); // s2\nSystem.out.println(result);\n}",
      "responses": [{
        "code": "A",
        "value": "false"
      }, {
        "code": "B",
        "value": "true"
      }, {
        "code": "C",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "E",
        "value": "The code does not compile due to another line."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "10. F. While the table has two columns, the SQL query has only one bind\nvariable (?). Therefore, the code throws an exception when attempting to\nset the second bind variable, and option F is correct."
      }
    },
    "11": {
      "nbr": 11,
      "value": "Suppose we have an empty bunny table with two columns: name and color.\nWhat is the state of the table after running this code?\nvar url = \"jdbc:derby:bunnies\";\nvar sql = \"INSERT INTO bunny(name, color) VALUES (?, ?)\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.prepareStatement(sql)) { // s1\nstmt.setString(1, \"Daisy\");\nstmt.setString(2, \"Brown\");\nstmt.executeUpdate();\nstmt.setString(1, \"Cinna\");\nstmt.setString(2, \"Brown\");\nstmt.executeUpdate();\n}",
      "responses": [{
        "code": "A",
        "value": "It has one row."
      }, {
        "code": "B",
        "value": "It has two rows, and the color is Brown in both."
      }, {
        "code": "C",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "E",
        "value": "The code does not compile due to another line."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "11. B. This code is correct. It executes the first update to add the first row and\nthen sets the parameters for the second. When it updates the second time, it\nadds the second row. Therefore, option B is the answer."
      }
    },
    "12": {
      "nbr": 12,
      "value": "What is the name of a concrete class that implements Statement and is\nincluded in the core JDK?",
      "responses": [{
        "code": "A",
        "value": "CallableStatement"
      }, {
        "code": "B",
        "value": "PreparedStatement"
      }, {
        "code": "C",
        "value": "StatementImpl"
      }, {
        "code": "D",
        "value": "Both A and B"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "12. E. CallableStatement and PreparedStatement are interfaces that extend\nthe Statement interface. You don't need to know that for the exam. You do\nneed to know that a database driver is required to provide the concrete\nimplementation class of Statement rather than the JDK. This makes option\nE correct."
      }
    },
    "13": {
      "nbr": 13,
      "value": "Given the table books in the figure and a ResultSet created by running the\nfollowing SQL statement, which option prints the value 379?\nSELECT * FROM books WHERE title = 'Beginning Java'",
      "responses": [{
        "code": "A",
        "value": "System.out.println(rs.getInt(1));"
      }, {
        "code": "B",
        "value": "System.out.println(rs.getInt(2));"
      }, {
        "code": "C",
        "value": "System.out.println(rs.getInteger(1));"
      }, {
        "code": "D",
        "value": "System.out.println(rs.getInteger(2));"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "13. B. Unlike arrays, JDBC uses one‐based indexes. Since num_pages is in the\nsecond column, the parameter needs to be 2, ruling out options A and C.\nFurther, there is not a method named getInteger() on the ResultSet\ninterface, ruling out option D. Since the proper method is getInt(), option\nB is the answer."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Given the table books in the previous question and the following code,\nwhich lines would you add to successfully insert a row? (Choose two.)\nvar url = \"jdbc:derby:books;create=true\";\nvar sql = \"INSERT INTO books (title,num_pages)\nVALUES(?,?)\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.prepareStatement(sql)) {\n// INSERT CODE HERE\nstmt.executeUpdate();\n}",
      "responses": [{
        "code": "A",
        "value": "stmt.setObject(0, \"Intermediate Java\");"
      }, {
        "code": "B",
        "value": "stmt.setObject(1, \"Intermediate Java\");"
      }, {
        "code": "C",
        "value": "stmt.setObject(1, 500);"
      }, {
        "code": "D",
        "value": "stmt.setObject(2, 500);"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "14. B,D. Since JDBC does not begin indexes with zero, option A is incorrect,\nand option B is correct. Similarly, the second parameter is at index 2, so\noption C is incorrect, and option D is the other answer. Note that\nsetObject() can be called instead of a more specific type."
      }
    },
    "15": {
      "nbr": 15,
      "value": "Given the table books from the previous two questions and a ResultSet\ncreated by running this SQL statement, which option prints Advanced\nJava?\nSELECT title FROM books WHERE num_pages> 500",
      "responses": [{
        "code": "A",
        "value": "System.out.println(rs.getString());"
      }, {
        "code": "B",
        "value": "System.out.println(rs.getString(\"0\"));"
      }, {
        "code": "C",
        "value": "System.out.println(rs.getString(\"1\"));"
      }, {
        "code": "D",
        "value": "System.out.println(rs.getString(\"title\"));"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "15. D. Option A does not compile because you have to pass a column index or\ncolumn name to the method. Options B and C compile. However, there are\nnot columns named 0 or 1. Since these column names don't exist, the code\nwould throw a SQLException at runtime. Option D is correct as it uses the\nproper column name."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Which of the following could be valid JDBC URL formats for an imaginary\ndriver named magic and a database named box?\nString first = \"jdbc:magic:127.0.0.1:1234/box\";\nString second = \"jdbc:magic:box\";\nString third = \"jdbc@magic:@127.0.0.1:1234\";",
      "responses": [{
        "code": "A",
        "value": "Only first"
      }, {
        "code": "B",
        "value": "Only second"
      }, {
        "code": "C",
        "value": "Only third"
      }, {
        "code": "D",
        "value": "Both first and second"
      }, {
        "code": "E",
        "value": "Both first and third"
      }, {
        "code": "F",
        "value": "All of these"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "16. D. A JDBC URL has three components separated by colons. All three of\nthese URLs meet those criteria. For the data after the component, the\ndatabase driver specifies the format. Depending on the driver, this might\ninclude an IP address and port. Regardless, it needs to include the database\nname or alias. The first and second URLs could both be valid formats\nbecause they mention the database box. However, third is incorrect\nbecause it has jdbc@ instead of jdbc:. Therefore, option D correct."
      }
    },
    "17": {
      "nbr": 17,
      "value": "Which is a benefit of PreparedStatement over Statement? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Language independence"
      }, {
        "code": "B",
        "value": "NoSQL support"
      }, {
        "code": "C",
        "value": "Readability"
      }, {
        "code": "D",
        "value": "Security"
      }, {
        "code": "E",
        "value": "Supports stored procedures"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "17. C,D. JDBC uses Java and SQL, so it is not language independent, making\noption A incorrect. It is used with relational databases, ruling out option B.\nA CallableStatement supports stored procedures, not a\nPreparedStatement, making option E incorrect.\nOptions C and D are correct. Using bind variables with a\nPreparedStatement produces code that is easier to read than one with a lot\nof String concatenation. Further, when used properly, a\nPreparedStatement prevents SQL injection."
      }
    },
    "18": {
      "nbr": 18,
      "value": "Assuming the clowns database exists and contains one empty table named\nclowns, what is the output of the following?\nvar url = \"jdbc:derby:clowns\";\nvar sql = \"SELECT * FROM clowns\";\ntry (var conn = new Connection(url); // s1\nvar stmt = conn.prepareStatement(sql); // s2\nvar rs = stmt.executeQuery()) { // s3\nif (rs.next())\nSystem.out.println(rs.getString(1));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code terminates successfully without any output."
      }, {
        "code": "B",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "C",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s3."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "18. B. Connection is an interface rather than a concrete class. Therefore, it\ndoes not have a constructor and line s1 does not compile. As a result, option\nB is the answer. Option A would be the answer if the code new\nConnection() was changed to DriverManager.getConnection()."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What is the correct order to close database resources?",
      "responses": [{
        "code": "A",
        "value": "Connection then PreparedStatement then ResultSet"
      }, {
        "code": "B",
        "value": "Connection then ResultSet then PreparedStatement"
      }, {
        "code": "C",
        "value": "PreparedStatement then Connection then ResultSet"
      }, {
        "code": "D",
        "value": "PreparedStatement then ResultSet then Connection"
      }, {
        "code": "E",
        "value": "ResultSet then PreparedStatement then Connection"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "19. E. When manually closing database resources, they should be closed in the\nreverse order from which they were opened. This means the ResultSet\nobject is closed before the Statement object and the Statement object is\nclosed before the Connection object. This makes option E the answer."
      }
    },
    "20": {
      "nbr": 20,
      "value": "Assuming the clowns database exists and contains one empty table named\nclowns, what is the output of the following?\nvar url = \"jdbc:derby:clowns\";\nvar sql = \"SELECT * FROM clowns\";\ntry (var conn = DriverManager.getConnection(url); // s1\nvar stmt = conn.prepareStatement(sql); // s2\nvar rs = stmt.executeQuery()) { // s3\nif (rs.next())\nSystem.out.println(rs.getString(1));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code terminates successfully without any output."
      }, {
        "code": "B",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "C",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s3."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "20. A. This code correctly obtains a Connection and PreparedStatement. It\nthen runs a query, getting back a ResultSet without any rows. The\nrs.next() call returns false, so nothing is printed, making option A\ncorrect."
      }
    },
    "21": {
      "nbr": 21,
      "value": "Suppose we have a bunny table with two columns: name and color. What\ndoes the following code output if the table is empty?\nvar url = \"jdbc:derby:bunnies\";\nvar sql =\n\"SELECT count(*) FROM bunny WHERE color = ? and name =\n?\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.prepareStatement(sql)) { // s1\nstmt.setString(1, \"White\");\ntry (var rs = stmt.executeQuery()) { // s2\nif (rs.next())\nSystem.out.println(rs.getInt(1));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "E",
        "value": "The code does not compile due to another line."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "21. F. The SQL query has two bind variables, but the code sets only one. This\ncauses a SQLException when executeQuery() is called, making option F\nthe answer."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Suppose the pandas table has one row with the name Mei Xiang and the\nlocation DC. What does the following code output?\nvar url = \"jdbc:derby:pandas\";\nvar sql = \"SELECT name FROM pandas WHERE location = ?\";\ntry (var conn = DriverManager.getConnection(url); // s1\nvar stmt = conn.prepareStatement(sql)) { // s2\nstmt.setString(1, \"DC\");\ntry (var rs = stmt.executeQuery()) {\nif (rs.next())\nSystem.out.println(rs.getString(\"name\"));\nelse\nSystem.out.println(\"No match\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Mei Xiang"
      }, {
        "code": "B",
        "value": "No match"
      }, {
        "code": "C",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "E",
        "value": "The code does not compile due to another line."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "22. A. This code uses a PreparedStatement and properly sets a bind variable\n(?). The ResultSet has one value and does print Mei Xiang successfully.\nTherefore, option A is the answer."
      }
    },
    "23": {
      "nbr": 23,
      "value": "Which statement is true about the JDBC core classes?",
      "responses": [{
        "code": "A",
        "value": "Driver is an implementation of DriverManager."
      }, {
        "code": "B",
        "value": "A general Connection implementation is included in the JDK."
      }, {
        "code": "C",
        "value": "A PreparedStatement uses bind variables."
      }, {
        "code": "D",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "23. C. Option A is incorrect because Driver is an interface, while\nDriverManager is a concrete class. The inverse isn't true either;\nDriverManager doesn't implement Driver. Option B is incorrect because\nthe Connection implementation comes from a specific database driver JAR.\nOption C is correct as bind variables (?) are used."
      }
    },
    "24": {
      "nbr": 24,
      "value": "Which is true if the clowns database exists and contains an empty clowns\ntable?\nvar url = \"jdbc:derby:clowns\";\nvar sql = \"SELECT COUNT(*) FROM clowns\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.prepareStatement(sql);\nvar rs = stmt.executeQuery()) {\nrs.next(); // r1\nSystem.out.println(rs.getInt(1)); // r2\n}",
      "responses": [{
        "code": "A",
        "value": "The code compiles and prints 0 without error."
      }, {
        "code": "B",
        "value": "The code compiles and prints 1 without error."
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime on line r1."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime on line r2."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "24. A. The count(*) function in SQL always returns a number. In this case, it\nis the number zero. This means line r1 executes successfully because it\npositions the cursor at that row. Line r2 also executes successfully and\nprints 0, which is the value in the row. Since the code runs successfully,\noption A is the answer."
      }
    },
    "25": {
      "nbr": 25,
      "value": "Suppose we have an empty bunny table with two columns: name and color.\nWhat is the state of the table after running this code?\nvar url = \"jdbc:derby:bunnies\";\nvar sql = \"INSERT INTO bunny(name, color) VALUES (?, ?)\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.prepareStatement(sql)) { // s1\nstmt.setString(1, \"Hoppy\");\nstmt.setString(2, \"Brown\");\nstmt.executeUpdate();\nstmt.setString(1, \"Daisy\");\nstmt.executeUpdate();\n}",
      "responses": [{
        "code": "A",
        "value": "Only one row has the color Brown set."
      }, {
        "code": "B",
        "value": "It has two rows, and the color is Brown in both."
      }, {
        "code": "C",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "E",
        "value": "The code does not compile due to another line."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "25. B. This code is correct. It executes the first update to add the first row and\nthen sets the parameters for the second. For the second update, only one\nparameter is set. The other is reused since it was set earlier. Therefore,\noption B is the answer."
      }
    },
    "26": {
      "nbr": 26,
      "value": "Which are true statements? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "A PreparedStatement is generally faster than a Statement when each\nis run 100 times."
      }, {
        "code": "B",
        "value": "A PreparedStatement is generally slower than a Statement when\neach is run 100 times."
      }, {
        "code": "C",
        "value": "A PreparedStatement is generally the same speed as a Statement\nwhen each is run 100 times."
      }, {
        "code": "D",
        "value": "PreparedStatement extends Statement"
      }, {
        "code": "E",
        "value": "Statement extends PreparedStatement"
      }, {
        "code": "F",
        "value": "PreparedStatement and Statement are not in the same inheritance\nhierarchy."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D"
        ],
        "explanation": "26. A,D. The PreparedStatement interface extends the Statement interface,\nwhich matches option D. One of the benefits of a PreparedStatement is\nperformance. While a PreparedStatement may not be faster if run only\nonce, it will quickly become so. Therefore, option A is the other correct\nanswer."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Which is true of a PreparedStatement?",
      "responses": [{
        "code": "A",
        "value": "It has a method to change the bind variable to a different character\nother than ?."
      }, {
        "code": "B",
        "value": "It can be used only for SELECT statements."
      }, {
        "code": "C",
        "value": "It can be used only for UPDATE statements."
      }, {
        "code": "D",
        "value": "All of these are true."
      }, {
        "code": "E",
        "value": "None of these are true."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "27. E. In JDBC, the bind variable is always a question mark (?), making\noption A incorrect. A PreparedStatatement is not limited to specific types\nof SQL, making options B and C incorrect as well. This makes option E the\ncorrect answer."
      }
    },
    "28": {
      "nbr": 28,
      "value": "Suppose we have a peacocks table with two columns: name and rating.\nWhat does the following code output if the table is empty?\nvar url = \"jdbc:derby:birds\";\nvar sql = \"SELECT name FROM peacocks WHERE name = ?\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.prepareStatement(sql)) { // s1\nstmt.setString(1, \"Feathers\");\nSystem.out.println(stmt.executeUpdate()); // s2\n}",
      "responses": [{
        "code": "A",
        "value": "false"
      }, {
        "code": "B",
        "value": "true"
      }, {
        "code": "C",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "E",
        "value": "The code does not compile due to another line."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "28. F. While this code compiles, it isn't right. Since we have a SELECT\nstatement, we should be calling execute() or executeQuery(). Option F is\nthe answer because the code throws an exception when attempting to call\nexecuteUpdate()."
      }
    },
    "29": {
      "nbr": 29,
      "value": "What is the most likely outcome of this code if the people table is empty?\n6: var stmt = conn.prepareStatement(\"SELECT * FROM\npeople\");\n7: var rs1 = stmt.executeQuery();\n8: var rs2 = stmt.executeQuery();\n9: System.out.println(rs1.next() + \" \" + rs2.next());",
      "responses": [{
        "code": "A",
        "value": "It prints false false."
      }, {
        "code": "B",
        "value": "It prints true false."
      }, {
        "code": "C",
        "value": "It does not terminate."
      }, {
        "code": "D",
        "value": "It throws a SQLException."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "29. D. When running a query on a PreparedStatement, Java closes any\nalready open ResultSet objects associated with the statement. This means\nthat rs1 is closed on line 8. Therefore, it throws a SQLException on line 9\nbecause we are trying to call next() on a closed ResultSet, and option D is\ncorrect."
      }
    },
    "30": {
      "nbr": 30,
      "value": "What is the most likely outcome of this code if the bunnies table is empty?\nvar url = \"jdbc:derby:bunnies\";\nvar sql = \"INSERT INTO bunny(name, color) VALUES (?, ?)\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.createStatement()) {\nstmt.setString(1, \"Hoppy\");\nstmt.setString(2, \"Brown\");\nstmt.executeUpdate(sql);\n}",
      "responses": [{
        "code": "A",
        "value": "One row is in the table."
      }, {
        "code": "B",
        "value": "Two rows are in the table."
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code throws a SQLException."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "30. C. This question is trickier if you know more JDBC than is on the exam. If\nyou know only what is on the exam, you would assume the\ncreateStatement() method doesn't exist. However, it does, and stmt is a\nStatement object. Since setString() does not exist on Statement, the\ncode does not compile. This means the answer is option C regardless of\nyour level of knowledge of JDBC."
      }
    }
  }
}, {
  "name": "Localization",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "Which of the following are considered locales? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Cultural region"
      }, {
        "code": "B",
        "value": "Local address"
      }, {
        "code": "C",
        "value": "City"
      }, {
        "code": "D",
        "value": "Time zone region"
      }, {
        "code": "E",
        "value": "Political region"
      }, {
        "code": "F",
        "value": "Geographical region"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E",
          "F"
        ],
        "explanation": "1. A,E,F. Oracle defines a locale as a geographical, political, or cultural\nregion, making options A, E, and F correct. A local address and city are too\ngranular for a locale. Also, time zones often span multiple locales."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Assuming the key green is in all five of the files referenced in the options,\nwhich file will the following code use for the resource bundle?\nLocale.setDefault(new Locale(\"en\", \"US\"));\nvar rb = ResourceBundle.getBundle(\"Colors\", new\nLocale(\"fr\"));\nSystem.out.print(rb.getString(\"green\"));",
      "responses": [{
        "code": "A",
        "value": "Colors_default.properties"
      }, {
        "code": "B",
        "value": "Colors.properties"
      }, {
        "code": "C",
        "value": "Colors_en.properties"
      }, {
        "code": "D",
        "value": "Colors_US.properties"
      }, {
        "code": "E",
        "value": "Colors_en_US.properties"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "2. E. Java starts out by looking for a properties file with the requested locale,\nwhich in this case is the fr language. It doesn't find it, so it moves onto the\ndefault locale en_US, which it does find, making option E correct."
      }
    },
    "3": {
      "nbr": 3,
      "value": "When localizing an application, which type of data varies in presentation\ndepending on locale?",
      "responses": [{
        "code": "A",
        "value": "Currencies"
      }, {
        "code": "B",
        "value": "Dates"
      }, {
        "code": "C",
        "value": "Both"
      }, {
        "code": "D",
        "value": "Neither"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "3. C. Currencies vary in presentation by locale. For example, 9,000 and\n9.000 both represent nine thousand, depending on the locale. Similarly, for\ndates, 01‐02‐2022 and 02‐01‐2022 represent January 2, 2022, or February\n1, 2020, depending on the locale. This makes option C the answer."
      }
    },
    "4": {
      "nbr": 4,
      "value": "How do you find out the locale of the running program?",
      "responses": [{
        "code": "A",
        "value": "Locale.get(\"default\")"
      }, {
        "code": "B",
        "value": "Locale.get(Locale.DEFAULT)"
      }, {
        "code": "C",
        "value": "Locale.of()"
      }, {
        "code": "D",
        "value": "Locale.now()"
      }, {
        "code": "E",
        "value": "Locale.getDefault()"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "4. E. The Locale object provides getDefault() and setDefault() methods\nfor working with the default locale, so option E is correct. The rest of the\nmethods do not exist in the Locale class."
      }
    },
    "5": {
      "nbr": 5,
      "value": "How long will the effects of calling Locale.setDefault() be active\nassuming no other calls to that method are made?",
      "responses": [{
        "code": "A",
        "value": "Until the end of the method."
      }, {
        "code": "B",
        "value": "Until the program exits."
      }, {
        "code": "C",
        "value": "Until the next reboot of the computer."
      }, {
        "code": "D",
        "value": "It persists after reboot."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "5. B. Calling Locale.setDefault() changes the default locale within the\nprogram. It does not change any settings on the computer. The next time\nyou run a Java program, it will have the original default locale rather than\nthe one you changed it to."
      }
    },
    "6": {
      "nbr": 6,
      "value": "What is the output of the following code snippet?\nvar d = LocalDateTime.parse(\"2022-01-21T12:00:00\",\nDateTimeFormatter.ISO_LOCAL_DATE_TIME);\nSystem.out.print(d.format(DateTimeFormatter.ISO_LOCAL_DATE));",
      "responses": [{
        "code": "A",
        "value": "2022‐00‐21"
      }, {
        "code": "B",
        "value": "2022‐00‐22"
      }, {
        "code": "C",
        "value": "2022‐01‐21"
      }, {
        "code": "D",
        "value": "2022‐01‐22"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "6. C. The code compiles and runs without issue. The data is in a valid date\nformat, so the text is parsed as January 21, 2022. Date values are indexed\nfrom 1, not 0, making option C the correct output. Note that a date formatter\nis able to format a date/time value, as the time element can be discarded."
      }
    },
    "7": {
      "nbr": 7,
      "value": "What is the output if the solveMystery() method is applied to a\nProperties object loaded from mystery.properties?\nmystery.properties\nmystery=bag\ntype=paper\nvoid solveMystery(Properties props) {\nvar a = props.get(\"mystery\");\nvar b = props.get(\"more\", null);\nvar c = props.get(\"more\", \"trick\");\nSystem.out.print(a + \" \" + b + \" \" + c);\n}",
      "responses": [{
        "code": "A",
        "value": "bag ? trick"
      }, {
        "code": "B",
        "value": "bag ? null"
      }, {
        "code": "C",
        "value": "bag null null"
      }, {
        "code": "D",
        "value": "bag null trick"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "7. E. The first line of the method is correct, as Properties inherits Map and\nhas a get() method. The get() method does not have an overloaded\nversion that takes a default value, though. For this reason, the second and\nthird get() calls do not compile, and option E is correct. If getProperty()\nwere instead used on the second and third call, then the output would be\nbag null trick."
      }
    },
    "8": {
      "nbr": 8,
      "value": "Fill in the blank with the option that allows the code snippet to compile and\nprint a message without throwing an exception at runtime.\nvar x = LocalDate.of(2022, 3, 1);\nvar y = LocalDateTime.of(2022, 3, 1, 5, 55);\nvar f = DateTimeFormatter.ofPattern(\"MMMM' at 'h'\no'clock'\");\nSystem.out.print(_______________);",
      "responses": [{
        "code": "A",
        "value": "f.formatDate(x)"
      }, {
        "code": "B",
        "value": "f.formatDate(y)"
      }, {
        "code": "C",
        "value": "f.format(x)"
      }, {
        "code": "D",
        "value": "f.format(y)"
      }, {
        "code": "E",
        "value": "The code does not compile regardless of what is placed in the blank."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "8. F. Options A and B are incorrect because formatDate() is not a valid\nmethod name in DateTimeFormatter. Option E is incorrect because the\ncode compiles if either option C or D is used. Both options C and D will\nproduce an exception at runtime, though, as the date pattern is invalid. In\nparticular, the apostrophe in o'clock should be escaped. Option C is also\nincorrect because there is no hour value h for a LocalDate. If the pattern\nstring was corrected with o''clock, then option D would be correct and\nprint March at 5 o'clock at runtime."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Which of the following are valid locale formats? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "hi"
      }, {
        "code": "B",
        "value": "hi_IN"
      }, {
        "code": "C",
        "value": "IN_hi"
      }, {
        "code": "D",
        "value": "in_hi"
      }, {
        "code": "E",
        "value": "HI_IN"
      }, {
        "code": "F",
        "value": "IN"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B"
        ],
        "explanation": "9. A,B. In Java, a locale can be represented by a language code in lowercase,\nor a language and country code, with language in lowercase and country in\nuppercase. For these reasons, options A and B are correct. Options C, D,\nand E are incorrect because the lowercase language must be before the\nuppercase country. Option F is incorrect because the language is missing.\nRemember, the exam won't expect you to know which language and\ncountry codes exist, but it will expect you to know how to use them."
      }
    },
    "10": {
      "nbr": 10,
      "value": "Assuming the key indigo is in all five of the files referenced in the options,\nwhich file will the following code use for the resource bundle?\nLocale loc = new Locale(\"fr\", \"CH\");\nLocale.setDefault(new Locale(\"it\", \"CH\"));\nResourceBundle rb = ResourceBundle.getBundle(\"Colors\",\nloc);\nrb.getString(\"Indigo\");",
      "responses": [{
        "code": "A",
        "value": "Colors_default.properties"
      }, {
        "code": "B",
        "value": "Colors_en_US.properties"
      }, {
        "code": "C",
        "value": "Colors_CH.properties"
      }, {
        "code": "D",
        "value": "Colors_en.properties"
      }, {
        "code": "E",
        "value": "Colors_es.properties"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "10. F. Java starts out by looking for a properties file with the requested locale,\nwhich in this case is the fr_CH language and country. It doesn't find\nColors_fr_CH.properties, so it moves onto the locale with just a language\ncode fr. It also does not find Colors_fr.properties. It then moves on to\nthe default locale it_CH checking Colors_it_CH.properties, but there is\nstill no match. It drops the country code and checks it for\nColors_it.properties, but still doesn't find a match. Lastly, it checks for\na Colors.properties file but since that's not an option, it fails. The result\nis a MissingResourceException is thrown at runtime, making option F\ncorrect."
      }
    },
    "11": {
      "nbr": 11,
      "value": "For currency, the US uses the $ symbol, the UK uses the £ symbol, and\nGermany uses the € symbol. Given this information, what is the expected\noutput of the following code snippet?\nLocale.setDefault(Locale.US);\nLocale.setDefault(Category.FORMAT, Locale.GERMANY);\nSystem.out.print(NumberFormat.getCurrencyInstance(Locale.UK)\n.format(1.1));",
      "responses": [{
        "code": "A",
        "value": "$1.10"
      }, {
        "code": "B",
        "value": "1,10€"
      }, {
        "code": "C",
        "value": "£1.10"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "An exception is thrown at runtime."
      }, {
        "code": "F",
        "value": "The output cannot be determined without knowing the locale of the\nsystem where it will be run."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "11. C. The code compiles, so option D is incorrect. In this sample, the default\nlocale is set to US, while the default locale format is set to GERMANY. Neither\nis used for formatting the value, as getCurrencyInstance() is called with\nUK as the locale. For this reason, the £ symbol is used, making option C\ncorrect."
      }
    },
    "12": {
      "nbr": 12,
      "value": "Given the following four properties files, what does this code print?\nLocale.setDefault(new Locale(\"en\"));\nvar rb = ResourceBundle.getBundle(\"Cars\",\nnew Locale(\"de\", \"DE\"));\nvar r1 = rb.getString(\"engine\");\nvar r2 = rb.getString(\"horses\");\nvar r3 = rb.getString(\"country\");\nSystem.out.print(r1+ \" \" + r2 + \" \" + r3);",
      "responses": [{
        "code": "A",
        "value": "null null null"
      }, {
        "code": "B",
        "value": "engine 241 US"
      }, {
        "code": "C",
        "value": "moteur 45 US"
      }, {
        "code": "D",
        "value": "engine 241 earth"
      }, {
        "code": "E",
        "value": "moteur 241 earth"
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "12. D. The getBundle() does not find Cars_de_DE.properties or\nCars_de.properties, so it moves on to the default locale. Since\nCars_en.properties is available, it will use this file, falling back to\nCars.properties if any values are not available. Therefore, it selects\nengine and horses from the first file, and country from the second file,\nprinting engine 241 earth and making option D correct."
      }
    },
    "13": {
      "nbr": 13,
      "value": "Given the four properties files in question 12, what does this code print?\nLocale.setDefault(new Locale(\"en\", \"US\"));\nvar rb = ResourceBundle.getBundle(\"Cars\",\nnew Locale(\"fr\", \"FR\"));\nvar s1 = rb.getString(\"country\");\nvar s2 = rb.getString(\"horses\");\nvar s3 = rb.getString(\"engine\");\nSystem.out.print(s1+ \" \" + s2 + \" \" + s3);",
      "responses": [{
        "code": "A",
        "value": "France null engine"
      }, {
        "code": "B",
        "value": "France 241 moteur"
      }, {
        "code": "C",
        "value": "France 45 moteur"
      }, {
        "code": "D",
        "value": "France 241 engine"
      }, {
        "code": "E",
        "value": "France 45 engine"
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "13. F. The getBundle() method matches Cars_fr_FR.properties. It will\nthen fall back to Cars_fr.properties (which does not exist) and\nCars.properties if the value is not available. For this reason, the first and\nthird values would be France and moteur. While the second value horses is\nin the default locale, it is not available if the requested locale has been\nfound. As a result, the code throws a MissingResourceException, making\noption F the answer."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Given the four properties files in question 12, what does this code print?\nLocale.setDefault(new Locale(\"ja\",\"JP\"));\nvar rb = ResourceBundle.getBundle(\"Cars\",\nnew Locale(\"fr\", \"FR\"));\nvar t1 = rb.getString(\"engine\");\nvar t2 = rb.getString(\"road\");\nvar t3 = rb.getString(\"country\");\nSystem.out.print(t1+ \" \" + t2 + \" \" + t3);",
      "responses": [{
        "code": "A",
        "value": "moteur autoroute France"
      }, {
        "code": "B",
        "value": "engine autoroute France"
      }, {
        "code": "C",
        "value": "engine highway France"
      }, {
        "code": "D",
        "value": "moteur highway France"
      }, {
        "code": "E",
        "value": "moteur highway US"
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "14. A. The getBundle() method matches Cars_fr_FR.properties. It will\nthen fall back to Cars_fr.properties (which does not exist) and\nCars.properties if the value is not available. For this reason, the first\nvalue printed is moteur from Cars.properties, while the next two values\nprinted are autoroute and France from Cars_fr_FR.properties, making\noption A correct."
      }
    },
    "15": {
      "nbr": 15,
      "value": "Fill in the blank so the code correctly compiles and creates a Locale\nreference.\nLocale loc = Locale.____________________;",
      "responses": [{
        "code": "A",
        "value": "get(\"Italian\")"
      }, {
        "code": "B",
        "value": "of(Locale.ITALIAN)"
      }, {
        "code": "C",
        "value": "get(Locale.ITALIAN)"
      }, {
        "code": "D",
        "value": "getLocale(\"Italian\")"
      }, {
        "code": "E",
        "value": "of(\"Italian\")"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "15. F. There are no get() or of() methods in Locale. You need to use a\nconstructor or a predefined Locale constant to obtain a Locale reference.\nTherefore, option F is the correct answer. Options B and C are close in that\nLocale.ITALIAN does reference a Locale object. However, it should not be\npassed to the nonexistent get() method."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Assuming the key turquoise is in all five of the files referenced in the\noptions, which file will the following code use for the resource bundle?\nLocale loc = new Locale(\"zh\", \"CN\");\nLocale.setDefault(new Locale(\"en\", \"US\"));\nResourceBundle rb = ResourceBundle.getBundle(\"Colors\",\nloc);\nrb.getString(\"turquoise\");",
      "responses": [{
        "code": "A",
        "value": "Colors_en.properties"
      }, {
        "code": "B",
        "value": "Colors_CN.properties"
      }, {
        "code": "C",
        "value": "Colors.properties"
      }, {
        "code": "D",
        "value": "Colors_default.properties"
      }, {
        "code": "E",
        "value": "Colors_en_CN.properties"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "16. A. Java starts out by looking for a properties file with the requested locale,\nwhich in this case is the zh_CN language and country. It doesn't find it, so it\nmoves onto the locale with just a language code zh, which it also does not\nfind. It then moves on to the default locale en_US, but there is still no match.\nIt drops the country code and does find a match with en, making option A\ncorrect."
      }
    },
    "17": {
      "nbr": 17,
      "value": "How many lines does the following print out?\n3: Locale.setDefault(Locale.KOREAN);\n4: System.out.println(Locale.getDefault());\n5: Locale.setDefault(new Locale(\"en\", \"AU\"));\n6: System.out.println(Locale.getDefault());\n7: Locale.setDefault(new Locale(\"EN\"));\n8: System.out.println(Locale.getDefault());",
      "responses": [{
        "code": "A",
        "value": "Only an exception is printed."
      }, {
        "code": "B",
        "value": "One, followed by an exception."
      }, {
        "code": "C",
        "value": "Two, followed by an exception."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "It does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "17. D. This code compiles and runs without exception, making option D the\ncorrect answer. Line 3 uses a predefined Locale constant. Line 5 passes a\nlanguage and country code for English in Australia. Line 7 incorrectly\npasses capital letters as a language code. However, Java automatically\nconverts it to lowercase without throwing an exception. The three lines\nprinted by the code are ko, en_AU, and en."
      }
    },
    "18": {
      "nbr": 18,
      "value": "Assuming the key red is in all five of the files referenced in the options,\nwhich file will the following code use for the resource bundle?\nLocale.setDefault(new Locale(\"en\", \"US\"));\nvar rb = ResourceBundle.getBundle(\"Colors\",\nnew Locale(\"ca\",\"ES\"));\nSystem.out.print(rb.getString(\"red\"));",
      "responses": [{
        "code": "A",
        "value": "Colors.properties"
      }, {
        "code": "B",
        "value": "Colors_en_US.properties"
      }, {
        "code": "C",
        "value": "Colors_US.properties"
      }, {
        "code": "D",
        "value": "Colors_ES.properties"
      }, {
        "code": "E",
        "value": "Colors_ca.properties"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "18. E. Java starts out by looking for a properties file with the requested locale,\nwhich in this case is the ca_ES language and country. It doesn't find it, so it\nmoves onto the locale with just a language code ca, which it does find,\nmaking option E correct."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What is the output of the following code snippet?\nvar d = LocalDate.parse(\"2022-04-01\",\nDateTimeFormatter.ISO_LOCAL_DATE);\nSystem.out.print(d.format(\nDateTimeFormatter.ISO_LOCAL_DATE_TIME));",
      "responses": [{
        "code": "A",
        "value": "2022 APRIL 1"
      }, {
        "code": "B",
        "value": "2022 MAY 0"
      }, {
        "code": "C",
        "value": "2022 MAY 1"
      }, {
        "code": "D",
        "value": "2022 APRIL 0"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "19. F. The parse() method properly reads the date as April 1, 2022. The\nformat() tries to use a date/time formatter on a date, which produces an\nexception at runtime since the time element is missing. For this reason,\noption F is correct."
      }
    },
    "20": {
      "nbr": 20,
      "value": "What is the output if the launch() method is applied to a Properties\nobject loaded from scifi.properties?\nscifi.properties\nrocket=saturn5\nmoon=landing\nvoid launch(Properties props) {\nvar a = props.getProperty(\"rocket\", \"?\");\nvar b = props.getProperty(\"earth\");\nvar c = props.getProperty(\"earth\", \"?\");\nSystem.out.print(a + \" \" + b + \" \" + c);\n}",
      "responses": [{
        "code": "A",
        "value": "saturn5 null ?"
      }, {
        "code": "B",
        "value": "saturn5 null null"
      }, {
        "code": "C",
        "value": "null null ?"
      }, {
        "code": "D",
        "value": "saturn5 ? ?"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "20. A. The first line of the method retrieves the value for the property with\nkey rocket, which is saturn5. The next line retrieves the value for earth,\nbut since it's not found, null is returned. The last functions similarly to the\nprevious line but uses ? as the default value since earth is not set. The code\nthen prints saturn5 null ?, making option A the correct answer."
      }
    },
    "21": {
      "nbr": 21,
      "value": "For what values of pattern will the following print <02.1> <06.9>\n<10,00>? (Choose two.)\nString pattern = \"_______________\";\nvar message = DoubleStream.of(2.1, 6.923, 1000)\n.mapToObj(v -> new DecimalFormat(pattern).format(v))\n.collect(Collectors.joining(\"> <\"));\nSystem.out.print(\"<\" + message + \">\");",
      "responses": [{
        "code": "A",
        "value": "##,00.##"
      }, {
        "code": "B",
        "value": "##,00.#"
      }, {
        "code": "C",
        "value": "0,00.#"
      }, {
        "code": "D",
        "value": "#,00.#"
      }, {
        "code": "E",
        "value": "0,00.0"
      }, {
        "code": "F",
        "value": "#,##.#"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "21. B,D. Options B and D correctly print the same string value in the specified\nformat. Option A is incorrect because <06.92> is printed instead of <06.9>.\nOptions C and E are incorrect, because (among other things) commas are\nprinted as part of both of the first two values. Option F is incorrect because\n<2.1> <6.9> is printed instead of <02.1> <06.9>."
      }
    },
    "22": {
      "nbr": 22,
      "value": "What is the result of the following?\nMap<String, String> map = new TreeMap<>();\nmap.put(\"tool\", \"hammer\");\nmap.put(\"problem\", \"nail\");\nvar props = new Property(); // p1\nmap.forEach((k,v) -> props.put(k, v)); // p2\nString t = props.getProperty(\"tool\"); // p3\nString n = props.getProperty(\"nail\");\nSystem.out.print(t + \" \" + n);",
      "responses": [{
        "code": "A",
        "value": "hammer nail"
      }, {
        "code": "B",
        "value": "The code does not compile due to line p1."
      }, {
        "code": "C",
        "value": "The code does not compile due to line p2."
      }, {
        "code": "D",
        "value": "The code does not compile due to line p3."
      }, {
        "code": "E",
        "value": "An exception is thrown at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "22. B. The class on line p1 should be Properties rather than Property. As\nwritten, it is incorrect and does not compile, making option B the correct\nanswer."
      }
    },
    "23": {
      "nbr": 23,
      "value": "Assuming the key purple is in all five of the files referenced in the options,\nwhich file will the following code use for the resource bundle?\nLocale.setDefault(new Locale(\"en\", \"US\"));\nvar rb = ResourceBundle.getBundle(\"Colors\", new\nLocale(\"en\"));\nSystem.out.print(rb.getString(\"purple\"));",
      "responses": [{
        "code": "A",
        "value": "Colors_en_US.properties"
      }, {
        "code": "B",
        "value": "Colors_en.properties"
      }, {
        "code": "C",
        "value": "Colors_US.properties"
      }, {
        "code": "D",
        "value": "Colors_fr.properties"
      }, {
        "code": "E",
        "value": "Colors.properties"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "23. B. Java starts out by looking for a properties file with the requested locale,\nwhich in this case is the en language. It finds it right away, making option B\ncorrect."
      }
    },
    "24": {
      "nbr": 24,
      "value": "Which of the following are not valid Locale formats? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "nl_BE"
      }, {
        "code": "B",
        "value": "fr_CA"
      }, {
        "code": "C",
        "value": "uk_ua"
      }, {
        "code": "D",
        "value": "CR"
      }, {
        "code": "E",
        "value": "no"
      }, {
        "code": "F",
        "value": "ro_RO"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "24. C,D. In Java, a locale can be represented by a language code in lowercase,\nor a language and country code, with language in lowercase and country in\nuppercase. Option C is invalid because both values are lowercase. Option D\nis invalid because the value is in uppercase. The rest of the options are valid\nlocale formats. Remember, the exam won't expect you to know which\nlanguage and country codes exist, but it will expect you to know how to use\nthem."
      }
    },
    "25": {
      "nbr": 25,
      "value": "For currency, the US uses the $ symbol, the UK uses the £ symbol, and\nGermany uses the € symbol. Given this information, what is the expected\noutput of the following code snippet?\nLocale.setDefault(Locale.US);\nLocale.setDefault(Category.FORMAT, Locale.GERMANY);\nLocale.setDefault(Category.DISPLAY, Locale.UK);\nSystem.out.print(NumberFormat.getCurrencyInstance()\n.format(6.95));",
      "responses": [{
        "code": "A",
        "value": "$6.95"
      }, {
        "code": "B",
        "value": "6,95 €"
      }, {
        "code": "C",
        "value": "£6.95"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "An exception is thrown at runtime."
      }, {
        "code": "F",
        "value": "The output cannot be determined without knowing the locale of the\nsystem where it will be run."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "25. B. The code compiles, so option D is incorrect. While three distinct locale\nvalues are set, the one that is used for formatting text is Category.FORMAT.\nFor this reason, the GERMANY locale is used to formatting the data with the €\nsymbol, making option B correct."
      }
    },
    "26": {
      "nbr": 26,
      "value": "What is the output of the following code snippet?\nvar x = LocalDate.of(2022, 3, 1);\nvar y = LocalDateTime.of(2022, 1, 1, 2, 55);\nvar f = DateTimeFormatter.ofPattern(\"'yyyy-MM'\");\nSystem.out.print(f.format(x) + \" \" + f.format(y));",
      "responses": [{
        "code": "A",
        "value": "2022‐03 2022‐01"
      }, {
        "code": "B",
        "value": "2022‐01 2022‐03"
      }, {
        "code": "C",
        "value": "2022‐02 2022‐00"
      }, {
        "code": "D",
        "value": "yyyy‐MM yyyy‐MM"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "26. D. The date/time pattern uses single quotes to escape the date/time values,\nmeaning the output is yyyy‐MM for all valid inputs. For this reason, option D\nis correct. If the single quotes were removed, then 2022‐03 2022‐01 would\nbe the correct output."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Given the following two properties files, what does the following class\noutput?\ncontainer.properties\nname=generic\nnumber=2\ncontainer_en.properties\nname=Docker\ntype=container\nvoid loadPod() {\nnew Locale.Builder()\n.setLanguage(\"en\")\n.setRegion(\"US\").build();\nvar rb = ResourceBundle.getBundle(\"container\");\nString name = rb.getString(\"name\");\nString type = rb.getString(\"type\");\nSystem.out.print(name + \" \" + type);\n}",
      "responses": [{
        "code": "A",
        "value": "Docker container"
      }, {
        "code": "B",
        "value": "generic container"
      }, {
        "code": "C",
        "value": "generic null"
      }, {
        "code": "D",
        "value": "The output cannot be determined without knowing the locale of the\nsystem where it will be run."
      }, {
        "code": "E",
        "value": "An exception is thrown at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "27. D. The method creates a resource bundle using a builder but never sets it.\nSince we don't know the default locale of the code, the answer depends on\nwhere it is executed, making option D correct."
      }
    },
    "28": {
      "nbr": 28,
      "value": "Given the two properties files from question 27, what does the following\nclass output?\nvoid loadContainer() {\nLocale.setDefault(new Locale(\"en\"));\nvar rb = ResourceBundle.getBundle(\"container\");\nString name = rb.getString(\"name\");\nString type = rb.getString(\"type\");\nSystem.out.print(name + \" \" + type);\n}",
      "responses": [{
        "code": "A",
        "value": "Docker container"
      }, {
        "code": "B",
        "value": "generic container"
      }, {
        "code": "C",
        "value": "generic null"
      }, {
        "code": "D",
        "value": "The output cannot be determined without knowing the locale of the\nsystem where it will be run."
      }, {
        "code": "E",
        "value": "An exception is thrown at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "28. A. This code sets the default locale to English and then tries to get a\nresource bundle for container. It finds the resource bundle\ncontainer_en.properties as the most specific match. Both keys are found\nin this file, so option A is the answer."
      }
    },
    "29": {
      "nbr": 29,
      "value": "Given the two properties files from question 27, what does the following\nclass output?\nvoid loadControlPlane() {\nLocale.setDefault(new Locale(\"en_US\"));\nvar rb = ResourceBundle.getBundle(\"container\");\nString name = rb.getString(\"name\");\nString type = rb.getString(\"type\");\nSystem.out.print(name + \" \" + type);\n}",
      "responses": [{
        "code": "A",
        "value": "Docker container"
      }, {
        "code": "B",
        "value": "generic container"
      }, {
        "code": "C",
        "value": "generic null"
      }, {
        "code": "D",
        "value": "The output cannot be determined without knowing the locale of the\nsystem where it will be run."
      }, {
        "code": "E",
        "value": "An exception is thrown at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "29. E. The Locale constructor that takes a single argument expects a language\ncode, not a concatenation of language and region codes. Therefore, the\nlanguage is set as en_us, not en, with no region code set. Since no\nproperties files match the language en_us, the default\ncontainer.properties is used. Since type is not found in this properties\nfile, a MissingResourceException is thrown at runtime."
      }
    },
    "30": {
      "nbr": 30,
      "value": "Assuming the Forest.properties file is the only resource file available,\nwhat is the output of calling the hike() method?\nForest.properties\ntrees=evergreen {0}\nanimals=squirrels\nstatic void hike() {\nLocale.setDefault(new Locale.Builder()\n.setLanguage(\"en\").build());\nvar rb = ResourceBundle\n.getBundle(\"Forest\", new Locale(\"fr\"));\nSystem.out.print(MessageFormat.format(\"trees\",\"pretty\"));\n}",
      "responses": [{
        "code": "A",
        "value": "trees"
      }, {
        "code": "B",
        "value": "trees pretty"
      }, {
        "code": "C",
        "value": "trees {0}"
      }, {
        "code": "D",
        "value": "trees null"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "30. A. The code compiles, so option E is incorrect. Java starts out by looking\nfor a properties file with the requested locale, which in this case is the fr\nlanguage. It doesn't find Forest_fr.properties, so it moves onto the\ndefault locale en. It also doesn't find Forest_en.properties. It settles on\nForest.properties without throwing an exception, so option F is\nincorrect. The first argument to MessageFormat.format() should be a\npattern String value. Since trees is sent, the output of the formatting\nstring is trees, making option A correct. If rb.getString(\"trees\") was\npassed instead of just trees, then the output would be evergreen pretty."
      }
    }
  }
}, {
  "name": "Annotations",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "What modifier is used to mark an annotation element as optional?",
      "responses": [{
        "code": "A",
        "value": "optional"
      }, {
        "code": "B",
        "value": "default"
      }, {
        "code": "C",
        "value": "required"
      }, {
        "code": "D",
        "value": "value"
      }, {
        "code": "E",
        "value": "case"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "1. B. The default modifier along with a value is used to mark an annotation\nelement as optional, as opposed to required."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Given a Broadway show, which information is best stored using\nannotations? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "The number of people attending each day"
      }, {
        "code": "B",
        "value": "The maximum number of tickets a person can purchase"
      }, {
        "code": "C",
        "value": "The total number of people the theater can hold"
      }, {
        "code": "D",
        "value": "The price including discounts a person pays for a ticket"
      }, {
        "code": "E",
        "value": "A person's seat assignment"
      }, {
        "code": "F",
        "value": "The time a ticket is sold"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C"
        ],
        "explanation": "2. B,C. Annotations are about storing metadata, or data about data. The\nmaximum number of tickets per person and total number of people the\ntheater can hold define rules that are unlikely to change frequently, so they\nare best stored with annotations. The number of people attending, price, and\ntime the ticket is sold are likely to change frequently and should be part of\nthe transactional information for the ticket. The seat assignment also\nchanges for every ticket sold."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Fill in the blank with the correct annotation usage that allows the code to\ncompile.\npublic interface CelestialBody {\nString name();\ndouble size() default 100;\nint lightYears = 2;\n}\n_________________ class Planet {}",
      "responses": [{
        "code": "A",
        "value": "@CelestialBody(name=\"Venus\")"
      }, {
        "code": "B",
        "value": "@CelestialBody(name=\"Pluto\", size=2, lightYears=5)"
      }, {
        "code": "C",
        "value": "@CelestialBody(lightYears=10)"
      }, {
        "code": "D",
        "value": "@CelestialBody(\"Jupiter\")"
      }, {
        "code": "E",
        "value": "@CelestialBody(size=3)"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "3. F. CelestialBody is not an annotation definition because it is not declared\nwith the @interface type, making option F correct. If the correct\ndeclaration was used, then option A would be the correct answer. Options B\nand C are incorrect, because lightYears is a constant and cannot be set as\npart of the annotation. Options C and E are also incorrect because they are\nmissing a name element. Option D is incorrect because there is no value()\nelement."
      }
    },
    "4": {
      "nbr": 4,
      "value": "Fill in the blank with the correct value for @Target that allows the code to\ncompile.\nimport java.lang.annotation.*;\n@Target({_______________})\npublic @interface LightSource {}\n@LightSource class Bulb {\n@LightSource void lightSwitch() {}\n@LightSource private Bulb() {}\n}",
      "responses": [{
        "code": "A",
        "value": "ElementType.METHOD, ElementType.CONSTRUCTOR"
      }, {
        "code": "B",
        "value": "ElementType.ANNOTATION_TYPE"
      }, {
        "code": "C",
        "value": "ElementType.CONSTRUCTOR, ElementType.TYPE,\nElementType.METHOD"
      }, {
        "code": "D",
        "value": "ElementType.TYPE_USE"
      }, {
        "code": "E",
        "value": "ElementType.LOCAL_VARIABLE, ElementType.FIELD"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "4. C. Option C uses the correct values and allows all three annotations to\ncompile. Option A is incorrect because the class declaration usage does not\ncompile. Using option B or E does not allow any of the annotations to\ncompile. Option D allows the class and constructor annotations to compile,\nbut not the method usage."
      }
    },
    "5": {
      "nbr": 5,
      "value": "Which of the following are marker annotations? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "@Target"
      }, {
        "code": "B",
        "value": "@Inherited"
      }, {
        "code": "C",
        "value": "@Override"
      }, {
        "code": "D",
        "value": "@Retention"
      }, {
        "code": "E",
        "value": "@Repeatable"
      }, {
        "code": "F",
        "value": "@Documented"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "F"
        ],
        "explanation": "5. B,C,F. Options B, C, and F are each marker annotations because they do\nnot contain any elements. Option A is incorrect because @Target requires\nan ElementType[] value. Option D is incorrect because @Retention\nrequires a RetentionPolicy value. Option E is incorrect because\n@Repeatable requires a Class value."
      }
    },
    "6": {
      "nbr": 6,
      "value": "Given the following declarations, which annotations can fill in the blank\nthat would allow the code to compile? (Choose three.)\npublic @interface Music {\nString value() default \"violin\";\n}\nclass Orchestra {\n___________ void play() {}\n}",
      "responses": [{
        "code": "A",
        "value": "@Music(super=\"piccolo\")"
      }, {
        "code": "B",
        "value": "@Music(\"viola\")"
      }, {
        "code": "C",
        "value": "@Music(value()=\"bass\")"
      }, {
        "code": "D",
        "value": "@Music"
      }, {
        "code": "E",
        "value": "@Music(default=\"flute\")"
      }, {
        "code": "F",
        "value": "@Music(value=\"cello\")"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "F"
        ],
        "explanation": "6. B,D,F. Option B is correct and relies on the fact that the single element\nvalue() can be used without an element name. Option D is correct because\nthe annotation has a default value; therefore, value is optional. Option F is\ncorrect and uses the correct name for value. Options A, C, and E are\nincorrect because they use the wrong name for the element."
      }
    },
    "7": {
      "nbr": 7,
      "value": "How many lines of the following declaration contain a compiler error?\n1: public @interface Thermometer {\n2: int minTemp();\n3: Integer maxTemp() default 1;\n4: double[] color();\n5: final String type;\n6: Boolean compact;\n7: }",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "7. D. Lines 3 and 6 do not compile because wrapper classes are not permitted\nas annotation element types. Line 5 does not compile because a constant\nmust be declared with a value. For these reasons, option D is correct. The\nrest of the lines compile without issue."
      }
    },
    "8": {
      "nbr": 8,
      "value": "In what ways are annotations similar to interfaces? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "They can both declare methods with bodies."
      }, {
        "code": "B",
        "value": "They can both declare constructors."
      }, {
        "code": "C",
        "value": "They can both declare constants."
      }, {
        "code": "D",
        "value": "They can both be extended with the extends keyword."
      }, {
        "code": "E",
        "value": "They can both be used in a class declaration."
      }, {
        "code": "F",
        "value": "They both are declared with the interface type."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "8. C,E. Options A and D are incorrect. An interface can define a method and\nbe extended, but an annotation cannot. Neither type can declare\nconstructors, making option B incorrect. Annotations and interfaces can\nboth declare constants and be applied to a class declaration, making options\nC and E correct. Interfaces use the interface type, while annotations use\nthe @interface type, making option F incorrect."
      }
    },
    "9": {
      "nbr": 9,
      "value": "In how many of the marked places (m1, m2, m3) will adding the line\n@SuppressWarnings() independently allow the class to compile without\nany warnings?\nimport java.util.*;\n// m1\npublic class Space {\n// m2\nfinal void frontier() {\nList<Object> stars = List.of(1,2,3);\nstars.add(4);\n// m3\nList planets = new ArrayList<>();\nplanets.add(5);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "None, the class does not compile as is."
      }, {
        "code": "B",
        "value": "None, the class already compiles without warnings."
      }, {
        "code": "C",
        "value": "One."
      }, {
        "code": "D",
        "value": "Two."
      }, {
        "code": "E",
        "value": "Three."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "9. F. The class compiles as is but generates warnings for unchecked/unsafe\noperations with the planets.add(5) operation, so options A and B are\nincorrect. Inserting @SuppressWarnings(), though, will cause a compiler\nerror as it requires at least one value. For this reason, option F is correct. If\n@SuppressWarnings(\"unchecked\") was used instead, then inserting it on\nlines m1 and m2 would allow the code to compile without any warnings."
      }
    },
    "10": {
      "nbr": 10,
      "value": "An annotation cannot be applied to which of the following?",
      "responses": [{
        "code": "A",
        "value": "Class declaration."
      }, {
        "code": "B",
        "value": "Annotation declaration."
      }, {
        "code": "C",
        "value": "Inner class declaration."
      }, {
        "code": "D",
        "value": "Cast operation."
      }, {
        "code": "E",
        "value": "Local variable declaration using var."
      }, {
        "code": "F",
        "value": "An annotation can be applied to all of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "10. F. An annotation can be applied to all of these Java declarations, making\noption F correct."
      }
    },
    "11": {
      "nbr": 11,
      "value": "Which statements about the @Override annotation are correct? (Choose\nthree.)",
      "responses": [{
        "code": "A",
        "value": "It can be optionally specified when a class implements an abstract\ninterface method."
      }, {
        "code": "B",
        "value": "Adding it to a method may trigger a compiler error."
      }, {
        "code": "C",
        "value": "It is required whenever a class implements an abstract interface\nmethod."
      }, {
        "code": "D",
        "value": "It can be added to an interface declaration type."
      }, {
        "code": "E",
        "value": "It can be optionally specified when a method is overridden in a\nsubclass."
      }, {
        "code": "F",
        "value": "It is required whenever a method is overridden in a subclass."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "E"
        ],
        "explanation": "11. A,B,E. The @Override annotation is always optional for methods and\nnever required. For this reason, options A and E are correct, and options C\nand F are incorrect. Option B is correct because adding it to a method that is\nnot actually overriding an inherited method will cause a compiler error.\nOption D is incorrect because it can be applied only to method declarations."
      }
    },
    "12": {
      "nbr": 12,
      "value": "Given the following declarations, which annotation can be applied to a\nmethod declaration?\nimport java.lang.annotation.*;\n@interface Bread {\npublic int maker = 5;\nString baker();\n}\n@Inherited\n@interface Toast {\nboolean buttered() default true;\nint freshness() default Bread.maker;\nstatic boolean wheat = false;\n}",
      "responses": [{
        "code": "A",
        "value": "@Toast(true)"
      }, {
        "code": "B",
        "value": "@Toast"
      }, {
        "code": "C",
        "value": "@Bread(\"null\")"
      }, {
        "code": "D",
        "value": "@Toast(wheat=true)"
      }, {
        "code": "E",
        "value": "@Bread"
      }, {
        "code": "F",
        "value": "None of the above, as the annotation declarations do not compile"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "12. B. The declaration compiles, so option F is incorrect. The Bread\nannotation is declared with one required element, while Toast is declared\nwith no required elements. For these reasons, option B is correct, and\noption E is incorrect. Options A and C are incorrect because neither\nannotation contains a value() element. Option D is incorrect because\nwheat is a constant, not an element."
      }
    },
    "13": {
      "nbr": 13,
      "value": "Which properties of the Clean annotation must be true for the following to\ncompile? (Choose three.)\n@Clean(\"Basement\") public class House {}",
      "responses": [{
        "code": "A",
        "value": "The annotation must contain exactly one element."
      }, {
        "code": "B",
        "value": "The annotation must contain an element named value."
      }, {
        "code": "C",
        "value": "The element must not have a default value."
      }, {
        "code": "D",
        "value": "The element may have a default value."
      }, {
        "code": "E",
        "value": "The annotation may contain more than one element."
      }, {
        "code": "F",
        "value": "The annotation must contain an element named values."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "E"
        ],
        "explanation": "13. B,D,E. An annotation may omit the element name if it contains an element\nnamed value, declared as value(), making option B correct and option F\nincorrect. Additionally, it may contain any number of additional elements,\nprovided none of them is required, making option E correct. Finally, the\nelement may optionally have a default value, making option D correct. The\nother options are incorrect statements that contradict the correct answers."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Assume the following code compiles. Which annotation inserted in the line\nallows the code to print a non‐null value at runtime?\n// INSERT HERE\n@interface Fast {\nint topSpeed() default 10;\n}\n@Fast class BigCat {}\npublic class Cheetah extends BigCat {\npublic static void main(String… unused) {\nvar a = Cheetah.class.getAnnotation(Fast.class);\nSystem.out.print(a);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "@Inherited"
      }, {
        "code": "B",
        "value": "@Polymorphism"
      }, {
        "code": "C",
        "value": "@Inheritance"
      }, {
        "code": "D",
        "value": "@Retention"
      }, {
        "code": "E",
        "value": "@Subclass"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "14. F. Trick question! By default, annotations are not present at runtime. To\nprint a non‐null value, both @Retention(RetentionPolicy.RUNTIME) and\n@Inherited would be required, making option F correct. The @Retention\nannotation would preserve the annotation for runtime, while the\n@Inherited annotation would apply it to the subclass Cheetah."
      }
    },
    "15": {
      "nbr": 15,
      "value": "How many lines of the following declaration contain a compiler error?\n1: public @interface Student {\n2: final boolean likesPonies = true;\n3: int value default 100;\n4: int age();\n5: /** TODO **/\n6: String name() default \"Olivia\";\n7: }",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "15. B. Only line 3 contains a compiler error, as an element declared in an\nannotation must use parentheses after its name, making option B correct. If\nvalue() was used instead of value, then the code would compile."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Which statement about the following declarations is correct?\nimport java.lang.annotation.*;\nimport java.util.List;\n@Target(ElementType.TYPE_USE)\npublic @interface Friend {\nString value();\nString lastName() default null;\nint age = 10;\n}\nclass MyFriends {\nvoid makeFriends() {\nvar friends = List.of(new @Friend(\"Olivia\") Object(),\nnew @Friend(\"Adeline\") String(),\nnew @Friend(\"Henry\") MyFriends());\n}\n}",
      "responses": [{
        "code": "A",
        "value": "None of the declarations compile."
      }, {
        "code": "B",
        "value": "Only the declaration of Friend contains a compiler error."
      }, {
        "code": "C",
        "value": "Only the declaration of MyFriends contains a compiler error."
      }, {
        "code": "D",
        "value": "Both declarations contain compiler errors."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "16. B. A default annotation element value must be a non‐null constant\nexpression. Since lastName() provides a null value by default, the\ndeclaration of Friend contains a compiler error. The declaration of\nMyFriends does not contain any compiler errors, so option B is correct."
      }
    },
    "17": {
      "nbr": 17,
      "value": "Which of the following are permitted to be used for annotation element\ntype? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Object"
      }, {
        "code": "B",
        "value": "An annotation"
      }, {
        "code": "C",
        "value": "Class[]"
      }, {
        "code": "D",
        "value": "An enum"
      }, {
        "code": "E",
        "value": "Double"
      }, {
        "code": "F",
        "value": "var"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "D"
        ],
        "explanation": "17. B,C,D. An annotation element type must be a primitive type, a String, a\nClass, an enum, another annotation, or an array of any of these types. For\nthis reason, options B, C, and D are correct. Option A is incorrect because\nObject is not supported. While primitives are supported, wrappers are not,\nmaking option E incorrect. Option F is also incorrect as local variable type\ninference with var is not permitted, even if a default value is provided."
      }
    },
    "18": {
      "nbr": 18,
      "value": "Fill in the blanks with the lines of code that allow the program to compile.\n(Choose two.)\nimport java.lang.annotation.*;\n@Repeatable(___________) // t1\n@interface Gift {\nString value();\n}\n@interface Presents {\n___________; // t2\n}\n@Gift(\"Book\") @Gift(\"Toy\") public class Surprise {}",
      "responses": [{
        "code": "A",
        "value": "Presents on line t1"
      }, {
        "code": "B",
        "value": "@Presents on line t1"
      }, {
        "code": "C",
        "value": "Gift value() on line t2"
      }, {
        "code": "D",
        "value": "Presents.class on line t1"
      }, {
        "code": "E",
        "value": "Gift[] value() on line t2"
      }, {
        "code": "F",
        "value": "Gift[] gift() on line t2"
      }
      ],
      "answer": {
        "codes": [
          "D",
          "E"
        ],
        "explanation": "18. D,E. Gift is a repeatable annotation. It requires specifying a container\ntype annotation using the Class object, making option D correct. The\ncontaining type annotation referenced must declare a value() element that\nis an array of the repeatable annotation, making option E correct."
      }
    },
    "19": {
      "nbr": 19,
      "value": "Which statements about annotations are correct? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Annotations contain data that changes throughout the program\nexecution."
      }, {
        "code": "B",
        "value": "Adding an annotation to a class that already compiles may trigger a\ncompiler error and cause it to fail to compile."
      }, {
        "code": "C",
        "value": "Annotations contain metadata about a Java type."
      }, {
        "code": "D",
        "value": "Annotations cannot be applied to lambda expression variables."
      }, {
        "code": "E",
        "value": "Annotations cannot be applied to other annotations."
      }, {
        "code": "F",
        "value": "Removing all annotations from a class that already compiles will not\nintroduce a compiler error."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "F"
        ],
        "explanation": "19. B,C,F. Option A is incorrect, as annotations generally contain information\nthat is constant throughout the program execution. Option B is correct. For\nexample, adding an @Override annotation to a method that is not a valid\noverride will trigger a compiler error. Option C is also correct and is the\nprimary purpose of annotations. Options D and E are incorrect, as\nannotations can be applied to a variety of types including lambda\nexpression variables and other annotations. Finally, option F is correct.\nAnnotations are optional metadata, and removing all of them from a class\ndoes not cause a compiler error."
      }
    },
    "20": {
      "nbr": 20,
      "value": "Given the following declarations, which annotations can fill in the blank\nthat would allow the code to compile? (Choose three.)\nimport java.util.*;\npublic @interface Vacuum {\nString[] value();\n}\nclass Appliance {\n______________ void clean() {}\n}",
      "responses": [{
        "code": "A",
        "value": "@Vacuum({})"
      }, {
        "code": "B",
        "value": "@Vacuum({\"upright\",\"new\"})"
      }, {
        "code": "C",
        "value": "@Vacuum(List.of(\"portable\"))"
      }, {
        "code": "D",
        "value": "@Vacuum"
      }, {
        "code": "E",
        "value": "@Vacuum(\"handheld\")"
      }, {
        "code": "F",
        "value": "@Vacuum(default=\"shop\")"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "E"
        ],
        "explanation": "20. A,B,E. Options A, B, and E are correct and rely on the fact that the\nelement name is optional for an annotation with a single element named\nvalue(). Option E also relies on annotations supporting a single element\nfor an array. Note that the array provided is not required to have any\nelements. Option C is incorrect because Java does not automatically convert\nfrom a List to an array. Option D is incorrect because the annotation\ncontains a required element. Finally, option F is incorrect because default\nis the wrong element name."
      }
    },
    "21": {
      "nbr": 21,
      "value": "Which method declarations can @SafeVarargs be correctly applied to?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "protected void hum(double… tune)"
      }, {
        "code": "B",
        "value": "final int whistle(int length, float… measure)"
      }, {
        "code": "C",
        "value": "static void sing()"
      }, {
        "code": "D",
        "value": "private void listen(String… mp3)"
      }, {
        "code": "E",
        "value": "void dance(List<Integer>… beat)"
      }, {
        "code": "F",
        "value": "private static int play(int[] notes)"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "21. B,D. The @SafeVarargs annotation requires the method to which it is\napplied contain a varargs parameter and be unable to be overridden, aka\nmarked static, final, or private. Options B and D fulfill this\nrequirement. Options A and E are missing a modifier that prevents them\nfrom being overridden. Options C and F are missing a vararg parameter.\nWhile a primitive array int[] can be passed to a method containing a\nvarargs parameter, to apply the @SafeVarargs annotation, the method must\nbe declared with a varargs annotation."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Which annotation can be applied to an existing annotation X and ensures a\nclass that uses X shows the annotation in its generated Javadoc?",
      "responses": [{
        "code": "A",
        "value": "@Documented"
      }, {
        "code": "B",
        "value": "@Generated"
      }, {
        "code": "C",
        "value": "@JavaDoc"
      }, {
        "code": "D",
        "value": "@PreserveAnnotations"
      }, {
        "code": "E",
        "value": "@Retention"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "22. A. The correct annotation that preserves information about annotations in\ngenerated Javadoc files is @Documented. The rest are incorrect."
      }
    },
    "23": {
      "nbr": 23,
      "value": "Fill in the blank with the value that allows the annotation to be accessible\nby the JVM in which it is executed?\nimport java.lang.annotation.*;\n@Retention(_______________)\npublic class Corn {}",
      "responses": [{
        "code": "A",
        "value": "RetentionPolicy.CLASS"
      }, {
        "code": "B",
        "value": "RetentionPolicy.JRE"
      }, {
        "code": "C",
        "value": "RetentionPolicy.RUNTIME"
      }, {
        "code": "D",
        "value": "RetentionPolicy.SOURCE"
      }, {
        "code": "E",
        "value": "RetentionPolicy.LIVE"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "23. F. The @Retention annotation can be applied only to an annotation\ndeclaration, not a class declaration, making option F the correct answer.\nApplying it to a class will result in a compiler error. If Corn were an\nannotation, though, then RetentionPolicy.RUNTIME would be correct."
      }
    },
    "24": {
      "nbr": 24,
      "value": "How many lines of the following declarations contain a compiler error?\n1: @interface Sword {}\n2: public @interface Zelda {\n3: private String game();\n4: Sword sword();\n5: java.util.List<Integer> gems;\n6: final boolean hasBossKey();\n7: public abstract int level() default 99;\n8: protected boolean continue();\n9: }",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "24. E. Lines 3 and 8 do not compile because annotation elements must be\npublic, implicitly or explicitly. Line 8 also does not compile because\ncontinue is a keyword in Java. Line 5 does not compile. While arrays are\npermitted as element types, collections like List are not. Line 6 does not\ncompile because annotation elements cannot be marked final, as they are\nimplicitly abstract. For these reasons, option E is correct. Line 4 compiles\nbecause an annotation can declare another annotation as the element type.\nLine 7 also compiles. While the public and abstract modifiers aren't\nrequired for an annotation element, they can be specified."
      }
    },
    "25": {
      "nbr": 25,
      "value": "Which of the following are permitted for an annotation element default\nvalue? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "\"\""
      }, {
        "code": "B",
        "value": "(int)1_000.0"
      }, {
        "code": "C",
        "value": "new String()"
      }, {
        "code": "D",
        "value": "Integer.valueOf(3).intValue()"
      }, {
        "code": "E",
        "value": "null"
      }, {
        "code": "F",
        "value": "Integer.MAX_VALUE"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "F"
        ],
        "explanation": "25. A,B,F. An annotation element can include a default value if it is a nonnull\nconstant expression. Options A, B, and F fulfill this criteria. Option C\nis incorrect because it creates a new object. Option D is incorrect because it\nuses method calls. Option E is incorrect because null is not permitted."
      }
    },
    "26": {
      "nbr": 26,
      "value": "Assuming @Weather is a valid repeatable annotation that takes a String,\nwith its associated containing type annotation @Forecast, which of the\nfollowing can be applied to a type declaration? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "@Forecast({\"Storm\", \"Cloudy\"})"
      }, {
        "code": "B",
        "value": "@Forecast({@Weather(\"Storm\"), @Weather(\"Cloudy\")})"
      }, {
        "code": "C",
        "value": "@Weather(\"Storm\") @Weather(\"Cloudy\")"
      }, {
        "code": "D",
        "value": "@Weather({@Forecast(\"Storm\"), @Forecast(\"Cloudy\")})"
      }, {
        "code": "E",
        "value": "@Forecast(\"Storm\") @Forecast(\"Cloudy\")"
      }, {
        "code": "F",
        "value": "@Weather({\"Storm\", \"Cloudy\"})"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C"
        ],
        "explanation": "26. B,C. @Weather is the repeatable annotation, so it can be used twice on the\nsame type declaration, making option C correct. A containing type\nannotation @Forecast takes an array of the repeatable annotation @Weather,\nmaking option B also correct. Options A and F are incorrect, as those\nrepresent an annotation that takes an array of String values. Option D and\nE are incorrect because the repeatable and containing type annotations are\nreversed."
      }
    },
    "27": {
      "nbr": 27,
      "value": "Which of the following interface declarations will still compile if\n@FunctionalInterface is applied to each? (Choose two.)\ninterface Dog {\ndefault void drink() {}\nvoid play();\n}\ninterface Astra extends Dog {\nprivate static int eat() { return 1; }\nvoid fetch();\n}\ninterface Webby extends Dog {\nabstract void play();\ndefault void rest() {}\nabstract String toString();\n}\ninterface KC {}\ninterface Georgette extends Dog {\nint intelligence = 5;\nvoid jump();\n}",
      "responses": [{
        "code": "A",
        "value": "Dog"
      }, {
        "code": "B",
        "value": "KC"
      }, {
        "code": "C",
        "value": "Georgette"
      }, {
        "code": "D",
        "value": "Webby"
      }, {
        "code": "E",
        "value": "Astra"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D"
        ],
        "explanation": "27. A,D. To correctly apply the @FunctionalInterface annotation, the\ninterface must pass the single abstract method test. Also, note that none of\nthe default or static methods contributes to the abstract method count.\nDog contains a single abstract method play(), so it will compile, making\noption A correct. Webby extends Dog with the same abstract method as Dog.\nIt also declares toString(), but since this is inherited from\njava.lang.Object, it does not count as an abstract method. Therefore,\nWebby passes the single abstract method test for functional interfaces,\nmaking option D correct. Astra is incorrect because it contains two abstract\nmethods, play() and fetch(). KC is incorrect because it does not extend\nDog and does not contain any abstract methods. Finally, Georgette is\nincorrect because it contains two abstract methods, play() and jump()."
      }
    },
    "28": {
      "nbr": 28,
      "value": "How many lines of the following declarations contain a compiler error?\nimport java.lang.annotation.*;\nenum Colors { RED, BLUE, GREEN }\n@Documented\npublic @interface Bouncy {\nint value();\nColors color() default Colors.RED;\ndouble size();\n}\n@Bouncy(999, size=10.0) class Trampoline {}",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "28. B. The declaration of Colors and Bouncy compile without issue. The\ndeclaration of Trampoline does not compile, though. The Bouncy\nannotation has two required elements, value() and size(), so the name of\nthe element value cannot be dropped. For this reason, option B is correct."
      }
    },
    "29": {
      "nbr": 29,
      "value": "Fill in the blanks: The __________ annotation allows annotations from a\nsuperclass to be applied to a subclass, while the __________ annotation\ndetermines whether annotations are present in generated Javadoc. (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "@Retention in the first blank"
      }, {
        "code": "B",
        "value": "@Inherited in the first blank"
      }, {
        "code": "C",
        "value": "@Subclass in the first blank"
      }, {
        "code": "D",
        "value": "@Javadoc in the second blank"
      }, {
        "code": "E",
        "value": "@Retention in the second blank"
      }, {
        "code": "F",
        "value": "@Documented in the second blank"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "29. B,F. The @Inherited annotation determines whether annotations applied\nto a supertype are applied to its subtypes, while the @Documented annotation\nallows annotations to be included in generated Javadoc. For these reasons,\noptions B and F are correct."
      }
    },
    "30": {
      "nbr": 30,
      "value": "Fill in the blank with the correct annotation usage that allows the code to\ncompile without any warnings.\n@Deprecated(since=\"5.0\")\npublic class ProjectPlanner<T> {\nProjectPlanner create(T t) { return this; }\n}\n@SuppressWarnings(___________________)\nclass SystemPlanner {\nProjectPlanner planner = new\nProjectPlanner().create(\"TPS\");\n}",
      "responses": [{
        "code": "A",
        "value": "value=ignoreAll"
      }, {
        "code": "B",
        "value": "value=\"deprecation\",\"unchecked\""
      }, {
        "code": "C",
        "value": "\"unchecked\",\"deprecation\""
      }, {
        "code": "D",
        "value": "{\"deprecation\",\"unchecked\"}"
      }, {
        "code": "E",
        "value": "\"deprecation\""
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "30. D. The SystemPlanner class compiles although it contains two warnings.\nFirst, the ProjectPlanner class is used, which is deprecated. Second, the\ncreate() method uses an unchecked/unsafe operation taking a String for\nthe generic type. For this reason, both unchecked and deprecation options\nare required for the code to compile without any warnings. Option D uses\nthe correct format for passing an array to an annotation. Note that\nignoreAll is not a known parameter that the JVM accepts."
      }
    }
  }
}, {
  "name": "Practice Exam 1",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "What is the result of executing the following method?\npublic static void main(String… args) {\nString name = \"Desiree\";\nint _number = 694;\nboolean profit$$$;\nSystem.out.println(name + \" won. \"\n+ _number + \" profit? \" + profit$$$);\n}",
      "responses": [{
        "code": "A",
        "value": "The declaration of name does not compile."
      }, {
        "code": "B",
        "value": "The declaration of _number does not compile."
      }, {
        "code": "C",
        "value": "The declaration of profit$$$ does not compile."
      }, {
        "code": "D",
        "value": "The println() statement does not compile."
      }, {
        "code": "E",
        "value": "The code compiles and runs successfully."
      }, {
        "code": "F",
        "value": "The code compiles and throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "1. D. Variables are allowed to start with an underscore and are allowed to\ncontain a $. Therefore, all the variable declarations compile, making options\nA, B, and C incorrect. However, the println() refers to the uninitialized\nlocal boolean. Since local variables are not automatically initialized, the\ncode does not compile, and option D is correct."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Which statements about try‐with‐resources are true? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Any resource used must implement Closeable."
      }, {
        "code": "B",
        "value": "If more than one resource is used, then the order in which they are\nclosed is the reverse of the order in which they were created."
      }, {
        "code": "C",
        "value": "If the try block and close() method both throw an exception, the one\nthrown by the try block is suppressed."
      }, {
        "code": "D",
        "value": "Neither a catch nor a finally block is required."
      }, {
        "code": "E",
        "value": "The close() method of the resources must throw a checked exception."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "2. B,D. The try‐with‐resources statement requires resources that implement\nAutoCloseable. While Closeable extends AutoCloseable, it is certainly\npossible to have a class that implements AutoCloseable and works with\ntry‐with‐resources but does not implement Closeable, making option A\nincorrect. Option B is correct and a valid statement about how resources are\nclosed in try‐with‐resources statements. Option C is incorrect because the\nexception in the try block is reported to the caller, while the exception in\nthe close() method is suppressed. Option D is the other correct answer\nbecause neither catch nor finally is required when try‐with‐resources is\nused. Lastly, option E is incorrect. While the AutoCloseable interface does\ndefine a close() method that throws a checked exception, classes that\nimplement this method are free to drop the checked exception, per the rules\nof overriding methods."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Bill wants to create a program that reads all of the lines of all of his books\nusing NIO.2. Unfortunately, Bill may have made a few mistakes writing his\nprogram. How many lines of the following class contain compilation\nerrors?\n1: package bookworm;\n2: import java.io.*;\n3: import java.nio.file.*;\n4: public class ReadEverything {\n5: public void readFile(Path p) {\n6: try {\n7: Files.readAllLines(p)\n8: .parallel()\n9: .forEach(System.out::println);\n10: } catch (Exception e) {}\n11: }\n12: public void read(Path directory) throws Exception {\n13: Files.walk(directory)\n14: .filter(p -> File.isRegularFile(p))\n15: .forEach(x -> readFile(x));\n16: }\n17: public static void main(String[] b) throws\nIOException {\n18: Path p = Path.get(\"collection\");\n19: new ReadEverything().read(p);\n20: }\n21: }",
      "responses": [{
        "code": "A",
        "value": "None. Bill's implementation is correct."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "Five."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "3. E. The code does contain compilation errors, so option A is incorrect. The\nfirst is on line 8. The readAllLines() method returns a List<String>, not\na Stream<String>. While parallelStream() is allowed on a Collection,\nparallel() is not. Next, line 14 does not compile because of an invalid\nmethod call. The correct NIO.2 method call is Files.isRegularFile(),\nnot File.isRegularFile(), since the legacy File class does not have such\na method. Line 18 contains a similar error. Path is an interface, not a class,\nwith the correct call being Paths.get(). Lastly, line 19 does not compile\nbecause the read() method throws Exception, which is not caught or\nhandled by the main() method. For these four reasons, option E is the\ncorrect answer."
      }
    },
    "4": {
      "nbr": 4,
      "value": "Which of the following is a valid code comment in Java? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "/** Insert */ in next method **/"
      }, {
        "code": "B",
        "value": "/****** Find the kitty cat */"
      }, {
        "code": "C",
        "value": "// Is this a bug?"
      }, {
        "code": "D",
        "value": "$ Begin method ‐ performStart() $"
      }, {
        "code": "E",
        "value": "/*** TODO: Call grandma ***/"
      }, {
        "code": "F",
        "value": "# Updated code by Patti"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "E"
        ],
        "explanation": "4. B,C,E. Java supports three types of comments: single‐line (//), multi‐line\n(/* */), and Javadoc (/** **/), making options B, C, and E correct.\nOption A contains a */ in the middle of the expected comment, making the\npart after the comment Insert */ invalid. Option D is incorrect because a\ndollar sign ($) is not a valid comment in Java. Finally, the hash (#) is not a\ncomment character in Java, so option F is incorrect."
      }
    },
    "5": {
      "nbr": 5,
      "value": "What is the minimum number of requires directives that need to be\nremoved to break the cyclic dependency?\nmodule com.animal {\nexports com.animal;\nrequires com.plant;\n}\nmodule com.plant {\nexports com.plant;\nrequires com.animal;\n}\nmodule com.worm {\nexports com.worm;\nrequires com.animal;\nrequires com.plant;\n}\nmodule com.hedgehog {\nexports com.hedgehog;\nrequires com.animal;\nrequires com.plant;\n}",
      "responses": [{
        "code": "A",
        "value": "None, there is no cyclic dependency"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "3"
      }, {
        "code": "E",
        "value": "4"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "5. B. Modules have a cyclic dependency when they depend on each other. In\nthis example, com.animal and com.plant depend on each other. The other\ntwo modules depend on com.animal and com.plant but do not participate\nin the cycle. If the requires directive in either com.animal or com.plant\nwere removed, we would no longer have a cyclic dependency. Since only\none directive needs to be removed, option B is correct."
      }
    },
    "6": {
      "nbr": 6,
      "value": "What is the result of the following?\npackage calendar;\npublic class Seasons {\npublic static void seasons(String… names) {\nvar v = names[1].length(); // s1\nSystem.out.println(names[v]); // s2\n}\npublic static void main(String[] args) {\nseasons(\"Summer\", \"Fall\", \"Winter\", \"Spring\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Fall"
      }, {
        "code": "B",
        "value": "Spring"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code throws an exception on line s1."
      }, {
        "code": "E",
        "value": "The code throws an exception on line s2."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "6. E. The code does compile. Line s1 is a bit tricky because length is used\nfor an array and length() is used for a String. Line s1 stores the length of\nFall in a variable, which is 4. Line s2 throws an\nArrayIndexOutOfBoundsException because 4 is not a valid index for an\narray with four elements. Remember that indices start counting with zero.\nTherefore, option E is correct."
      }
    },
    "7": {
      "nbr": 7,
      "value": "What is the output of the following when run as java EchoFirst.java\nseed flower plant?\nimport java.util.*;\npublic class EchoFirst {\npublic static void main(String[] args) {\nvar result = Arrays.binarySearch(args, args[0]);\nSystem.out.println(result);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "F",
        "value": "The output is not guaranteed."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "7. F. The array is not sorted. It does not meet the pre‐condition for a binary\nsearch. Therefore, the output is not guaranteed and the answer is option F."
      }
    },
    "8": {
      "nbr": 8,
      "value": "Which method can fill in the blank that would cause the program to\nconsistently print Tie! ten times?\nimport java.util.concurrent.*;\nimport java.util.concurrent.locks.*;\npublic class TieShoes {\nprivate Lock shoes = new ReentrantLock();\npublic void tie() {\ntry {\nif (shoes.__________________) {\nSystem.out.println(\"Tie!\");\nshoes.unlock();\n}\n} catch (Exception e) {}\n}\npublic static void main(String… unused) {\nvar gate = new TieShoes();\nfor (int i = 0; i < 10; i++) {\nnew Thread(() -> gate.tie()).start();\n}\n} }",
      "responses": [{
        "code": "A",
        "value": "lock()"
      }, {
        "code": "B",
        "value": "tryLock()"
      }, {
        "code": "C",
        "value": "tryLock(10)"
      }, {
        "code": "D",
        "value": "The code does not compile regardless of what is placed in the blank."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "8. E. Option A is incorrect because the lock() method does not return a\nboolean value. Option B allows the class to compile (making option D\nincorrect), but is not guaranteed to print Tie! ten times. Depending on the\nthread ordering, it may print the value 1 to 10 times. Option C is incorrect\nbecause tryLock() with a time value also requires a TimeUnit parameter.\nFor these reasons, option E is the correct answer."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Given the following three class declarations, which sets of access modifiers\ncan be inserted, in order, into the following blank lines that would allow all\nof the classes to compile? (Choose three.)\n// Alarm.java\npackage wake;\npublic class Alarm {\n________ static int clock;\n________ long getTime() {return clock;}\n}\n// Coffee.java\npackage wake;\npublic class Coffee {\nprivate boolean bringCoffee() {\nreturn new Alarm().clock<10;\n}\n}\n// Snooze.java\npackage sleep;\npublic class Snooze extends wake.Alarm {\nprivate boolean checkTime() { return getTime()>10;}\n}",
      "responses": [{
        "code": "A",
        "value": "package‐private (blank) and package‐private (blank)"
      }, {
        "code": "B",
        "value": "package‐private (blank) and protected"
      }, {
        "code": "C",
        "value": "protected and package‐private (blank)"
      }, {
        "code": "D",
        "value": "protected and protected"
      }, {
        "code": "E",
        "value": "private and public"
      }, {
        "code": "F",
        "value": "public and public"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D",
          "F"
        ],
        "explanation": "9. B,D,F. The clock variable is accessed by a class in the same package;\ntherefore, it requires package‐private or less restrictive access (protected\nand public). The getTime() method is accessed by a subclass in a different\npackage; therefore, it requires protected or less restrictive access (public).\nOptions B, D, and F conform to these rules, making them the correct\nanswer. Options A and C cause the Snooze class to fail to compile because\nthe getTime() method is not accessible outside the package, even though\nSnooze is a subclass of Alarm. Option E causes the Coffee class to fail to\ncompile because the clock variable is only visible within the Alarm class."
      }
    },
    "10": {
      "nbr": 10,
      "value": "What is the result of the following?\nvar dice = new TreeSet<Integer>();\ndice.add(6);\ndice.add(6);\ndice.add(4);\ndice.stream()\n.filter(n -> n != 4)\n.forEach(System.out::println)\n.count();",
      "responses": [{
        "code": "A",
        "value": "It prints just one line."
      }, {
        "code": "B",
        "value": "It prints one line and then the number 3."
      }, {
        "code": "C",
        "value": "There is no output."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "10. D. This code attempts to use two terminal operations, forEach() and\ncount(). Only one terminal operation is allowed, so the code does not\ncompile, and option D is correct. The author of this code probably intended\nto use peek() instead of forEach(). With this change, the answer would be\noption A."
      }
    },
    "11": {
      "nbr": 11,
      "value": "Suppose the pandas table has one row with the name Mei Xiang and the\nlocation DC. What does the following code output?\nvar url = \"jdbc:derby:pandas\";\nvar sql = \"SELECT name FROM pandas WHERE location = ?\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.prepareStatement(sql); // s1\nstmt.setString(1, \"DC\");\nvar rs = stmt.executeQuery()) {\nif (rs.next())\nSystem.out.println(rs.getString(\"name\")); // s2\nelse\nSystem.out.println(\"No match\");\n}",
      "responses": [{
        "code": "A",
        "value": "Mei Xiang"
      }, {
        "code": "B",
        "value": "No match"
      }, {
        "code": "C",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "E",
        "value": "The code does not compile due to another line."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "11. E. All code in a try‐with‐resources declaration must implement Closeable\nor AutoCloseable. The call to stmt.setString() does not meet that\ncriteria. Since it doesn't compile, option E is the answer."
      }
    },
    "12": {
      "nbr": 12,
      "value": "Which of the following can fill in the blank to print out just the number\n161?\nimport java.util.*;\nimport java.util.stream.*;\nclass Runner {\nprivate int numberMinutes;\npublic Runner(int n) {\nnumberMinutes = n;\n}\npublic int getNumberMinutes() {\nreturn numberMinutes;\n} }\npublic class Marathon {\npublic static void main(String[] args) {\nvar match = Optional.ofNullable(161); // line z\nvar runners = Stream.of(new Runner(183),\nnew Runner(161), new Runner(201));\nvar opt = runners___________________________;\n} }",
      "responses": [{
        "code": "A",
        "value": ".map(Runner::getNumberMinutes)\n.filter(m -> match.get().equals(m))\n.peek(System.out::println)\n.count()"
      }, {
        "code": "B",
        "value": ".map(Runner::getNumberMinutes)\n.filter(m -> match.get().equals(m))\n.peek(System.out::println)\n.max()"
      }, {
        "code": "C",
        "value": ".map(Runner::getNumberMinutes)\n.peek(System.out::println)\n.filter(m -> match.get().equals(m))\n.count()"
      }, {
        "code": "D",
        "value": ".map(Runner::getNumberMinutes)\n.peek(System.out::println)\n.filter(m -> match.get().equals(m))\n.max()"
      }, {
        "code": "E",
        "value": "The code does not compile due to line z."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "12. A. Option E is incorrect since the ofNullable() method creates an\nOptional whether or not the parameter is null. Options B and D are\nincorrect because max() takes a parameter to specify the logic for\ndetermining the order. Both options A and C compile. The order of the\npipeline methods matter here. Option C prints all three numbers since the\nfilter() operation happens after the peek(). Option A is correct as the\nmethods are in the correct order."
      }
    },
    "13": {
      "nbr": 13,
      "value": "Which of the following exceptions do not need to be handled or declared by\nthe method in which they are thrown? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "FileNotFoundException"
      }, {
        "code": "B",
        "value": "ArithmeticException"
      }, {
        "code": "C",
        "value": "IOException"
      }, {
        "code": "D",
        "value": "BigProblem"
      }, {
        "code": "E",
        "value": "IllegalArgumentException"
      }, {
        "code": "F",
        "value": "RuntimeException"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E",
          "F"
        ],
        "explanation": "13. B,E,F. Unchecked exceptions inherit the RuntimeException class and are\nnot required to be caught in the methods where they are declared. Since\nArithmeticException and IllegalArgumentException extend\nRuntimeException, they are included as unchecked exceptions, making\noptions B, E, and F correct. FileNotFoundException and IOException are\nchecked exceptions, which must be handled or declared, making options A\nand C incorrect. Option D is also incorrect, as it is not the name of an\nexception class in Java."
      }
    },
    "14": {
      "nbr": 14,
      "value": "What is the output of the following application?\npackage homework;\nimport java.util.*;\nimport java.util.stream.*;\npublic class QuickSolution {\npublic static int findFast(Stream<Integer> s) {\nreturn s.findAny().get();\n}\npublic static int findSlow(Stream<Integer> s) {\nreturn s.parallel().findFirst().get();\n}\npublic static void main(String[] pencil) {\nvar s1 = List.of(1,2,3,4,5).stream();\nvar s2 = List.of(1,2,3,4,5).stream();\nint val1 = findFast(s1);\nint val2 = findSlow(s2);\nSystem.out.print(val1+\" \"+val2);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "1 1"
      }, {
        "code": "B",
        "value": "3 1"
      }, {
        "code": "C",
        "value": "The answer cannot be determined until runtime."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "14. C. The class compiles and runs without issue, so options D and E are\nincorrect. The result of findSlow() is deterministic and always 1. The\nfindFirst() method returns the first element in an ordered stream, whether\nit be serial or parallel. This makes it a costly operation for a parallel stream,\nsince the stream has to be accessed in a serial manner. On the other hand,\nthe result of findFast() is unknown until runtime. The findAny() method\nmay return the first element or any element in the stream, even on serial\nstreams. Since both 1 1 and 3 1 are possible outputs of this program, the\nanswer cannot be determined until runtime, and option C is the correct\nanswer."
      }
    },
    "15": {
      "nbr": 15,
      "value": "What is the result of the following?\nimport java.time.*;\nimport java.time.format.*;\npublic class PiDay {\npublic static void main(String[] args) {\nLocalDateTime pi = LocalDateTime.of(2017, 3, 14, 1,\n59);\nDateTimeFormatter formatter = DateTimeFormatter\n.ofPattern(\"m.ddhh'MM'\");\nSystem.out.print(formatter.format(pi));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "3.011459"
      }, {
        "code": "B",
        "value": "3.1401MM"
      }, {
        "code": "C",
        "value": "59.011459"
      }, {
        "code": "D",
        "value": "59.1401MM"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "15. D. The code compiles and runs without issue. The m symbol represents\nminute, so 59 is the first value printed, followed by a period. The next\nsymbols ddhh represent day and hour in 2‐digit formats, so 1401 is printed.\nFinally, 'MM' represents an escaped string using single quotes, so it is\nprinted just as MM. For these reasons, option D is correct."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Which is part of the module service and has a requires directive?",
      "responses": [{
        "code": "A",
        "value": "Consumer"
      }, {
        "code": "B",
        "value": "Service locator"
      }, {
        "code": "C",
        "value": "Service provider"
      }, {
        "code": "D",
        "value": "Service provider interface"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "16. B. Only the service locator and service provider interface are part of the\nservice. The service locator has a requires directive, and the service\nprovider interface has an exports directive, which matches option B."
      }
    },
    "17": {
      "nbr": 17,
      "value": "What option names are equivalent to ‐p and ‐cp on the javac command?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "‐‐module‐path and ‐classpath"
      }, {
        "code": "B",
        "value": "‐‐module‐path and ‐class‐path"
      }, {
        "code": "C",
        "value": "‐‐module‐path and ‐‐class‐path"
      }, {
        "code": "D",
        "value": "‐‐path and ‐classpath"
      }, {
        "code": "E",
        "value": "‐‐path and ‐class‐path"
      }, {
        "code": "F",
        "value": "‐‐path and ‐‐class‐path"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C"
        ],
        "explanation": "17. A,C. The javac command uses ‐p and ‐‐module‐path to supply the\nmodule path. There are two valid long forms of the classpath option:\n‐classpath and ‐‐class‐path. Options A and C match these."
      }
    },
    "18": {
      "nbr": 18,
      "value": "What is the result of the following when called as java Binary.java?\nimport java.util.*;\npublic class Binary {\npublic static void main(String[] args) {\nargs = new String[] {\"0\", \"1\", \"01\", \"10\" };\nArrays.sort(args);\nSystem.out.println(Arrays.toString(args));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "[]"
      }, {
        "code": "B",
        "value": "[0, 01, 1, 10]"
      }, {
        "code": "C",
        "value": "[0, 01, 10, 1]"
      }, {
        "code": "D",
        "value": "[0, 1, 01, 10]"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "18. B. While no arguments are passed from the command line, this doesn't\nmatter because the main() method redefines the args array. Remember that\nString values sort alphabetically rather than by number. Therefore, 01 sorts\nbefore 1, and option B is correct."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What is the output of the following application?\npackage music;\ninterface DoubleBass {\nvoid strum();\ndefault int getVolume() {return 5;}\n}\ninterface BassGuitar {\nvoid strum();\ndefault int getVolume() {return 10;}\n}\nabstract class ElectricBass implements DoubleBass,\nBassGuitar {\n@Override public void strum() {System.out.print(\"X\");}\n}\npublic class RockBand {\npublic static void main(String[] strings) {\nfinal class MyElectricBass extends ElectricBass {\npublic int getVolume() {return 30;}\npublic void strum() {System.out.print(\"Y\");}\n}\n} }",
      "responses": [{
        "code": "A",
        "value": "X"
      }, {
        "code": "B",
        "value": "Y"
      }, {
        "code": "C",
        "value": "The application completes without printing anything."
      }, {
        "code": "D",
        "value": "ElectricBass is the first class to not compile."
      }, {
        "code": "E",
        "value": "RockBand is the first class to not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "19. D. The application does not compile, so options A, B, and C are incorrect.\nThe ElectricBass class does not compile, since it inherits two default\nmethods with the same signature. Even though the class is marked\nabstract, it still must override this default method. Since ElectricBass\nfails to do so, option D is correct. If the ElectricBass class did correctly\noverride the getVolume() method, then the rest of the code would compile\nwithout issue. In this case, there would be nothing printed at runtime. The\nmain() method just declares a local inner class but does not actually use it."
      }
    },
    "20": {
      "nbr": 20,
      "value": "What does the following do?\npublic class Shoot {\ninterface Target {\nboolean needToAim(double angle);\n}\nstatic void prepare(double angle, Target t) {\nboolean ready = t.needToAim(angle); // k1\nSystem.out.println(ready);\n}\npublic static void main(String[] args) {\nprepare(45, d => d> 5 || d < -5); // k2\n}\n}",
      "responses": [{
        "code": "A",
        "value": "It prints true."
      }, {
        "code": "B",
        "value": "It prints false."
      }, {
        "code": "C",
        "value": "It doesn't compile due to line k1."
      }, {
        "code": "D",
        "value": "It doesn't compile due to line k2."
      }, {
        "code": "E",
        "value": "It doesn't compile due to another line."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "20. D. The lambda syntax is incorrect. It should be ‐>, not =>. Therefore,\noption D is correct. If this was fixed, option A would be correct."
      }
    },
    "21": {
      "nbr": 21,
      "value": "Which of the following lambda expressions can be passed to a method that\ntakes IntUnaryOperator as an argument? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "v ‐> {System.out.print(\"Hello!\"); return 2%1;}"
      }, {
        "code": "B",
        "value": "(Integer w) ‐> w.intValue()"
      }, {
        "code": "C",
        "value": "(int j) ‐> (int) 30L"
      }, {
        "code": "D",
        "value": "(int q) ‐> q / 3.1"
      }, {
        "code": "E",
        "value": "(long x) ‐> (int) x"
      }, {
        "code": "F",
        "value": "z ‐> z"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "F"
        ],
        "explanation": "21. A,C,F. The IntUnaryOperator takes an int value and returns an int\nvalue. Options B and E are incorrect because the parameter types, Integer\nand long, respectively, are not int. Option B is incorrect because unboxing\ncan be used for expressions, but it cannot be used for parameter matching.\nOption D is incorrect because dividing an int by a double value 3.1 results\nin q/3.1 being a double value, which cannot be converted to int without\nan explicit cast. Option E is incorrect because the parameter type must\nmatch, and long is not the same as int. The rest of the lambda expressions\nare valid, since they correctly take an int value and return an int value."
      }
    },
    "22": {
      "nbr": 22,
      "value": "How many of these module declarations are valid?\nmodule com.apple { exports com.apple; }\nmodule com.4apple { requires com.apple;}\nmodule com.apple4 { declares com.apple; }\nmodule com.apple-four { }\nmodule com.apple$ {}",
      "responses": [{
        "code": "A",
        "value": "None."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "Five."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "22. C. This question is tricky because it mixes testing valid identifier names\nwith module concepts. The com.apple module is valid and demonstrates a\nsimple module. Additionally, the com.apple$ module is valid since $\ncharacters are permitted in identifier names. The com.4apple and\ncom.apple‐four modules are invalid because identifier or identifier\nsegments may not start with a digit nor contain a dash. The com.apple4\nmodule is invalid because declares is not a valid module directive. Since\nonly two are valid, option C is the answer."
      }
    },
    "23": {
      "nbr": 23,
      "value": "What is the output of the following application?\npackage tax;\npublic class Accountant {\npublic void doTaxes() throws Throwable {\ntry {\nthrow new NumberFormatException();\n} catch (ClassCastException\n| ArithmeticException e) { // p1\nSystem.out.println(\"Math\");\n} catch (IllegalArgumentException | Exception f) { //\np2\nSystem.out.println(\"Unknown\");\n}\n}\npublic static void main(String[] numbers) throws\nThrowable {\ntry {\nnew Accountant().doTaxes();\n} finally {\nSystem.out.println(\"Done!\");\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Math"
      }, {
        "code": "B",
        "value": "Unknown"
      }, {
        "code": "C",
        "value": "Unknown followed by Done!"
      }, {
        "code": "D",
        "value": "The code does not compile due to line p1."
      }, {
        "code": "E",
        "value": "The code does not compile due to line p2."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "23. E. The second catch block on line p2 does not compile. Since\nIllegalArgumentException is a subclass of Exception, they cannot be\nused in the same multi‐catch block, since it is redundant. For this reason,\noption E is correct. If the redundant exception class was removed from line\np2, then the rest of the program would compile and print Unknown followed\nby Done! at runtime."
      }
    },
    "24": {
      "nbr": 24,
      "value": "What is the result of compiling and running the following application?\npackage names;\nimport java.util.*;\nimport java.util.function.*;\ninterface ApplyFilter {\nvoid filter(List<String> input);\n}\npublic class FilterBobs {\nstatic Function<String,String> first = s ->\n{System.out.println(s); return s;};\nstatic Predicate second = t ->\n\"bob\".equalsIgnoreCase(t);\npublic void process(ApplyFilter a, List<String> list) {\na.filter(list);\n}\npublic static void main(String[] contestants) {\nfinal List<String> people = new ArrayList<>();\npeople.add(\"Bob\");\npeople.add(\"bob\");\npeople.add(\"Jennifer\");\npeople.add(\"Samantha\");\nfinal FilterBobs f = new FilterBobs();\nf.process(q -> {\nq.removeIf(second);\nq.forEach(first);\n}, people);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "It prints two lines."
      }, {
        "code": "B",
        "value": "It prints three lines."
      }, {
        "code": "C",
        "value": "One line of code does not compile."
      }, {
        "code": "D",
        "value": "Two lines of code do not compile."
      }, {
        "code": "E",
        "value": "Three lines of code do not compile."
      }, {
        "code": "F",
        "value": "The code compiles but prints an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "24. D. The code does not compile, so options A, B, and F are incorrect. The\nfirst compilation error is in the declaration of the lambda expression for\nsecond. It does not use a generic type, which means t is of type Object.\nSince equalsIgnoreCase() expects a String as a parameter, the lambda\nexpression does not compile. The second compilation issue is in the lambda\nexpression in the main() method. Notice that process() takes an\nApplyFilter instance, and ApplyFilter is a functional interface that takes\na List<String> object. For this reason, q in this lambda expression is\ntreated as an instance of List<String>. The forEach() method defined in\nCollections requires a Consumer instance, not a Function, so the call\nq.forEach(first) does not compile. For these two reasons, option D is the\ncorrect answer, since the rest of the code compiles without issue."
      }
    },
    "25": {
      "nbr": 25,
      "value": "How many of these variables are true?\nvar lol = \"lol\";\nvar smiley = lol.toUpperCase() == lol;\nvar smirk = lol.toUpperCase() == lol.toUpperCase();\nvar blush = lol.toUpperCase().equals(lol);\nvar cool = lol.toUpperCase().equals(lol.toUpperCase());\nvar wink = lol.toUpperCase().equalsIgnoreCase(lol);\nvar yawn = lol.toUpperCase().equalsIgnoreCase(\nlol.toUpperCase());",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "Three."
      }, {
        "code": "D",
        "value": "Four."
      }, {
        "code": "E",
        "value": "Five."
      }, {
        "code": "F",
        "value": "None. The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "25. C. The variables smiley and smirk are both false, since a String should\nbe compared with a method rather than ==, especially when not comparing\ntwo values from the string pool. The variable blush is also false because\none value is uppercase and the other is lowercase. The variable cool is true\nbecause both values are uppercase. Finally, the variables wink and yawn\nprint true because they don't look at the case. This makes option C the\nanswer."
      }
    },
    "26": {
      "nbr": 26,
      "value": "Let's say you are managing animals at a veterinary hospital using a new\nsoftware application. Which metadata attributes would be best managed\nwith an annotation? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "The number of animals that are checked at any given time"
      }, {
        "code": "B",
        "value": "The maximum number of the animals the hospital can hold"
      }, {
        "code": "C",
        "value": "The feeding schedule for each animal checked in"
      }, {
        "code": "D",
        "value": "The name of every veterinarian in the building"
      }, {
        "code": "E",
        "value": "Whether or not the hospital is capable of handling emergencies"
      }, {
        "code": "F",
        "value": "The location of each animal within the hospital"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "26. B,E. Annotations define metadata that generally do not change. Options B\nand E define metadata that would not likely change without major changes\nto the hospital. Options A, C, D, and F define attributes that would likely\nchange numerous times throughout the day and would be better stored in a\ndatabase or some other data structure."
      }
    },
    "27": {
      "nbr": 27,
      "value": "What is the output of the following program?\npublic class Ghost {\nprivate final String name;\npublic Ghost() {\nthis(null);\nthis.name = \"Casper\";\n}\npublic Ghost(String n) {\nname = \"Boo\";\n}\npublic static void main(String[] sound) {\nvar d = new Ghost(\"Space\");\nSystem.out.println(d.name);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Casper"
      }, {
        "code": "B",
        "value": "Boo"
      }, {
        "code": "C",
        "value": "Space"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The answer cannot be determined with the information given."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "27. D. The name instance variable is marked final and must be assigned a\nvalue at most once when it is declared, by an instance initializer, or by a\nconstructor. The no‐argument constructor calls the Ghost(String)\nconstructor, which assigns a value of \"Boo\" to name. The process returns\nand the constructor assigns a value of \"Casper\" to name. Since name is\nfinal, it cannot be assigned a value twice. The compiler detects this error,\nmaking option D the correct answer."
      }
    },
    "28": {
      "nbr": 28,
      "value": "How many of the following variable declarations compile?\n1: import java.util.*;\n2: public class ListOfList {\n3: public void create() {\n4: List<?> n = new ArrayList<>();\n5: List<? extends RuntimeException> o\n6: = new ArrayList<Exception>();\n7: List<? super RuntimeException> p\n8: = new ArrayList<Exception>();\n9: List<T> q = new ArrayList<?>();\n10: List<T extends RuntimeException> r\n11: = new ArrayList<Exception>();\n12: List<T super RuntimeException> s\n13: = new ArrayList<Exception>();\n14: } }",
      "responses": [{
        "code": "A",
        "value": "None."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "Five."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "28. C. Lines 9–13 do not compile because neither the class nor method defines\na generic type T. The declaration on lines 5–6 does not compile because?\nextends RuntimeException cannot have a broader type. This leaves us\nwith two declarations that do compile, making option C the correct answer.\nLine 4 compiles, since any type of generic list can go in List<?>. The\ndeclaration on lines 7–8 also compiles because ? super RuntimeException\ndoes allow a broader exception type."
      }
    },
    "29": {
      "nbr": 29,
      "value": "What is the output of the following application?\npackage fly;\npublic class Helicopter {\npublic int adjustPropellers(int length, String[] type) {\nlength++;\ntype[0] = \"LONG\";\nreturn length;\n}\npublic static void main(String[] climb) {\nfinal var h = new Helicopter();\nvar length = 5;\nvar type = new String[1];\nlength = h.adjustPropellers(length, type);\nSystem.out.print(length+\",\"+type[0]);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "5,LONG"
      }, {
        "code": "B",
        "value": "6,LONG"
      }, {
        "code": "C",
        "value": "5,null"
      }, {
        "code": "D",
        "value": "6,null"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "29. B. The application compiles and runs without issue, so options E and F are\nincorrect. Java uses pass‐by‐value, so even though the change to length in\nthe first line of the adjustPropellers() method does not change the value\nin the main() method, the value is later returned by the method and used to\nreassign the length value. The result is that length is assigned a value of 6,\ndue to it being returned by the method. For the second parameter, while the\nString[] reference cannot be modified to impact the reference in the\ncalling method, the data in it can be. Therefore, the value of the first\nelement is set to LONG, resulting in an output of 6,LONG, making option B\nthe correct answer."
      }
    },
    "30": {
      "nbr": 30,
      "value": "Fill in the blank with code that belongs in a service provider.\nString cheese = ServiceLoader.load(Mouse.class)\n.stream ()\n.map(______________)\n.map(Mouse::favoriteFood)\n.findFirst() .orElse(\"\");",
      "responses": [{
        "code": "A",
        "value": "Mouse.get()"
      }, {
        "code": "B",
        "value": "Mouse::get"
      }, {
        "code": "C",
        "value": "Provider.get()"
      }, {
        "code": "D",
        "value": "Provider::get"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "30. E. The service provider does not have code to look up the service, making\noption E correct."
      }
    },
    "31": {
      "nbr": 31,
      "value": "Which lines can fill in the blank that would allow the code to compile?\n(Choose two.)\nabstract public class Exam {\nboolean pass;\nprotected abstract boolean passed();\nclass JavaProgrammerCert extends Exam {\nprivate Exam part1;\nprivate Exam part2;\n______________________________\n}\n}",
      "responses": [{
        "code": "A",
        "value": "boolean passed() { return part1.pass && part2.pass; }"
      }, {
        "code": "B",
        "value": "boolean passed() { return part1.passed() && part2.passed();\n}"
      }, {
        "code": "C",
        "value": "private boolean passed() { return super.passed(); }"
      }, {
        "code": "D",
        "value": "public boolean passed() { return part1.passed() &&\npart2.passed(); }"
      }, {
        "code": "E",
        "value": "public boolean passed() { return part1.pass && part2.pass;\n}"
      }, {
        "code": "F",
        "value": "public boolean passed() { return super.passed(); }"
      }
      ],
      "answer": {
        "codes": [
          "D",
          "E"
        ],
        "explanation": "31. D,E. Each option presents a potential override of the passed() method,\nsince the method signature is the same. Options A, B, and C are incorrect\nbecause the method reduces the visibility of the protected method version\ndeclared in the parent class. Option F is incorrect, as the parent version of\npassed() is abstract and cannot be invoked. That leaves options D and E\nas valid overrides of this method."
      }
    },
    "32": {
      "nbr": 32,
      "value": "Which of the following are valid lambda expressions? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "() ‐> {}"
      }, {
        "code": "B",
        "value": "(Double adder) ‐> {int y; System.out.print(adder); return\nadder;}"
      }, {
        "code": "C",
        "value": "(Long w) ‐> {Long w=5; return 5;}"
      }, {
        "code": "D",
        "value": "(int count, vote) ‐> count*vote"
      }, {
        "code": "E",
        "value": "dog ‐> dog"
      }, {
        "code": "F",
        "value": "name ‐> {name.toUpperCase()}"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "E"
        ],
        "explanation": "32. A,B,E. First, option A is a valid functional interface that matches the\nRunnable functional interface. Option B is also a valid lambda expression\nthat matches Function<Double,Double>, among other functional\ninterfaces. Option C is incorrect because the local variable w cannot be\ndeclared again in the lambda expression body, since it is already declared as\na lambda parameter. Option D is also incorrect. If the data type is specified\nfor one variable in a lambda expression, it must be specified for all\nvariables within the expression. Next, option E is correct because this\nlambda expression matches the UnaryOperator functional interface. Lastly,\noption F is incorrect. The statement name.toUpperCase() is missing a\nsemicolon (;) that is required to terminate the statement."
      }
    },
    "33": {
      "nbr": 33,
      "value": "How many lines of the following application contain compilation errors?\n1: package percussion;\n2:\n3: interface MakesNoise {}\n4: abstract class Instrument implements MakesNoise {\n5: public Instrument(int beats) {}\n6: public void play() {}\n7: }\n8: public class Drum extends Instrument {\n9: public void play(int count) {}\n10: public void concert() {\n11: super.play(5);\n12: }\n13: public static void main(String[] beats) {\n14: MakesNoise mn = new Drum();\n15: mn.concert();\n16: }\n17: }",
      "responses": [{
        "code": "A",
        "value": "The code compiles and runs without issue."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "33. D. The code definitely does not compile. The first problem with this code\nis that the Drum class is missing a constructor causing the class declaration\non line 8 to fail to compile. The default no‐argument constructor cannot be\ninserted if the superclass, Instrument, defines only constructors that take\narguments. The second problem with the code is that line 11 does not\ncompile, since it calls super.play(5), but the version of play() in the\nparent class does not take any arguments. Finally, line 15 does not compile.\nWhile mn may be a reference variable that points to a Drum() object, the\nconcert() method cannot be called unless it is explicitly cast back to a\nDrum reference. For these three reasons, the code does not compile, and\noption D is the correct answer."
      }
    },
    "34": {
      "nbr": 34,
      "value": "Given the Electricity annotation, how many lines of the Solar class\ncontain a compiler error?\n1: import java.lang.annotation.*;\n2: @Target(ElementType.METHOD)\n3: public @interface Electricity {\n4: int[] value() default 100;\n5: short type() default 1;\n6: }\n7: @Electricity() class Solar {\n8: @Electricity(2) @Electricity(0) void charge() {}\n9: @Electricity(value=9) void turnOn() {}\n10: @Electricity(6,5) void install() {}\n11: @Electricity(value=1,7) void turnOff() {}\n12: @Electricity(value=8) void storePower() {}\n13: }",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "Three."
      }, {
        "code": "D",
        "value": "Four."
      }, {
        "code": "E",
        "value": "Five."
      }, {
        "code": "F",
        "value": "Six."
      }, {
        "code": "G",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "34. D. Line 7 does not compile because the @Target annotation with the\nMETHOD value prohibits usage on a class. Line 8 does not compile because\nElectricity is not marked as a repeatable annotation. Lines 10 and 11 do\nnot compile because the braces, {}, are required around the list of elements.\nThe rest of the lines compile. Note that the value name is optional since\nthere are no required elements beyond the value() element."
      }
    },
    "35": {
      "nbr": 35,
      "value": "What is the output of the following application?\n1: interface HasHue {String getHue();}\n2: enum COLORS implements HasHue {\n3: red {\n4: public String getHue() {return \"FF0000\";}\n5: }, green {\n6: public String getHue() {return \"00FF00\";}\n7: }, blue {\n8: public String getHue() {return \"0000FF\";}\n9: }\n10: private COLORS() {}\n11: }\n12: class Book {\n13: static void main(String[] pencils) {}\n14: }\n15: final public class ColoringBook extends Book {\n16: final void paint(COLORS c) {\n17: System.out.print(\"Painting: \"+c.getHue());\n18: }\n19: final public static void main(String[] crayons) {\n20: new ColoringBook().paint(green);\n21: }\n22: }",
      "responses": [{
        "code": "A",
        "value": "Painting: 00FF00"
      }, {
        "code": "B",
        "value": "One line of code does not compile."
      }, {
        "code": "C",
        "value": "Two lines of code do not compile."
      }, {
        "code": "D",
        "value": "Three lines of code do not compile."
      }, {
        "code": "E",
        "value": "The code compiles but prints an exception at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "35. C. Line 10 does not compile because line 9 is missing a semicolon(;) at\nthe end of it. A semicolon is required after a list of enum values if the enum\ncontains anything besides the list of values. Line 20 does not compile\nbecause the enum name is missing before the enum value green. For these\ntwo reasons, option C is correct."
      }
    },
    "36": {
      "nbr": 36,
      "value": "What is the output of the following code snippet?\n11: Path x = Paths.get(\".\",\"song\",\"..\",\"/note\");\n12: Path y = Paths.get(\"/dance/move.txt\");\n13: x.normalize();\n14: System.out.println(x.resolve(y));\n15: System.out.println(y.resolve(x));",
      "responses": [{
        "code": "A",
        "value": "/./song/../note/dance/move.txt\n/dance/move.txt"
      }, {
        "code": "B",
        "value": "/dance/move.txt\n/dance/move.txt/note"
      }, {
        "code": "C",
        "value": "/dance/move.txt\n/dance/move.txt/./song/../note"
      }, {
        "code": "D",
        "value": "/note/dance/move.txt\n../dance/move.txt/song"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but an exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "36. C. Line 13 does not modify the value of x because Path is immutable and\nx is not reassigned to the new value. On line 14, the resolve() method is\ncalled using y as the input argument. If the parameter passed to the\nresolve() method is absolute, then that value is returned, leading the first\nprintln() method call to output /dance/move.txt. On line 15, the\nabsolute path is concatenated with the relative path, printing\n/dance/move.txt/./song/../note at runtime. For these reasons, option C\nis correct."
      }
    },
    "37": {
      "nbr": 37,
      "value": "What is the result of running the following program?\n1: package fun;\n2: public class Sudoku {\n3: static int[][] game;\n4:\n5: public static void main(String args[]) {\n6: game[3][3] = 6;\n7: Object[] obj = game;\n8: obj[3] = 'X';\n9: System.out.println(game[3][3]);\n10: }\n11: }",
      "responses": [{
        "code": "A",
        "value": "6"
      }, {
        "code": "B",
        "value": "X"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws a NullPointerException at runtime."
      }, {
        "code": "E",
        "value": "The code compiles but throws a different exception at runtime."
      }, {
        "code": "F",
        "value": "The output is not guaranteed."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "37. D. This question appears to ask you about involved array logic. Instead, it\nis checking to see if you remember that instance and class variables are\ninitialized to null. Line 6 throws a NullPointerException, making option\nD correct. If the array was initialized to int[4][4] or larger, then option E\nwould be correct because the code would throw an ArrayStoreException\non line 8."
      }
    },
    "38": {
      "nbr": 38,
      "value": "What is the output of the following?\nvar listing = new String[][] { { \"Book\", \"34.99\" },\n{ \"Game\", \"29.99\" }, { \"Pen\", \".99\" } };\nSystem.out.println(listing.length + \" \" +\nlisting[0].length);",
      "responses": [{
        "code": "A",
        "value": "2 2"
      }, {
        "code": "B",
        "value": "2 3"
      }, {
        "code": "C",
        "value": "3 2"
      }, {
        "code": "D",
        "value": "3 3"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "38. C. This array has three elements, making listing.length output 3. It so\nhappens that each element references an array of the same size. But the\ncode checks the first element and sees it is an array of size two, making the\nanswer option C."
      }
    },
    "39": {
      "nbr": 39,
      "value": "Which of the following are JDBC interfaces in the java.sql package?",
      "responses": [{
        "code": "A",
        "value": "Driver, Query"
      }, {
        "code": "B",
        "value": "Driver, ResultSet"
      }, {
        "code": "C",
        "value": "DriverManager, Query"
      }, {
        "code": "D",
        "value": "DriverManager, ResultSet"
      }, {
        "code": "E",
        "value": "Driver, DriverManager, Query"
      }, {
        "code": "F",
        "value": "Driver, DriverManager, ResultSet"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "39. B. Driver, Connection, PreparedStatement, and ResultSet are the four\nkey interfaces you need to know for JDBC. DriverManager is a class rather\nthan an interface. Query is not used in JDBC. Since only Driver and\nResultSet are interfaces in the list, option B is the answer."
      }
    },
    "40": {
      "nbr": 40,
      "value": "Given the following class, which statement is correct?\n1: import java.security.*;\n2: import java.util.*;\n3:\n4: public class SecretFile {\n5: private String secret;\n6: // Constructors/Getters Omitted\n7:\n8: private static class Folder {\n9: private final SecretFile value;\n10: private final Permission permission;\n11:\n12: // Constructors/Getters Omitted\n13: }\n14:\n15: public static Permission getPermission(String check)\n{\n16: // Implementation Omitted\n17: }\n18:\n19: private static Map<String, Folder> c = new HashMap<>\n();\n20: public static SecretFile getSecret(String t) {\n21: var securityRecord = c.get(t);\n22: if (securityRecord != null) {\n23: return securityRecord.getValue();\n24: }\n25:\n26: var p = getPermission(t);\n27: AccessController.checkPermission(p);\n28: var pc = p.newPermissionCollection();\n29: pc.add(p);\n30: var secret = AccessController.doPrivileged(\n31: new PrivilegedAction<SecretFile>() {\n32: public SecretFile run() {\n33: return\n34: new\nSecretFile(System.getProperty(t));\n35: }},\n36: new AccessControlContext(new\nProtectionDomain[] {\n37: new ProtectionDomain(null, pc) }));\n38: c.put(t, new Folder(secret, p));\n39: return secret;\n40: } }",
      "responses": [{
        "code": "A",
        "value": "The class does not contain any security issues."
      }, {
        "code": "B",
        "value": "The class contains exactly one security issue."
      }, {
        "code": "C",
        "value": "The class contains exactly two security issues."
      }, {
        "code": "D",
        "value": "The class contains exactly three security issues."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "40. C. The class contains two security issues, making option C correct. First,\nline 23 returns a cached value without calling checkPermission() to ensure\nthe user has permission to read it. Second, line 34 allows direct access to\nany system property the user passes, without validating the inputted\nproperty name. When invoking doPrivileged(), make sure there is no\nchance for a user to pass their own, unprotected values into the request."
      }
    },
    "41": {
      "nbr": 41,
      "value": "How many objects are eligible for garbage collection immediately before\nthe end of the main() method?\npublic class Tennis {\npublic static void main(String[] game) {\nString[] balls = new String[1];\nint[] scores = new int[1];\nballs = null;\nscores = null;\n}\n}",
      "responses": [{
        "code": "A",
        "value": "None."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "41. C. All arrays are objects regardless of whether they point to primitives or\nclasses. That means both balls and scores are objects. Both are set to null\nso they are eligible for garbage collection. The balls array is initialized to\ncontain all null references. There are no objects inside. The scores array is\ninitialized to all 0 values. Therefore, only two objects exist to be eligible for\ngarbage collection, and option C is correct."
      }
    },
    "42": {
      "nbr": 42,
      "value": "What is the output of the following application?\npackage rope;\nimport java.util.concurrent.*;\npublic class Jump {\nprivate static void await(CyclicBarrier b) {\ntry { b.await(); } catch (Exception e) {}\n}\npublic static void main(String[] chalk) {\nExecutorService s = Executors.newFixedThreadPool(4);\nfinal var b = new CyclicBarrier(4,\n() -> System.out.print(\"Jump!\"));\nfor(int i=0; i<10; i++)\ns.execute(() ->await(b));\ns.shutdown();\n} }",
      "responses": [{
        "code": "A",
        "value": "Jump! is printed once, and the program exits."
      }, {
        "code": "B",
        "value": "Jump! is printed twice, and the program exits."
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The output cannot be determined ahead of time."
      }, {
        "code": "E",
        "value": "A deadlock is produced at runtime."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "42. E. The code compiles without issue. The main() method creates a thread\npool of four threads. It then submits ten tasks to it. At any given time, the\nExecutorService has up to four threads active, which is the same number\nof threads required to reach the CyclicBarrier limit. Therefore, the barrier\nlimit is reached twice, printing Jump! twice. While eight of the tasks have\nbeen completed, two are left running. Since no more tasks will call the\nawait() method, the CyclicBarrier limit is never reached, and a deadlock\nis encountered at runtime, with the program hanging indefinitely. For this\nreason, option E is correct."
      }
    },
    "43": {
      "nbr": 43,
      "value": "Given the application shown here, which lines do not compile? (Choose\nthree.)\npackage furryfriends;\ninterface Friend {\nprotected String getName(); // h1\n}\nclass Cat implements Friend {\nString getName() { // h2\nreturn \"Kitty\";\n}\n}\npublic class Dog implements Friend {\nString getName() throws RuntimeException { // h3\nreturn \"Doggy\";\n}\npublic static void main(String[] adoption) {\nFriend friend = new Dog(); // h4\nSystem.out.print(((Cat)friend).getName()); // h5\nSystem.out.print(((Dog)null).getName()); // h6\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Line h1"
      }, {
        "code": "B",
        "value": "Line h2"
      }, {
        "code": "C",
        "value": "Line h3"
      }, {
        "code": "D",
        "value": "Line h4"
      }, {
        "code": "E",
        "value": "Line h5"
      }, {
        "code": "F",
        "value": "Line h6"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "C All of the compilation issues with this code involve access\nmodifiers"
        ],
        "explanation": "43. A,B,C All of the compilation issues with this code involve access\nmodifiers. First, interface methods cannot be marked protected. This\ncauses a compilation error on line h1, making option A correct. Next, lines\nh2 and h3 both override the interface method with the package‐private\naccess modifier. Since this reduces the implied visibility of public, the\noverrides are invalid and neither line compiles. Therefore, options B and C\nare also correct.\nNote that the RuntimeException is allowed in an overridden method even\nthough it is not in the parent method signature because only new checked\nexceptions in overridden methods cause compilation errors. Line h4 is\nvalid. An object can be implicitly cast to a superclass or inherited interface.\nFinally, lines h5 and h6 will compile without issue but independently throw\na ClassCastException and a NullPointerException at runtime,\nrespectively. Since the question only asks about compilation problems,\nneither of these are correct answers."
      }
    },
    "44": {
      "nbr": 44,
      "value": "Fill in the blanks: Using the ________ and ________ modifiers together\nallows a variable to be accessed from any class, without requiring an\ninstance variable.",
      "responses": [{
        "code": "A",
        "value": "class, static"
      }, {
        "code": "B",
        "value": "default, public"
      }, {
        "code": "C",
        "value": "final, package‐private"
      }, {
        "code": "D",
        "value": "protected, instance"
      }, {
        "code": "E",
        "value": "public, static"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "44. E. The public modifier allows access from the same class, package,\nsubclass, or even classes in other packages, while the static modifier\nallows access without an instance of the class. For these reasons, option E is\nthe correct answer. Option A is incorrect because class is not a modifier; it\nis a keyword. Option B is incorrect because the default keyword is for\ninterface methods and switch statements, not class variables. Option C is\nincorrect because final is not related to access, and package‐private\nprevents access from classes outside the package. Finally, option D is\nincorrect because instance is not a Java keyword or modifier. Further,\nprotected prevents all classes outside the package other than subclasses\nfrom accessing the variable."
      }
    },
    "45": {
      "nbr": 45,
      "value": "Which statements when inserted independently will throw an exception at\nruntime? (Choose two.)\nvar x = new LinkedList<>();\nx.offer(18);\n// INSERT CODE HERE",
      "responses": [{
        "code": "A",
        "value": "x.peek(); x.peek();"
      }, {
        "code": "B",
        "value": "x.poll(); x.poll();"
      }, {
        "code": "C",
        "value": "x.pop(); x.pop();"
      }, {
        "code": "D",
        "value": "x.remove(); x.remove();"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "45. C,D. Option A is incorrect because the peek() method returns the next\nvalue or null if there isn't one without changing the state of the queue. In\nthis example, both peek() calls return 18. Option B is incorrect because the\npoll() method removes and returns the next value, returning null if there\nisn't one. In this case, 18 and null are returned, respectively. Options C and\nD are correct because both the pop() and remove() methods throw a\nNoSuchElementException when the queue is empty. This means both return\n18 for the first call and throw an exception for the second."
      }
    },
    "46": {
      "nbr": 46,
      "value": "Which of the following shows a valid Locale format? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "iw"
      }, {
        "code": "B",
        "value": "UA"
      }, {
        "code": "C",
        "value": "it_ch"
      }, {
        "code": "D",
        "value": "JA_JP"
      }, {
        "code": "E",
        "value": "th_TH"
      }, {
        "code": "F",
        "value": "ES_HN"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "46. A,E. In Java, a locale can be represented by a language code in lowercase,\nor a language and country code, with language in lowercase and country in\nuppercase. For these reasons, options A and E are correct. Options C, D,\nand F are incorrect because the lowercase language must be before the\nuppercase country. Option B is incorrect because the language is missing.\nRemember, the exam won't expect you to know which language and\ncountry codes exist, but it will expect you to know how to use them."
      }
    },
    "47": {
      "nbr": 47,
      "value": "Which sets of lines can be removed without stopping the code from\ncompiling and while printing the same output? (Choose three.)\n14: String race = \"\";\n15: outer:\n16: do {\n17: inner:\n18: do\n19: {\n20: race += \"x\";\n21: }\n22: while (race.length() <= 4);\n23: } while (race.length() < 4);\n24: System.out.println(race);",
      "responses": [{
        "code": "A",
        "value": "Lines 15 and 17"
      }, {
        "code": "B",
        "value": "Lines 16 and 23"
      }, {
        "code": "C",
        "value": "Lines 17, 18, and 22"
      }, {
        "code": "D",
        "value": "Line 17"
      }, {
        "code": "E",
        "value": "Line 22"
      }, {
        "code": "F",
        "value": "Line 23"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B",
          "D"
        ],
        "explanation": "47. A,B,D. The unmodified code prints xxxxx, so you're looking for options\nthat also print this value. Option A is correct because the labels are not\nreferenced. Option B is correct because the outer while is broader than the\ninner while. If race.length() <= 4 is true, then race.length() < 4\nmust be true. The inner loop prints xxxxx, and the outer loop is not needed.\nOption C is incorrect because the outer loop only prints xxxx without the\ninner loop. Option D is also correct because a label is not used. Option E\nand F are incorrect because you cannot remove the while portion of a\ndo/while loop."
      }
    },
    "48": {
      "nbr": 48,
      "value": "How many objects are eligible for garbage collection at the end of the\nmain() method?\npackage store;\npublic class Shoes {\nstatic String shoe1 = new String(\"sandal\");\nstatic String shoe2 = new String(\"flip flop\");\npublic void shopping() {\nString shoe3 = new String(\"croc\");\nshoe2 = shoe1;\nshoe1 = shoe3;\n}\npublic static void main(String… args) {\nnew Shoes().shopping();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "None."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "48. C. While shoe3 goes out of scope after the shopping() method, the\n\"croc\" object is referenced by shoe1, and therefore cannot be garbage\ncollected. Similarly, the \"sandal\" object is now referenced by shoe2. No\nvariables reference the \"flip flop\" object, so it is eligible to be garbage\ncollected. Finally, the Shoes object created in the main() method is also\neligible for garbage collection, since there are no saved references to it. For\nthese reasons, option C is correct."
      }
    },
    "49": {
      "nbr": 49,
      "value": "Which of the following variable types can be used in a switch statement\nunder some circumstances? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "An enumerated type"
      }, {
        "code": "B",
        "value": "StringBuilder"
      }, {
        "code": "C",
        "value": "Byte"
      }, {
        "code": "D",
        "value": "Double"
      }, {
        "code": "E",
        "value": "var"
      }, {
        "code": "F",
        "value": "Exception"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "E"
        ],
        "explanation": "49. A,C,E. A switch statement supports the primitive types byte, short,\nchar, and int and their associated wrapper classes Character, Byte, Short,\nand Integer. It also supports the String class and enumerated types.\nFinally, it permits var under some circumstances, such as if the type can\nresolve to one of the previous types. For these reasons, options A, C, and E\nare correct. The other classes are not supported."
      }
    },
    "50": {
      "nbr": 50,
      "value": "What is the output of the following?\n1: import static java.util.stream.Collectors.*;\n2: import java.util.*;\n3:\n4: public class Goat {\n5: private String food;\n6:\n7: // constructor, getter and toString\n8:\n9: public static void main(String[] args) {\n10: var goats = List.of(\n11: new Goat(\"can\"),\n12: new Goat(\"hay\"),\n13: new Goat(\"shorts\"),\n14: new Goat(\"hay\"));\n15:\n16: goats.stream()\n17: .collect(groupingBy(Goat::getFood))\n18: .entrySet()\n19: .stream()\n20: .filter(e -> e.getValue().size() == 2)\n21: .map(e -> e.getKey())\n22: .collect(partitioningBy(e -> e.isEmpty()))\n23: .get(false)\n24: .stream()\n25: .sorted()\n26: .forEach(System.out::print);\n27: }\n28: }",
      "responses": [{
        "code": "A",
        "value": "canshorts"
      }, {
        "code": "B",
        "value": "hay"
      }, {
        "code": "C",
        "value": "hayhay"
      }, {
        "code": "D",
        "value": "shortscan"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "50. B. This code contains three stream pipelines for the price of one! Lines\n16–17 are the first pipeline. They group the four Goat instances by the type\nof food they eat. This creates a Map with the elements {hay=[hay, hay],\ncan=[can], shorts=[shorts]}.\nLines 19–22 are the second pipeline. This one starts by only including\nelements that have two matches, in our case hay. We then use the String\nkey Goat. Finally, this pipeline partitions the single key based on whether it\nhas any characters giving us {false=[hay], true=[]}.\nOn line 23, we get just one of the lists leaving us with [hay]. The final\npipeline is lines 24–26. It sorts the single element in an attempt to confuse\nyou and then prints it. Therefore, only one hay is printed, and option B is\nthe answer."
      }
    }
  }
}, {
  "name": "Practice Exam 2",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "What is the output of the following application?\n1: package fruit;\n2: enum Season {\n3: SPRING(1), SUMMER(2), FALL(3), WINTER(4);\n4: public Season(int orderId) {}\n5: }\n6: public class PickApples {\n7: public static void main(String… orchard) {\n8: final Season s = Season.FALL;\n9: switch(s) {\n10: case Season.FALL:\n11: System.out.println(\"Time to pick!\");\n12: default:\n13: System.out.println(\"Not yet!\");\n14: }\n15: }\n16: }",
      "responses": [{
        "code": "A",
        "value": "Time to pick!"
      }, {
        "code": "B",
        "value": "Time to pick! followed by Not yet!"
      }, {
        "code": "C",
        "value": "One line of code does not compile."
      }, {
        "code": "D",
        "value": "Two lines of code do not compile."
      }, {
        "code": "E",
        "value": "Three lines of code do not compile."
      }, {
        "code": "F",
        "value": "The code compiles but prints an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "1. D. Line 4 does not compile because enum constructors cannot be public.\nLine 10 also does not compile because a case statement must use an enum\nvalue without the type. In particular, FALL is permitted, but Season.FALL is\nnot. For these two reasons, option D is correct."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Which statements about the following class are correct? (Choose two.)\npackage knowledge;\nclass InformationException extends Exception {}\npublic class LackOfInformationException\nextends InformationException {\npublic LackOfInformationException() { // t1\nsuper(\"\");\n}\npublic LackOfInformationException(String s) { // t2\nthis(new Exception(s));\n}\npublic LackOfInformationException(Exception c) { // t3\nsuper();\n}\n@Override public String getMessage() {\nreturn \"lackOf\";\n}\n}",
      "responses": [{
        "code": "A",
        "value": "LackOfInformationException compiles without issue."
      }, {
        "code": "B",
        "value": "The constructor declared at line t1 does not compile."
      }, {
        "code": "C",
        "value": "The constructor declared at line t2 does not compile."
      }, {
        "code": "D",
        "value": "The constructor declared at line t3 does not compile."
      }, {
        "code": "E",
        "value": "The getMessage() method does not compile because of the @Override\nannotation."
      }, {
        "code": "F",
        "value": "LackOfInformationException is a checked exception."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "2. B,F. The LackOfInformationException class does not compile, making\noption A incorrect. The compiler inserts the default no‐argument\nconstructor into InformationException, since the class does not explicitly\ndefine any. Since LackOfInformationException extends\nInformationException, the only constructor available in the parent class is\nthe no‐argument call to super(). For this reason, the constructor defined at\nline t1 does not compile because it calls a nonexistent parent constructor\nthat takes a String value, and option B is one of the correct answers. The\nother two constructors at lines t2 and t3 compile without issue, making\noptions C and D incorrect. Option E is also incorrect. The getMessage()\nmethod is inherited, so applying the @Override annotation is allowed by the\ncompiler. Option F is the other correct answer. The\nLackOfInformationException is a checked exception because it inherits\nException but not RuntimeException."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Assuming the following class is concurrently accessed by numerous\nthreads, which statement about the CountSheep class is correct?\npackage fence;\nimport java.util.concurrent.atomic.*;\npublic class CountSheep {\nprivate static AtomicInteger counter = new\nAtomicInteger();\nprivate Object lock = new Object();\npublic synchronized int increment1() {\nreturn counter.incrementAndGet();\n}\npublic static synchronized int increment2() {\nreturn counter.getAndIncrement();\n}\npublic int increment3() {\nsynchronized(lock) {\nreturn counter.getAndIncrement();\n} } }",
      "responses": [{
        "code": "A",
        "value": "The class is thread‐safe only if increment1() is removed."
      }, {
        "code": "B",
        "value": "The class is thread‐safe only if increment2() is removed."
      }, {
        "code": "C",
        "value": "The class is thread‐safe only if increment3() is removed."
      }, {
        "code": "D",
        "value": "The class is already thread‐safe."
      }, {
        "code": "E",
        "value": "The class does not compile."
      }, {
        "code": "F",
        "value": "The class compiles but may throw an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "3. D. The code compiles, making option E incorrect. The key here is that the\nAtomicInteger variable is thread‐safe regardless of the synchronization\nmethods used to access it. Therefore, synchronizing on an instance object,\nas in increment1() or increment3(), or on the class object, as in\nincrement2(), is unnecessary because the AtomicInteger class is already\nthread‐safe. For this reason, option D is the correct answer."
      }
    },
    "4": {
      "nbr": 4,
      "value": "Which statements best describe the result of executing this code? (Choose\ntwo.)\npackage nyc;\npublic class TouristBus {\npublic static void main(String… args) {\nvar nycTourLoops = new String[] {\n\"Downtown\", \"Uptown\", \"Brooklyn\" };\nvar times = new String[] { \"Day\", \"Night\" };\nfor (int i = 0, j = 0;\ni < nycTourLoops.length; i++, j++)\nSystem.out.println(\nnycTourLoops[i] + \" \" + times[j]);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The println() causes one line of output."
      }, {
        "code": "B",
        "value": "The println() causes two lines of output."
      }, {
        "code": "C",
        "value": "The println() causes three lines of output."
      }, {
        "code": "D",
        "value": "The code terminates successfully."
      }, {
        "code": "E",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "4. B,E. The first two iterations through the loop complete successfully,\nmaking option B correct. However, the two arrays are not the same size,\nand the for loop only checks the size of the first one. The third iteration\nthrows an ArrayIndexOutOfBoundsException, making option E correct."
      }
    },
    "5": {
      "nbr": 5,
      "value": "What is the output of the following application?\npackage woods;\ninterface Plant {\ndefault String grow() { return \"Grow!\"; }\n}\ninterface Living {\npublic default String grow() { return \"Super Growing!\";\n}\n}\npublic class Tree implements Plant, Living { // m1\npublic String grow() { return super.Plant.grow(); }\npublic static void main(String[] leaves) {\nPlant p = new Tree(); // m2\nSystem.out.print(((Living)p).grow()); // m3\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Grow!"
      }, {
        "code": "B",
        "value": "Super Growing!"
      }, {
        "code": "C",
        "value": "It does not compile because of line m1."
      }, {
        "code": "D",
        "value": "It does not compile because of line m2."
      }, {
        "code": "E",
        "value": "It does not compile because of line m3."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "5. F. A class can inherit two default interfaces with the same signature, so\nlong as it correctly overrides them, which Tree does. It can also call an\ninherited version of the default method within an instance method,\nprovided it uses the proper syntax. In this case, it does not. The correct\nsyntax is Plant.super.grow(), not super.Plant.grow(). For this reason,\nthis line does not compile. Since it is the only line that does not compile,\noption F is correct."
      }
    },
    "6": {
      "nbr": 6,
      "value": "Which statements about the following application are true? (Choose two.)\npackage party;\nimport java.util.concurrent.*;\npublic class Plan {\nExecutorService s =\nExecutors.newScheduledThreadPool(10);\npublic void planEvents() {\nRunnable r1 = () -> System.out.print(\"Check food\");\nRunnable r2 = () -> System.out.print(\"Check drinks\");\nRunnable r3 = () -> System.out.print(\"Take out\ntrash\");\ns.scheduleWithFixedDelay(r1,1,TimeUnit.HOURS);\n// g1\ns.scheduleAtFixedRate(r2,1,1000,TimeUnit.SECONDS);\n// g2\ns.execute(r3);\n// g3\ns.shutdownNow();\n} }",
      "responses": [{
        "code": "A",
        "value": "Line g1 does not compile."
      }, {
        "code": "B",
        "value": "Line g2 does not compile."
      }, {
        "code": "C",
        "value": "Line g3 does not compile."
      }, {
        "code": "D",
        "value": "All of the lines of code compile."
      }, {
        "code": "E",
        "value": "The code hangs indefinitely at runtime."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B"
        ],
        "explanation": "6. A,B. Lines g1 and g2 do not compile because these methods are available\nonly in the ScheduledExecutorService interface. Since s is of type\nExecutorService, the lines referenced in options A and B do not compile.\nEven if the correct reference type for s was used, line g1 would still fail to\ncompile because scheduleWithFixedDelay() requires two long values,\none for the initial delay and one for the period. Line g3 compiles without\nissue because this method is available in the ExecutorService interface."
      }
    },
    "7": {
      "nbr": 7,
      "value": "Which of the following is a valid method name in Java? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "_ _ _ _ _"
      }, {
        "code": "B",
        "value": "%run"
      }, {
        "code": "C",
        "value": "check‐Activity"
      }, {
        "code": "D",
        "value": "$Hum2"
      }, {
        "code": "E",
        "value": "sing\\\\3"
      }, {
        "code": "F",
        "value": "po#ut"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D"
        ],
        "explanation": "7. A,D. Java methods must start with a letter, the dollar $ symbol, or the\nunderscore _ character. For this reason, option B is incorrect, and options A\nand D are correct. Despite how option A looks, it is a valid method name in\nJava. Options C, E, and F do not compile because the symbols ‐, \\, and #\nare not allowed in method names, respectively."
      }
    },
    "8": {
      "nbr": 8,
      "value": "Which two options when inserted independently can fill in the blank to\ncompile the code? (Choose two.)\njavac ______ mods -d birds com-bird/*.java *.java",
      "responses": [{
        "code": "A",
        "value": "‐cp"
      }, {
        "code": "B",
        "value": "‐m"
      }, {
        "code": "C",
        "value": "‐p"
      }, {
        "code": "D",
        "value": "‐classpath"
      }, {
        "code": "E",
        "value": "‐‐classpath"
      }, {
        "code": "F",
        "value": "‐‐module‐path"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "F"
        ],
        "explanation": "8. C,F. The javac command takes a ‐‐module‐path parameter. You need to\nmemorize that the short form of this option is ‐p. This makes options C and\nF the answer."
      }
    },
    "9": {
      "nbr": 9,
      "value": "Which classes when inserted into the blank do not allow this code to\ncompile? (Choose two.)\nimport java.io.*;\nclass Music {\nvoid make() throws IOException {\nthrow new UnsupportedOperationException();\n}\n}\npublic class Sing extends Music {\npublic void make() throws _______________ {\nSystem.out.println(\"do-re-mi-fa-so-la-ti-do\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "FileNotFoundException"
      }, {
        "code": "B",
        "value": "NumberFormatException"
      }, {
        "code": "C",
        "value": "Exception"
      }, {
        "code": "D",
        "value": "Error"
      }, {
        "code": "E",
        "value": "Throwable"
      }, {
        "code": "F",
        "value": "RuntimeException"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "9. C,E. An overriding method cannot declare any new or broader checked\nexceptions as the overridden method. Option A is permitted because\nFileNotFoundException is a narrower exception than IOException.\nOptions B, D, and F are permitted because new unchecked exceptions are\nallowed. Note that IOException is not required to be declared at all in the\noverriding method. Options C and E are incorrect because they are broader\nchecked exceptions than IOException. Even if you didn't know Throwable\nwas checked, you should have been able to solve this by process of\nelimination."
      }
    },
    "10": {
      "nbr": 10,
      "value": "What is the result of compiling and executing the following application?\npackage reptile;\npublic class Alligator {\nstatic int teeth;\ndouble scaleToughness;\npublic Alligator() {\nthis.teeth++;\n}\npublic void snap(int teeth) {\nSystem.out.print(teeth+\" \");\nteeth--;\n}\npublic static void main(String[] unused) {\nnew Alligator().snap(teeth);\nnew Alligator().snap(teeth);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "0 1"
      }, {
        "code": "B",
        "value": "1 1"
      }, {
        "code": "C",
        "value": "1 2"
      }, {
        "code": "D",
        "value": "2 2"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but produces an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "10. C. The code compiles and runs without exception, making options E and F\nincorrect. The question is testing your knowledge of variable scope. The\nteeth variable is static in the Alligator class, meaning the same value is\naccessible from all instances of the class, including the static main()\nmethod. The static variable teeth is incremented each time the\nconstructor is called. Note that the constructor uses this to access a static\nvariable, which is bad practice, but allowed.\nSince teeth is a local variable within the snap() method, the argument\nvalue is used, but changes to the local variable do not affect the static\nvariable teeth. The local variable teeth is not used after it is decremented,\nthe decrement operation has no meaningful effect on the program flow or\nthe static variable teeth. Since the constructor is called twice, with\nsnap() executed after each constructor call, the output printed is 1 2,\nmaking option C the correct answer."
      }
    },
    "11": {
      "nbr": 11,
      "value": "Which are true statements about the majority of steps in migrating to a\nmodular application? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "In a bottom‐up migration, automatic modules turn into named\nmodules."
      }, {
        "code": "B",
        "value": "In a bottom‐up migration, named modules turn into automatic\nmodules."
      }, {
        "code": "C",
        "value": "In a bottom‐up migration, unnamed modules turn into named modules."
      }, {
        "code": "D",
        "value": "In a top‐down migration, automatic modules turn into named modules."
      }, {
        "code": "E",
        "value": "In a top‐down migration, named modules turn into automatic modules."
      }, {
        "code": "F",
        "value": "In a top‐down migration, unnamed modules turn into named modules."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "11. C,D. A fully modular application has all named modules, making options\nB and E incorrect. A bottom‐up migration starts out with unnamed\nmodules, making option C correct. By contrast, a top‐down migration starts\nby making all modules automatic modules, making option D correct."
      }
    },
    "12": {
      "nbr": 12,
      "value": "Which of the following are true about Java operators and statements?\n(Choose three.)",
      "responses": [{
        "code": "A",
        "value": "Both right‐hand sides of the ternary expression are evaluated at\nruntime."
      }, {
        "code": "B",
        "value": "A switch statement may contain at most one default statement."
      }, {
        "code": "C",
        "value": "The post‐increment operator (++) returns the value of the variable\nbefore the addition is applied."
      }, {
        "code": "D",
        "value": "The logical operators (|) and (||) are interchangeable, producing the\nsame results at runtime."
      }, {
        "code": "E",
        "value": "The complement operator (!) operator may be applied to numeric\nexpressions."
      }, {
        "code": "F",
        "value": "An assignment operator returns a value that is equal to the value of the\nexpression being assigned."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "F"
        ],
        "explanation": "12. B,C,F. The ternary operator (? :) evaluates only one of the two right‐hand\nexpressions at runtime, so option A is incorrect. A switch statement may\ncontain at most one optional default statement, making option B correct.\nThe post‐increment operator increments the variable and returns the\noriginal value, making option C correct. The logical operator (|) operator\nwill evaluate both operands, while the disjunctive short‐circuit (||) operator\nwill only evaluate the right‐hand side of the expression if the left‐hand side\nevaluates to false. Therefore, they may produce different results if the left\noperand is true, and option D is incorrect. Option E is incorrect as the\ncomplement operator (!) is applied to boolean values. Finally, option F is\ncorrect and allows the assignment operator to be used in a conditional\nexpression, such as part of a loop condition."
      }
    },
    "13": {
      "nbr": 13,
      "value": "Assume the file system is accessible, /flower/rose.txt exists, and the\nother two directories /garden and /nursery do not exist. What is the\nexpected result after executing the following code snippet?\nFiles.createDirectories(Path.of(\"/garden\"));\nFiles.createDirectory(Path.of(\"/nursery\"));\nFiles.move(Path.of(\"/flower/rose.txt\"),\nPaths.get(\"/garden\"),\nStandardCopyOption.REPLACE_EXISTING);\nFiles.move(new File(\"/garden/rose.txt\").toPath(),\nPaths.get(\"/nursery\"), StandardCopyOption.ATOMIC_MOVE);",
      "responses": [{
        "code": "A",
        "value": "There is a file at /nursery/rose.txt"
      }, {
        "code": "B",
        "value": "There is a file at /flower/rose.txt"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The first move() statement throws an exception."
      }, {
        "code": "E",
        "value": "The second move() statement throws an exception."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "13. E. The code compiles, so option C is incorrect. The first two lines\nsuccessfully create directories. The first move() statement moves a file from\n/flower/rose.txt to /garden, not /garden/rose.txt. There is already an\nempty directory there, but since the REPLACE_EXISTING flag is provided, the\n/garden directory is replaced with a file. The next move() statement throws\nan exception because there is no source file at /garden/rose.txt. For this\nreason, option E is correct."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Which of the following are valid functional interfaces? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "interface CanClimb {\ndefault void climb() {}\nstatic void climb(int x) {}\n}"
      }, {
        "code": "B",
        "value": "interface CanDance {\nint dance() { return 5; }\n}"
      }, {
        "code": "C",
        "value": "interface CanFly {\nabstract void fly();\n}"
      }, {
        "code": "D",
        "value": "interface CanRun {\nvoid run();\nstatic double runFaster() {return 2.0; }\n}"
      }, {
        "code": "E",
        "value": "interface CanSwim {\nabstract Long swim();\nboolean test();\n}"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "14. C,D. To be a valid functional interface, an interface must declare exactly\none abstract method. Option A is incorrect, because CanClimb does not\ncontain any abstract methods. Next, all interface methods not marked\ndefault or static are assumed to be abstract, and abstract methods\ncannot have a body. For this reason, CanDance does not compile, making\noption B incorrect. Options C and D are correct answers because each\ncontains exactly one abstract method. Option E is incorrect because it\ncontains two abstract methods, since test() is assumed to be abstract."
      }
    },
    "15": {
      "nbr": 15,
      "value": "Suppose we have a peacocks table with two columns: name and rating.\nWhat does the following code output if the table is empty?\n10: var url = \"jdbc:derby:birds\";\n11: var sql = \"SELECT name FROM peacocks WHERE name = ?\";\n12: try (var conn = DriverManager.getConnection(url);\n13: var stmt = conn.prepareStatement(sql)) {\n14:\n15: stmt.setString(1, \"Feathers\");\n16:\n17: try (var rs = stmt.execute()) {\n18: System.out.println(rs.next());\n19: }\n20: }",
      "responses": [{
        "code": "A",
        "value": "false"
      }, {
        "code": "B",
        "value": "true"
      }, {
        "code": "C",
        "value": "The code does not compile due to lines 12–13."
      }, {
        "code": "D",
        "value": "The code does not compile due to lines 17–18."
      }, {
        "code": "E",
        "value": "The code does not compile due to another line."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "15. D. The execute() method returns a boolean, not a ResultSet. This\ncauses a compiler error on line 18, which corresponds to option D."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Which of the following are valid in a Java file, listed in the order in which\nthey are declared? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "A package‐private class declaration and a public interface declaration"
      }, {
        "code": "B",
        "value": "Two package statements, an import statement, and a public interface\ndeclaration"
      }, {
        "code": "C",
        "value": "A package statement, 128 import statements, and two public class\ndeclarations"
      }, {
        "code": "D",
        "value": "16 import statements, a package statement, and a public class\ndeclaration"
      }, {
        "code": "E",
        "value": "5 import statements and 7 package‐private interface declarations"
      }, {
        "code": "F",
        "value": "A private interface"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "16. A,E. A Java file can have at most one top‐level type and any number of\npackage‐private types. For this reason, options A and E are correct. Option\nB is incorrect because it can have at most one package statement. Option C\nis incorrect because it cannot have two public top‐level classes. Option D\nis incorrect because the package statement must appear before the import\nstatement. Option F is incorrect because top‐level types may not be\nprivate or protected."
      }
    },
    "17": {
      "nbr": 17,
      "value": "Which of the following sequences can fill in the blanks so the code prints ‐\n1 0 2?\nchar[][] letters = new char[][] {\nnew char[] { 'a', 'e', 'i', 'o', 'u'},\nnew char[] { 'a', 'e', 'o', 'u'} };\nvar x = Arrays.____________(letters[0], letters[0]);\nvar y = Arrays.____________(letters[0], letters[0]);\nvar z = Arrays.____________(letters[0], letters[1]);\nSystem.out.print(x + \" \" + y + \" \" + z);",
      "responses": [{
        "code": "A",
        "value": "compare, mismatch, compare"
      }, {
        "code": "B",
        "value": "compare, mismatch, mismatch"
      }, {
        "code": "C",
        "value": "mismatch, compare, compare"
      }, {
        "code": "D",
        "value": "mismatch, compare, mismatch"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "17. D. When the arrays are the same, the compare() method returns 0, while\nthe mismatch() method returns ‐1. This narrows it down to option C or\noption D. When the arrays are different, mismatch() returns the index of\nthe first element that is different. In our case, this is index 2, making option\nD correct. By contrast, the compare() method would return a negative\nnumber if filling in the third blank since 'i' is smaller than 'o'."
      }
    },
    "18": {
      "nbr": 18,
      "value": "What does the following output?\nvar dice = new LinkedList<Integer>();\ndice.offer(3);\ndice.offer(2);\ndice.offer(4);\nSystem.out.print(dice.stream().filter(n -> n != 4));",
      "responses": [{
        "code": "A",
        "value": "2"
      }, {
        "code": "B",
        "value": "3"
      }, {
        "code": "C",
        "value": "[3 2]"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "18. E. The code correctly creates a LinkedList with three elements. The\nstream pipeline does compile. However, there is no terminal operation,\nwhich means the stream is never evaluated, and the output is something like\njava.util.stream.ReferencePipeline$2@404b9385. This is definitely not\none of the listed choices, so option E is correct."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What is the output of executing the following code snippet?\nvar e = Executors.newSingleThreadExecutor();\nRunnable r1 = () -> Stream.of(1,2,3).parallel();\nCallable r2 = () -> Stream.of(4,5,6).parallel();\nFuture<Stream<Integer>> f1 = e.submit(r1); // x1\nFuture<Stream<Integer>> f2 = e.submit(r2); // x2\nvar r = Stream.of(f1.get(),f2.get())\n.flatMap(p -> p) // x3\n.parallelStream() // x4\n.collect(\nCollectors.groupingByConcurrent(i -> i%2==0));\nSystem.out.print(r.get(false).size()\n+\" \"+r.get(true).size());",
      "responses": [{
        "code": "A",
        "value": "3 3"
      }, {
        "code": "B",
        "value": "2 4"
      }, {
        "code": "C",
        "value": "One of the marked lines (x1, x2, x3, x4) does not compile."
      }, {
        "code": "D",
        "value": "Two of the marked lines (x1, x2, x3, x4) do not compile."
      }, {
        "code": "E",
        "value": "Three of the marked lines (x1, x2, x3, x4) do not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "19. D. Line x1 does not compile because of an assignment and value\nmismatch. The r1 variable is a Runnable expression. While there is an\nExecutorService.submit() that takes a Runnable expression, it returns\nFuture<?>, since the return type is void. This type is incompatible with the\nFuture<Stream> assignment without an explicit cast, leading to a compiler\nerror. Next, line x4 does not compile. The parallelStream() method is\nfound in the Collection interface, not the Stream interface. Due to these\ntwo compilation errors, option D is the correct answer."
      }
    },
    "20": {
      "nbr": 20,
      "value": "Which statements about the following class that loads a library on startup\nare correct? (Choose three.)\nimport java.io.FilePermission;\nimport java.security.*;\nimport java.util.List;\npublic class Startup {\nprivate static final List<String> files =\nList.of(\"my.secret\",\"other.secrets\");\npublic void startup(String f) {\nvar perm = new FilePermission(f,\"write\"); // j1\nAccessController.checkPermission(perm); // j2\nAccessController.doPrivileged(\nnew PrivilegedAction<Void>() {\npublic Void run() {\nif(files.contains(f))\nSystem.loadLibrary(f); // j3\nreturn null;\n}\n});\n} }",
      "responses": [{
        "code": "A",
        "value": "Line j1 contains a security error or risk."
      }, {
        "code": "B",
        "value": "Line j2 contains a security error or risk."
      }, {
        "code": "C",
        "value": "Line j3 contains a security error or risk."
      }, {
        "code": "D",
        "value": "Line j1 does not contain a security error or risk."
      }, {
        "code": "E",
        "value": "Line j2 does not contain a security error or risk."
      }, {
        "code": "F",
        "value": "Line j3 does not contain a security error or risk."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E",
          "F"
        ],
        "explanation": "20. A,E,F. Line j1 should be verifying read or execute access to the file, not\nwrite, making option A correct. The system needs permission other than\nwrite to load a library. The rest of the lines are valid, making options E and\nF correct. While the user is free to pass in any value for the file, it is\nchecked against a list of known files, thereby preventing arbitrary file\naccess."
      }
    },
    "21": {
      "nbr": 21,
      "value": "How many times does this code print [2, 7, 8]?\n1: import java.util.*;\n2: import java.util.stream.*;\n3:\n4: public class RemoveMe<T> {\n5: private List<T> values;\n6: public RemoveMe(T… values) {\n7: this.values = Arrays.stream(values)\n8: .collect(Collectors.toList());\n9: }\n10: public void remove(T value) {\n11: values.remove(value);\n12: }\n13: public static void main(String[] args) {\n14: var integer = new RemoveMe<Integer>(2, 7, 1, 8);\n15: var longs = new RemoveMe<Long>(2L, 7L, 1L, 8L);\n16: integer.remove(1);\n17: longs.remove(1L);\n18:\n19: System.out.println(integer.values);\n20: System.out.println(longs.values);\n21:\n22: var values = new ArrayList<Integer>();\n23: values.add(2);\n24: values.add(7);\n25: values.add(1);\n26: values.add(8);\n27: values.remove(1);\n28: System.out.println(values);\n29: }\n30: }",
      "responses": [{
        "code": "A",
        "value": "Zero."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but throws an exception."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "21. C. Lines 14 and 15 create RemoveMe<Integer> and RemoveMe<Long>\ninstances, respectively. Since we are using generics, the method calls on\nlines 16 and 17 autobox the primitive values (1 and 1L) to the Integer\nvalue 1 and Long value 1L, respectively. Therefore, the method on line 11\nremoves the argument that matches this object value, and not the element at\nindex 1, from the two lists. These are the two lines that print [2, 7, 8].\nLine 27 is trickier. Since we are passing a primitive int, the index is used\n(and not an object matching the value) in the call to remove().This means\nline 28 prints [2, 1, 8], which is not what we are looking for. Since only\nlines 16 and 17 give us the desired output, option C is the answer."
      }
    },
    "22": {
      "nbr": 22,
      "value": "Fill in the blanks with the proper method names to deserialize an object.\n(Choose two.)\nimport java.io.*;\npublic class BoxOfSecrets {\nprivate void ____________(ObjectInputStream in)\nthrows IOException {\n// IMPLEMENTATION OMITTED\n}\npublic Object ____________() throws\nObjectStreamException {\n// IMPLEMENTATION OMITTED\n}\n}",
      "responses": [{
        "code": "A",
        "value": "writeObject in the first blank"
      }, {
        "code": "B",
        "value": "writeResolve in the first blank"
      }, {
        "code": "C",
        "value": "readObject in the first blank"
      }, {
        "code": "D",
        "value": "writeReplace in the second blank"
      }, {
        "code": "E",
        "value": "readResolve in the second blank"
      }, {
        "code": "F",
        "value": "readReplace in the second blank"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "22. C,E. The write methods are used as part of serialization, not\ndeserialization, making options A, B, and D incorrect. Option C and E are\ncorrect because they use the correct method parameters and return types for\nreadObject() and readResolve(). The method names used in options B\nand F, writeResolve() and readReplace() respectively, are not actually\nserialization or deserialization methods."
      }
    },
    "23": {
      "nbr": 23,
      "value": "How many lines of the following application do not compile?\n1: package castles;\n2: import java.io.*;\n3: public class Palace {\n4: public void openDrawbridge() throws Exception {\n5: try {\n6: throw new Exception(\"Problem\");\n7: } catch (IOException e) {\n8: throw new IOException();\n9: } catch (FileNotFoundException e) {\n10: try {\n11: throw new IOException();\n12: } catch (Exception e) {\n13: } finally {\n14: System.out.println(\"Almost done\");\n15: }\n16: } finally {\n17: throw new RuntimeException(\"Unending\nproblem\");\n18: }\n19: }\n20:\n21: public static void main(String[] moat)\n22: throws IllegalArgumentException {\n23: new Palace().openDrawbridge();\n24: }\n25: }",
      "responses": [{
        "code": "A",
        "value": "None. The code compiles and produces a stack trace at runtime."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "Five."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "23. D. The second catch block in openDrawbridge() is unreachable since\nFileNotFoundException is a subclass of IOException. The catch blocks\nshould be ordered with the narrower exception classes before the broader\nones. For this reason, line 9 does not compile. Next, the local variable e is\ndeclared twice within the same scope, with the declaration on line 12 failing\nto compile. Finally, the openDrawbridge() method declares the checked\nException class, but it is not handled in the main() method on line 23.\nSince lines 9, 12, and 23 do not compile, option D is correct."
      }
    },
    "24": {
      "nbr": 24,
      "value": "Which of the following is true of the following module declaration?\n1: module com.mammal {\n2: exports com.mammal.cat;\n3: exports com.mammal.mouse to com.mice;\n4: uses com.animal;\n5: }",
      "responses": [{
        "code": "A",
        "value": "The first line that fails to compile is line 1."
      }, {
        "code": "B",
        "value": "The first line that fails to compile is line 2."
      }, {
        "code": "C",
        "value": "The first line that fails to compile is line 3."
      }, {
        "code": "D",
        "value": "The first line that fails to compile is line 4."
      }, {
        "code": "E",
        "value": "The code compiles."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "24. E. This is a correct module‐info file. It exports the com.mammal.cat\npackage to any modules that want to use it. By contrast, it exports the\ncom.mammal.mouse package to only one other module. Finally, it\ndemonstrates the uses directive. Since the code is correct, option E is the\nanswer."
      }
    },
    "25": {
      "nbr": 25,
      "value": "What is the result of the following?\nimport java.util.*;\npublic class Museums {\npublic static void main(String[] args) {\nString[] array = {\"Natural History\", \"Science\",\n\"Art\"};\nList<String> museums = Arrays.asList(array);\nmuseums.remove(2);\nSystem.out.println(museums);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "[Natural History, Science]"
      }, {
        "code": "B",
        "value": "[Natural History, Science, Art]"
      }, {
        "code": "C",
        "value": "The code does not compile."
      }, {
        "code": "D",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "25. D. When converting an array to a List, Java uses a fixed‐sized backed list.\nThis means that the list uses an array in the implementation. While\nchanging elements to new values is allowed, adding and removing elements\nis not."
      }
    },
    "26": {
      "nbr": 26,
      "value": "Which commands can include the following output? (Choose two.)\nJDK Internal API Suggested Replacement\nsun.misc.Unsafe See http://openjdk.java.net/jeps/260",
      "responses": [{
        "code": "A",
        "value": "jdeps sneaky.jar"
      }, {
        "code": "B",
        "value": "jdeps –j sneaky.jar"
      }, {
        "code": "C",
        "value": "jdeps –s sneaky.jar"
      }, {
        "code": "D",
        "value": "jdeps ‐‐internals sneaky.jar"
      }, {
        "code": "E",
        "value": "jdeps ‐jdkinternals sneaky.jar"
      }, {
        "code": "F",
        "value": "jdeps ‐‐jdk‐internals sneaky.jar"
      }
      ],
      "answer": {
        "codes": [
          "E",
          "F"
        ],
        "explanation": "26. E,F. Options B and D are incorrect because those flags do not exist on the\njdeps command. Options A and C do exist, but do not include suggested\nreplacements. Options E and F are correct as they will include a table of\nsuggestions if any internal APIs are used in the JAR."
      }
    },
    "27": {
      "nbr": 27,
      "value": "What is the output of the following?\npublic class Legos {\npublic static void main(String[] args) {\nvar ok = true;\nif (ok) {\nStringBuilder sb = new StringBuilder();\nsb.append(\"red\");\nsb.deleteCharAt(0);\nsb.delete(1, 1);\n}\nSystem.out.println(sb);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "r"
      }, {
        "code": "B",
        "value": "e"
      }, {
        "code": "C",
        "value": "ed"
      }, {
        "code": "D",
        "value": "red"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "27. E. This code does not compile because the println() attempts to\nreference the sb variable. However, that variable is only in scope for the if\nstatement. Since the code does not compile, option E is correct. If the\nprintln() were inside the if statement, option C would be correct."
      }
    },
    "28": {
      "nbr": 28,
      "value": "What is the output of the following when run as java EchoFirst.java\nseed flower plant?\nimport java.util.*;\npublic class EchoFirst {\npublic static void main(String[] args) {\nArrays.sort(args);\nvar result = Arrays.binarySearch(args, args[0]);\nSystem.out.println(result);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "1"
      }, {
        "code": "C",
        "value": "2"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "F",
        "value": "The output is not guaranteed."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "28. A. This class is called with three command‐line arguments. First, the array\nis sorted, which meets the pre‐condition for binary search. At this point, the\narray contains [flower, plant, seed]. The key is to notice the value of\nargs[0] is now flower rather than seed. Calling a binary search to find the\nposition of flower returns 0, which is the index matching that value.\nTherefore, the answer is option A."
      }
    },
    "29": {
      "nbr": 29,
      "value": "How many lines of the following declaration contain a compiler error?\n1: import java.lang.annotation.*;\n2: @Inherited\n3: public @interface Panic {\n4: public abstract alert() default 10;\n5: public final static int alarm_volume = 10;\n6: String[] type() default {\"test\"};\n7: Long range();\n8: abstract boolean silent();\n9: }",
      "responses": [{
        "code": "A",
        "value": "None."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }, {
        "code": "F",
        "value": "Five."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "29. C. Line 4 is missing a type for the element. If a compatible type, such as\nint, was added before alert(), it would compile. An annotation element\ntype must be a primitive type, a String, a Class, an enum, another\nannotation, or an array of any of these types. For this reason, line 6\ncompiles, and line 7 does not. Since lines 4 and 7 are the only lines that do\nnot compile, option C is correct. Notice that lines 5 and 8 use a lot of extra\nmodifiers, like public and abstract, that are usually applied implicitly."
      }
    },
    "30": {
      "nbr": 30,
      "value": "What is the output of the method that main() calls?\npublic class Hippo {\nprivate static void hippo(short num1, short num2) {\nSystem.out.println(\"shorts\");\n}\nprivate static void hippo(int… nums) {\nSystem.out.println(\"varargs\");\n}\nprivate void hippo(long num1, long num2) {\nSystem.out.println(\"longs\");\n}\nprivate void hippo(int num1, int num2) {\nSystem.out.println(\"nums\");\n}\npublic static void main(String… args) {\nhippo(1, 5);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "longs"
      }, {
        "code": "B",
        "value": "nums"
      }, {
        "code": "C",
        "value": "shorts"
      }, {
        "code": "D",
        "value": "varargs"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "30. D. This code is tricky. Java picks the most specific method signature it can\nfind in an overloading situation. Normally, that would be the one with the\ntwo int parameters. However, that method is an instance method, and the\nmain() method is looking for a static method. The next choice is the\nvarargs one, making option D the answer."
      }
    },
    "31": {
      "nbr": 31,
      "value": "Suppose you have a consumer that calls the lion() method within a Lion\nservice. You have four distinct modules: consumer, service locator, service\nprovider, and service provider interface. If you add a parameter to the\nlion() method, how many of the modules require recompilation?",
      "responses": [{
        "code": "A",
        "value": "Zero."
      }, {
        "code": "B",
        "value": "One."
      }, {
        "code": "C",
        "value": "Two."
      }, {
        "code": "D",
        "value": "Three."
      }, {
        "code": "E",
        "value": "Four."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "31. D. The service provider interface clearly needs to be recompiled, since\nthat's where the change occurs. The service provider also needs to be\nrecompiled because it implements the interface. Finally, the consumer\nneeds to be recompiled because it calls the interface. The service locator\ndoes not need to be recompiled as it only knows the service provider\ninterface name rather than its method signature. Since three require\nrecompilation, option D is correct."
      }
    },
    "32": {
      "nbr": 32,
      "value": "Which annotations will trigger a compiler error if incorrectly applied to a\nmethod with no other annotations? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "@Documented"
      }, {
        "code": "B",
        "value": "@Deprecated"
      }, {
        "code": "C",
        "value": "@SuppressWarnings(\"unchecked\")"
      }, {
        "code": "D",
        "value": "@Override"
      }, {
        "code": "E",
        "value": "@SuppressWarnings(\"magic\")"
      }, {
        "code": "F",
        "value": "@SafeVarargs"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "F"
        ],
        "explanation": "32. A,D,F. @Documented can be applied only to annotations, not methods,\nmaking option A correct. If @Override is applied to a method that is not\nactually overridden, a compiler error will ensue, making option D correct.\nThe @SafeVarargs annotation will trigger a compiler error if applied to a\nmethod without a vararg parameter or without a final, private, or static\nmodifier, making option F correct. The rest of the annotations can be\napplied to methods without triggering a compiler error. For option E, the\ncompiler might not recognize the cause (such as magic), but it will still\ncompile."
      }
    },
    "33": {
      "nbr": 33,
      "value": "Which of the following cannot be instantiated directly by the caller using\nthe constructor? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Locale"
      }, {
        "code": "B",
        "value": "ResourceBundle"
      }, {
        "code": "C",
        "value": "Locale.Builder"
      }, {
        "code": "D",
        "value": "Properties"
      }, {
        "code": "E",
        "value": "DateTimeFormatter"
      }, {
        "code": "F",
        "value": "HashMap"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "33. B,E. The Locale class has a constructor taking a language code and an\noptional country code. A Locale.Builder is created only using a\nconstructor. The Properties and HashMap classes are concrete types of Map,\nso they have constructors. By contrast, a ResourceBundle is an abstract\nclass, and instances are typically obtained by calling the\nResourceBundle.getBundle() method, making option B correct. Similarly,\nDateTimeFormatter is obtained using a static method, making option E\ncorrect."
      }
    },
    "34": {
      "nbr": 34,
      "value": "Which lines fail to compile?\npackage armory;\nimport java.util.function.*;\ninterface Shield {\nvoid protect();\n}\nclass Dragon {\nint addDragon(Integer count) {\nreturn ++count;\n}\n}\npublic class Sword {\npublic static void main(String[] knight) {\nvar dragon = new Dragon();\nFunction<Shield, Sword> func = Shield::protect; //\nline x\nUnaryOperator<Integer> op = dragon::addDragon; //\nline y\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Only line x"
      }, {
        "code": "B",
        "value": "Only line y"
      }, {
        "code": "C",
        "value": "Both lines x and y"
      }, {
        "code": "D",
        "value": "The code compiles."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "34. A. The method reference on line x is supposed to define a Function. The\nShield interface does define a single abstract method. However, that\nmethod has a void return type, which is not compatible with Function.\nLine y does compile since addDragon() has both a parameter and return\ntype. Option A is the answer, since only line x fails to compile."
      }
    },
    "35": {
      "nbr": 35,
      "value": "Fill in the blanks: The operators +=, ______, ______, _______, _______,\nand ‐‐ are listed in increasing or the same level of operator precedence.\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "^, *, =, ++"
      }, {
        "code": "B",
        "value": "%, *, /, &&"
      }, {
        "code": "C",
        "value": "=, +, /, *"
      }, {
        "code": "D",
        "value": "^, *, ==, ++"
      }, {
        "code": "E",
        "value": "*, /, %, ++"
      }, {
        "code": "F",
        "value": "<=, >=, !=, !"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "35. C,E. In option A, the assignment operator (=) incorrectly comes after the\nmultiplication (*) operator. In option B, the short‐circuit logical operator\n(&&) incorrectly comes after the division (/) operator. In option D, the\nequality operator (==) incorrectly comes after the multiplication (*)\noperator. In option F, the not equals operator (!=) incorrectly comes after\nthe relational operators, (<= and >=). This leaves options C and E as the\ncorrect answers. For these answers, it may help to remember that the\nmodulus operator (%), multiplication operator (*), and division operator (/)\nhave the same operator precedence."
      }
    },
    "36": {
      "nbr": 36,
      "value": "What is the result of the following?\n1: import java.util.function.*;\n2: public class Ready {\n3: private static double getNumber() {\n4: return .007;\n5: }\n6: public static void main(String[] args) {\n7: Supplier<double> s = Ready::getNumber;\n8: double d = s.get();\n9: System.out.println(d);\n10: }\n11: }",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "0.007"
      }, {
        "code": "C",
        "value": "The code does not compile due to line 7."
      }, {
        "code": "D",
        "value": "The code does not compile due to line 8."
      }, {
        "code": "E",
        "value": "The code does not compile for another reason."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "36. C. You can't use generics with a primitive, so it should be\nSupplier<Double>. This makes option C the answer. If this were fixed,\noption B would be the answer."
      }
    },
    "37": {
      "nbr": 37,
      "value": "What is the result of the following?\nimport java.util.stream.*;\npublic class StreamOfStreams {\npublic static void main(String[] args) {\nvar result =\nStream.of(getNums(9, 8), getNums(22, 33)) // c1\n.flatMap(x -> x) // c2\n.map((a, b) -> a - b) // c3\n.filter(x -> !x.isEmpty()) // c4\n.get();\nSystem.out.println(result);\n}\nprivate static Stream<Integer> getNums(int num1, int\nnum2) {\nreturn Stream.of(num1, num2);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code compiles and outputs 1."
      }, {
        "code": "B",
        "value": "The code compiles and outputs 8."
      }, {
        "code": "C",
        "value": "The first compiler error is on line c1."
      }, {
        "code": "D",
        "value": "The first compiler error is on line c2."
      }, {
        "code": "E",
        "value": "The first compiler error is on line c3."
      }, {
        "code": "F",
        "value": "The first compiler error is on line c4."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "37. E. Line c1 correctly creates a stream containing two streams. Line c2 uses\nflatMap() to create a Stream of four Integer objects. The first problem is\non line c3, which tries to use the numbers as if they are still pairs. Since we\nhave a Stream<Integer> at that point, the code does not compile, and\noption E is the answer. Line c4 does not compile either as you can't call a\nList method on an Integer."
      }
    },
    "38": {
      "nbr": 38,
      "value": "Given that FileNotFoundException is a subclass of IOException and Long\nis a subclass of Number, what is the output of the following application?\npackage materials;\nimport java.io.*;\nclass CarbonStructure {\nprotected long count;\npublic abstract Number getCount() throws IOException;\n// q1\npublic CarbonStructure(int count) { this.count = count;\n}\n}\npublic class Diamond extends CarbonStructure {\npublic Diamond() { super(15); }\npublic Long getCount() throws FileNotFoundException { //\nq2\nreturn count;\n}\npublic static void main(String[] cost) {\ntry {\nfinal CarbonStructure ring = new Diamond(); // q3\nSystem.out.print(ring.getCount()); // q4\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "15"
      }, {
        "code": "B",
        "value": "It does not compile because of line q1."
      }, {
        "code": "C",
        "value": "It does not compile because of line q2."
      }, {
        "code": "D",
        "value": "It does not compile because of line q3."
      }, {
        "code": "E",
        "value": "It does not compile because of line q4."
      }, {
        "code": "F",
        "value": "The class compiles but produces an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "38. B. This problem appears to be about overriding a method, but in fact, it is\nmuch simpler. The class CarbonStructure is not declared abstract, yet it\nincludes an abstract method. To fix it, the definition of CarbonStructure\nwould have to be changed to be an abstract class, or the abstract modifier\nwould need to be removed from getCount() in CarbonStructure and a\nmethod body added. Since the only answer choice available is to change the\ngetCount() method on line q1, option B is the correct answer. Note that the\nrest of the application, including the override on line q2, is correct and\ncompiles without issue. The return types Long and Number are covariant\nsince Number is a superclass of Long. Likewise, the exception thrown in the\nsubclass method is narrower, so no compilation error occurs on q2."
      }
    },
    "39": {
      "nbr": 39,
      "value": "Which of the following statements about InputStream and Reader are\ncorrect? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "They are both abstract classes."
      }, {
        "code": "B",
        "value": "They can both be used to read character data."
      }, {
        "code": "C",
        "value": "One contains a read() method that returns a byte value, while the\nother contains a read() method that returns a char value."
      }, {
        "code": "D",
        "value": "They are both interfaces."
      }, {
        "code": "E",
        "value": "Only one of them contains a flush() method."
      }, {
        "code": "F",
        "value": "Only one of them contains a skip() method."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "B"
        ],
        "explanation": "39. A,B. First, they are both classes, not interfaces, making option A correct\nand option D incorrect. Next, while it is more common to use Reader for\ncharacter data, InputStream and Reader are both capable of reading\ncharacter data, making option B correct. Option C is incorrect, as both\nclasses contain a read() method that returns an int value. As you may\nrecall from your studies, neither use byte or char so that ‐1 can be returned\nwhen the end of the stream is reached without using an existing byte or\nchar value. Option E is incorrect because neither contains a flush()\nmethod, while option F is incorrect because they both contain a skip()\nmethod."
      }
    },
    "40": {
      "nbr": 40,
      "value": "Which are true statements about interfaces and abstract classes? (Choose\nthree.)",
      "responses": [{
        "code": "A",
        "value": "Abstract classes offer support for single inheritance, while interfaces\noffer support for multiple inheritance."
      }, {
        "code": "B",
        "value": "All methods in abstract classes are public, while interfaces can use\nvarious access modifiers for their methods and variables, including\nprivate in some cases."
      }, {
        "code": "C",
        "value": "Both abstract classes and interfaces can have abstract methods."
      }, {
        "code": "D",
        "value": "Both abstract classes and interfaces can have public constructors."
      }, {
        "code": "E",
        "value": "Interfaces can only extend other interfaces, while abstract classes can\nextend both abstract and concrete classes."
      }, {
        "code": "F",
        "value": "Unlike abstract classes, interfaces can be marked final."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "E"
        ],
        "explanation": "40. A,C,E. Option B is incorrect as abstract classes allow any of the access\nmodifiers. Option D is incorrect because interfaces do not have\nconstructors. Option F is incorrect because neither abstract classes nor\ninterfaces can be marked final. Options A, C, and E are true statements."
      }
    },
    "41": {
      "nbr": 41,
      "value": "What is the output of the following?\nvar builder = new StringBuilder(\"Leaves growing\");\ndo {\nbuilder.delete(0, 5);\n} while (builder.length()> 5);\nSystem.out.println(builder);",
      "responses": [{
        "code": "A",
        "value": "Leaves growing"
      }, {
        "code": "B",
        "value": "ing"
      }, {
        "code": "C",
        "value": "wing"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "41. C. On the first iteration through the loop, the first five characters are\nremoved, and builder becomes \"s growing\". Since there are more than\nfive characters left, the loop iterates again. This time, five more characters\nare removed, and builder becomes \"wing\". This matches option C."
      }
    },
    "42": {
      "nbr": 42,
      "value": "Which of the following statements about nested classes are correct?\n(Choose three.)",
      "responses": [{
        "code": "A",
        "value": "An anonymous class can declare that it implements multiple interfaces."
      }, {
        "code": "B",
        "value": "All nested classes can contain constant variables."
      }, {
        "code": "C",
        "value": "A local class can declare that it implements multiple interfaces."
      }, {
        "code": "D",
        "value": "A member inner class can contain static methods."
      }, {
        "code": "E",
        "value": "A static nested class can contain static methods."
      }, {
        "code": "F",
        "value": "A local class can access all local variables prior to its declaration\nwithin a method."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "E"
        ],
        "explanation": "42. B,C,E. Options B, C, and E are valid statements about nested classes. An\nanonymous class can declare only one supertype, either a class or an\ninterface, making option A incorrect. A member inner class cannot contain\nstatic methods, making option B incorrect. A local class can access only\nfinal and effectively final local variables, making option F incorrect."
      }
    },
    "43": {
      "nbr": 43,
      "value": "Starting with DoubleBinaryOperator and going downward, fill in the\nvalues for the table.\nFunctional Interface # Parameters in Method Signature\nDoubleBinaryOperator\nLongToIntFunction\nToLongBiFunction\nIntSupplier\nObjLongConsumer",
      "responses": [{
        "code": "A",
        "value": "1, 0, 0, 0, 2"
      }, {
        "code": "B",
        "value": "1, 2, 1, 0, 1"
      }, {
        "code": "C",
        "value": "2, 1, 0, 1, 2"
      }, {
        "code": "D",
        "value": "2, 1, 1, 0, 1"
      }, {
        "code": "E",
        "value": "2, 1, 2, 0, 2"
      }, {
        "code": "F",
        "value": "3, 0, 2, 1, 1"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "43. E. DoubleBinaryOperator takes two double values and returns a double\nvalue. LongToIntFunction takes one long value and returns an int value.\nToLongBiFunction takes two generic arguments and returns a long value.\nIntSupplier does not take any values and returns an int value.\nObjLongConsumer takes one generic and one long value and does not return\na value. For these reasons, option E is the correct answer."
      }
    },
    "44": {
      "nbr": 44,
      "value": "Which of the following methods can run without error for at least one SQL\nquery?\nprivate static void choices(PreparedStatement ps,\nString sql) throws SQLException {\ntry (var rs = ps.executeQuery()) {\nSystem.out.println(rs.getInt(1));\n}\n}\nprivate static void moreChoices(PreparedStatement ps,\nString sql) throws SQLException {\ntry (var rs = ps.executeQuery()) {\nrs.next();\nSystem.out.println(rs.getInt(1));\n}\n}\nprivate static void stillMoreChoices(PreparedStatement ps,\nString sql) throws SQLException {\ntry (var rs = ps.executeQuery()) {\nif (rs.next())\nSystem.out.println(rs.getInt(1));\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "moreChoices()"
      }, {
        "code": "B",
        "value": "stillMoreChoices()"
      }, {
        "code": "C",
        "value": "choices() and stillMoreChoices()"
      }, {
        "code": "D",
        "value": "moreChoices() and stillMoreChoices()"
      }, {
        "code": "E",
        "value": "All three methods"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "44. D. The most common approach is stillMoreChoices(), which works for\nany SELECT statement that has an int in the first column. If the SELECT\nstatement has a function like count(*) or sum(*) in the first column, there\nwill always be a row in the ResultSet, so moreChoices() works as well.\nTherefore, option D is the answer."
      }
    },
    "45": {
      "nbr": 45,
      "value": "What is true of the following method?\npublic void printColor() {\nSystem.out.println(color);\n}",
      "responses": [{
        "code": "A",
        "value": "It is a correctly implemented accessor method."
      }, {
        "code": "B",
        "value": "It is a correctly implemented mutator method."
      }, {
        "code": "C",
        "value": "It is an incorrectly implemented accessor method."
      }, {
        "code": "D",
        "value": "It is an incorrectly implemented mutator method."
      }, {
        "code": "E",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "45. E. This method does not set or return a value so it is not an accessor or\nmutator. Therefore, option E is correct."
      }
    },
    "46": {
      "nbr": 46,
      "value": "What can fill in the blank so the play() method can be called from all\nclasses in the com.mammal.eland package, but not the com.mammal.gopher\npackage?\npackage com.mammal;\npublic class Enrichment {\n_____ void play() {}\n}",
      "responses": [{
        "code": "A",
        "value": "Leave it blank"
      }, {
        "code": "B",
        "value": "private"
      }, {
        "code": "C",
        "value": "protected"
      }, {
        "code": "D",
        "value": "public"
      }, {
        "code": "E",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "46. E. Leaving it blank gives package‐private access. This would be the\ncorrect answer if the code we wanted to receive access were in the same\npackage. Since it is not, we would need modules in order to restrict the\naccess and option E is correct."
      }
    },
    "47": {
      "nbr": 47,
      "value": "Which of the following statements about performing a concurrent reduction\nare correct? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "If a collector is used, it must have the unordered characteristic."
      }, {
        "code": "B",
        "value": "The stream must operate on thread‐safe collections."
      }, {
        "code": "C",
        "value": "If the reduce() method is used with a lambda expression, then it\nshould be stateful."
      }, {
        "code": "D",
        "value": "The stream must inherit ParallelStream<T>."
      }, {
        "code": "E",
        "value": "The stream must be parallel."
      }, {
        "code": "F",
        "value": "If a collector is used, it must have the concurrent characteristic."
      }
      ],
      "answer": {
        "codes": [
          "E",
          "F"
        ],
        "explanation": "47. E,F. To perform a concurrent reduction, the stream or the collector must\nbe unordered. Since it is possible to use an ordered collector with an\nunordered stream and achieve a parallel reduction, option A is incorrect.\nOption B is also incorrect. While having a thread‐safe collection is\npreferred, it is not required. Stateful lambda expressions should be avoided,\nwhether the stream is serial or parallel, making option C incorrect. Option\nD is incorrect as there is no class/interface within the JDK called\nParallelStream. Options E and F are correct statements about performing\nparallel reductions."
      }
    },
    "48": {
      "nbr": 48,
      "value": "Which of the following statements about java.lang.Error are most\naccurate? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "An Error should be thrown if a file system resource becomes\ntemporarily unavailable."
      }, {
        "code": "B",
        "value": "An application should never catch an Error."
      }, {
        "code": "C",
        "value": "Error is a subclass of Exception, making it a checked exception."
      }, {
        "code": "D",
        "value": "It is possible to catch and handle an Error thrown in an application."
      }, {
        "code": "E",
        "value": "An Error should be thrown if a user enters invalid input."
      }, {
        "code": "F",
        "value": "Error is a subclass of RuntimeException, making it an unchecked\nexception."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "48. B,D. An Error indicates an unrecoverable problem. Options A and E are\nincorrect because the application could possibly recover. While it is\npossible to catch an Error, it is strongly recommended that an application\nnever do so, making options B and D correct. Finally, options C and F are\nincorrect because Error extends from Throwable, not Exception or\nRuntimeException, although it is an unchecked exception."
      }
    },
    "49": {
      "nbr": 49,
      "value": "Given the following classes, what is the output of the Watch program?\n1: class SmartWatch extends Watch {\n2: private String getType() { return \"smart watch\"; }\n3: public String getName() {\n4: return getType() + \",\";\n5: }\n6: }\n7: public class Watch {\n8: private String getType() { return \"watch\"; }\n9: public String getName(String suffix) {\n10: return getType() + suffix;\n11: }\n12: public static void main(String[] args) {\n13: Watch watch = new Watch();\n14: Watch smartWatch = new SmartWatch();\n15: System.out.print(watch.getName(\",\"));\n16: System.out.print(smartWatch.getName(\"\"));\n17: }\n18: }",
      "responses": [{
        "code": "A",
        "value": "smart watch,smart watch"
      }, {
        "code": "B",
        "value": "smart watch,watch"
      }, {
        "code": "C",
        "value": "watch,smart watch"
      }, {
        "code": "D",
        "value": "watch,watch"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "49. D. Line 15 calls the method on line 9 since it is a Watch object, printing\nwatch. Line 16 is a SmartWatch object. However, the getName() method is\nnot overridden in SmartWatch, since the method signature is different.\nTherefore, the method on line 9 gets called again. That method calls\ngetType(). Since this is a private method, it is not overridden, and watch\nis printed again, making option D the correct answer."
      }
    },
    "50": {
      "nbr": 50,
      "value": "How many of the following lines contain a compiler error?\nlong min1= 123.0, max1 = 987L;\nfinal long min2 = 1_2_3, max2 = 9__8__7;\nlong min3 = 123, int max3 = 987;\nlong min4 = 123L, max4 = 987;\nlong min5 = 123_, max5 = _987;",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "50. D. A long cannot contain a number with decimal points, preventing min1\nfrom compiling. When declaring multiple variables in the same statement,\nthe type is only declared once. Therefore, max3 does not compile.\nUnderscores in numeric expressions are allowed as long as they are\nbetween two digits, making the line with min5 and max5 incorrect. Since\nthree lines have compiler errors, the answer is option D. The L suffix is\nvalid, as is having multiple underscores in a row."
      }
    }
  }
}, {
  "name": "Practice Exam 3",
  "questions": {
    "1": {
      "nbr": 1,
      "value": "What is the result of the following code?\n// Hopper.java\npackage com.animals;\npublic class Hopper {\nprotected void hop() {\nSystem.out.println(\"hop\");\n}\n}\n// Grasshopper.java\npackage com.insect;\nimport com.animals.Hopper;\npublic class Grasshopper extends Hopper {\npublic void move() {\nhop(); // p1\n}\n}\n// HopCounter.java\npackage com.animals;\npublic class HopCounter {\npublic static void main(String[] args) {\nvar hopper = new Grasshopper();\nhopper.move(); // p2\nhopper.hop(); // p3\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code prints hop once."
      }, {
        "code": "B",
        "value": "The code prints hop twice."
      }, {
        "code": "C",
        "value": "The first compiler error is on line p1."
      }, {
        "code": "D",
        "value": "The first compiler error is on line p2."
      }, {
        "code": "E",
        "value": "The first compiler error is on line p3."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "1. B. The hop() method has protected access, which allows subclasses to\ncall it, making line p1 compile. Additionally, code in the same package is\nallowed to access it, making lines p2 and p3 compile. The code compiles\nand runs without error, making option B the answer."
      }
    },
    "2": {
      "nbr": 2,
      "value": "Which of the following statements about try/catch blocks are correct?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "A catch block can never appear after a finally block."
      }, {
        "code": "B",
        "value": "A try block must be followed by a catch block."
      }, {
        "code": "C",
        "value": "A finally block can never appear after a catch block."
      }, {
        "code": "D",
        "value": "A try block must be followed by a finally block."
      }, {
        "code": "E",
        "value": "A try block can have zero or more catch blocks."
      }, {
        "code": "F",
        "value": "A try block can have zero or more finally blocks."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "2. A,E. A try block can have zero or more catch blocks, and zero or one\nfinally blocks, but must be accompanied by at least one of these blocks.\nFor these reasons, options B, D, and F are incorrect, and option E is correct.\nA finally block must appear after the last catch block, if there are any,\nmaking option C incorrect, and option A correct."
      }
    },
    "3": {
      "nbr": 3,
      "value": "Which statements are correct? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "A Comparable implementation is often implemented by a lambda."
      }, {
        "code": "B",
        "value": "A Comparable object has a compare() method."
      }, {
        "code": "C",
        "value": "The compare() and compareTo() methods have the same contract for\nthe return value."
      }, {
        "code": "D",
        "value": "It is possible to sort the same List using different Comparator\nimplementations."
      }, {
        "code": "E",
        "value": "Two objects that return true for equals() will always return 0 when\npassed to compareTo()."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D"
        ],
        "explanation": "3. C,D. Option A is incorrect because Comparable is implemented in the\nclass being compared. To be useful, such a class must have instance\nvariables to compare, ruling out a lambda. By contrast, a Comparator is\noften implemented with a lambda. Option B is incorrect because\ncompareTo() is the method in Comparable. Option C is correct because\nthese methods have different parameters but the same return type, with the\nsame rules for ordering elements. Option D is correct because a Comparator\ndoesn't need to be implemented by the class being compared. It can be\npassed to the sort() method as a parameter. Option E is incorrect because\ncomparators are not required to be consistent with the equals() method.\nFor example, two objects that are equivalent in terms of equals() may be\nsorted differently."
      }
    },
    "4": {
      "nbr": 4,
      "value": "How many lines does this code output?\nimport java.util.*;\npublic class PrintNegative {\npublic static void main(String[] args) {\nList<Integer> list = new ArrayList<>();\nlist.add(-5);\nlist.add(0);\nlist.add(5);\nlist.removeIf(e -> e < 0);\nlist.forEach(x -> System.out.println(x));\n}\n}",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "Three."
      }, {
        "code": "D",
        "value": "None. It doesn't compile."
      }, {
        "code": "E",
        "value": "None. It throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "4. B. This is a correct example of using lambdas. The code creates an\nArrayList with three elements. Both lambdas are correct. The code\nremoves any negative numbers and prints out the remaining two numbers, 0\nand 5, making option B correct."
      }
    },
    "5": {
      "nbr": 5,
      "value": "How many lines need to be changed to make this code compile?\n1: public class Massage {\n2: var name = \"Sherrin\";\n3: public void massage(var num) {\n4: var zip = 10017;\n5: var underscores = 1_001_7;\n6: var _ = \"\";\n7: }\n8: }",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "5. D. Lines 2 and 3 do not compile because var can only be used for local\nvariables. Line 6 does not compile because a single underscore is not\npermitted as a variable name. These three compiler errors cause option D to\nbe the answer. Lines 4 and 5 use var correctly."
      }
    },
    "6": {
      "nbr": 6,
      "value": "Which two conditions best describe one or more threads that appear to be\nactive but are perpetually stuck and never able to finish their task? (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "Deadlock"
      }, {
        "code": "B",
        "value": "Livelock"
      }, {
        "code": "C",
        "value": "Loss of precision"
      }, {
        "code": "D",
        "value": "Out of memory error"
      }, {
        "code": "E",
        "value": "Race condition"
      }, {
        "code": "F",
        "value": "Starvation"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "F"
        ],
        "explanation": "6. B,F. A deadlock and livelock both result in threads that cannot complete a\ntask, but only in a livelock do the threads appear active, making option A\nincorrect and option B correct. Options C and D are incorrect because they\ndo not apply to thread liveness. A race condition is an unexpected result\nwhen two threads, which should be run sequentially, are run at the same\ntime, leading to an unexpected result, making option E incorrect. Since\nlivelock is a special case of resource starvation, in which a single active\nthread is perpetually denied access to a shared resource or lock, option F is\nalso correct."
      }
    },
    "7": {
      "nbr": 7,
      "value": "How many lines of the following interface do not compile?\n15: public interface Piano {\n16: String type = \"Grand\";\n17: void play();\n18: public static int getNumberOfKeys() {\n19: return type.equals(\"Grand\") ? 88 : 61;\n20: }\n21: private static void printPianoInfo() {\n22: play();\n23: System.out.println(\"Key Count:\n\"+getNumberOfKeys());\n24: }\n25: default void tune() {\n26: play();\n27: printPianoInfo();\n28: } }",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "7. B. Line 22 does not compile because a static interface method cannot\ncall an instance‐based abstract method. Since this is the only line that\ndoes not compile, option B is correct."
      }
    },
    "8": {
      "nbr": 8,
      "value": "How many lines does the following code output?\nimport java.util.*;\npublic class Exams {\npublic static void main(String[] args) {\nList<String> exams = List.of(\"1Z0-817\", \"1Z0-819\");\nfor (var e : exams)\nfor (int i=exams.size(); i>0 ; i-=2)\nSystem.out.print(e+\" \"+exams.get(i));\nSystem.out.println();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "One."
      }, {
        "code": "B",
        "value": "Two."
      }, {
        "code": "C",
        "value": "Four."
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "F",
        "value": "The code compiles but enters an infinite loop at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "8. E. The first time the inner for loop is executed, it calls exams.get(i)\nwhere i is equal to exams.size(). Since the maximum element is indexed\nas exams.size()‐1, this results in an IndexOutOfBoundsException,\nmaking option E correct. Also, notice that there are no braces {} around the\ninner for loop; therefore, even without the exception, the most lines this\ncode would print would be one, since there's only one println() statement\nexecuted."
      }
    },
    "9": {
      "nbr": 9,
      "value": "How many lines of the main method fail to compile?\n10: public class Transport {\n11: static interface Vehicle {}\n12: static class Bus implements Vehicle {}\n13:\n14: public static void main(String[] args) {\n15: Bus bus = new Bus();\n16:\n17: System.out.println(null instanceof Bus);\n18: System.out.println(bus instanceof Vehicle);\n19: System.out.println(bus instanceof Bus);\n20: System.out.println(bus instanceof ArrayList);\n21: System.out.println(bus instanceof Collection);\n22: } }",
      "responses": [{
        "code": "A",
        "value": "None"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "9. B. You are allowed to use null with instanceof; it just prints false. The\nbus variable is both a Vehicle and a Bus, so lines 18 and 19 print true.\nThen it gets interesting. We know that bus is not an ArrayList or\nCollection. However, the compiler only knows that bus is not an\nArrayList because ArrayList is a concrete class. Line 20 does not\ncompile. The compiler can't definitively state that bus is not a Collection.\nSome future program could create a subclass of Bus that does implement\nCollection, so this line compiles. Therefore, only line 20 fails to compile,\nand option B is correct."
      }
    },
    "10": {
      "nbr": 10,
      "value": "Which of the following are true? (Choose two.)\n20: int[] crossword [] = new int[10][20];\n21: for (int i = 0; i < crossword.length; i++)\n22: for (int j = 0; j < crossword.length; j++)\n23: crossword[i][j] = 'x';\n24: System.out.println(crossword.size());",
      "responses": [{
        "code": "A",
        "value": "One line needs to be changed for this code to compile."
      }, {
        "code": "B",
        "value": "Two lines need to be changed for this code to compile."
      }, {
        "code": "C",
        "value": "Three lines need to be changed for this code to compile."
      }, {
        "code": "D",
        "value": "If the code is fixed to compile, none of the cells in the 2D array have a\nvalue of 0."
      }, {
        "code": "E",
        "value": "If the code is fixed to compile, half of the cells in the 2D array have a\nvalue of 0."
      }, {
        "code": "F",
        "value": "If the code is fixed to compile, all of the cells in the 2D array have a\nvalue of 0."
      }
      ],
      "answer": {
        "codes": [
          "A",
          "E"
        ],
        "explanation": "10. A,E. Line 24 does not compile because arrays use length. It is ArrayList\nthat uses size(). All of the other lines compile, making option A correct. It\nis permitted to split up the brackets, [], in the 2D array declaration on line"
      }
    },
    "11": {
      "nbr": 11,
      "value": "How many lines need to be changed to make this method compile?\n1: public void colors() {\n2: var yellow = \"\";\n3: yellow = null;\n4:\n5: var red = null;\n6:\n7: var blue = \"\";\n8: blue = 1;\n9:\n10: var var = \"\";\n11: var = \"\";\n12:\n13: var pink = 1;\n14: }",
      "responses": [{
        "code": "A",
        "value": "Zero"
      }, {
        "code": "B",
        "value": "One"
      }, {
        "code": "C",
        "value": "Two"
      }, {
        "code": "D",
        "value": "Three"
      }, {
        "code": "E",
        "value": "Four"
      }, {
        "code": "F",
        "value": "Five"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "11. C. Line 5 does not compile because the type of a variable cannot be\ninferred when the value is null. Line 8 does not compile because the type\ncannot be changed once the variable is declared. Therefore, option C is\ncorrect."
      }
    },
    "12": {
      "nbr": 12,
      "value": "What is the output of the following?\n10: var result = 8;\n11: monitor: while (result>= 7) {\n12: result++;\n13: do {\n14: result -= 2;\n15: continue monitor;\n16: } while (result> 5);\n17: }\n18: System.out.println(result);",
      "responses": [{
        "code": "A",
        "value": "5"
      }, {
        "code": "B",
        "value": "6"
      }, {
        "code": "C",
        "value": "7"
      }, {
        "code": "D",
        "value": "The code does not compile."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }, {
        "code": "F",
        "value": "The code compiles but enters an infinite loop at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "12. B. On line 10, result is first set to 8. On line 11, the loop is entered\nbecause 8 >= 7. On line 12, result is incremented to 9. Then the inner\nloop runs, decrementing result to 7. The inner loop is then broken by the\ncontinue monitor statement. The outer loop then evaluates the loop\ncondition. Since 7 >= 7, it runs again ending with the inner loop setting\nresult to 6. Since 6 >= 7 is false, the outer loop terminates after two\nexecutions and prints 6."
      }
    },
    "13": {
      "nbr": 13,
      "value": "Which of the following lambda expressions can be inserted into both blanks\nwhile still allowing the application to compile? (Choose three.)\npackage spooky;\nimport java.util.function.*;\nabstract class Phantom {\npublic void bustLater(DoubleConsumer buster, double\nvalue) {\nbuster.accept(value);\n}\n}\npublic class Ghost extends Phantom {\npublic void bustNow(Consumer<Double> buster, double\nvalue) {\nbuster.accept(value);\n}\nvoid call() {\nvar value = 10.0;\nbustNow(_______________, value);\nbustLater(_______________, value);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "System.out::print"
      }, {
        "code": "B",
        "value": "a ‐> {System.out.println(a.intValue());}"
      }, {
        "code": "C",
        "value": "g ‐> {System.out.println();}"
      }, {
        "code": "D",
        "value": "u ‐> System.out.println((long)u)"
      }, {
        "code": "E",
        "value": "v ‐> System.out.print(v)"
      }, {
        "code": "F",
        "value": "w ‐> System.out::println"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "E"
        ],
        "explanation": "13. A,C,E. To start with, bustNow() takes a Double value, while bustLater()\ntakes a double value. To be compatible, the lambda expression has to be\nable to handle both data types. Option A is correct, since the method\nreference System.out::print matches overloaded methods that can take\ndouble or a Double. Option E is also correct, as it's the equivalent rewrite of\noption A with a lambda expression. Option B is incorrect, since intValue()\nworks for the Consumer<Double>, which takes Double, but not\nDoubleConsumer, which takes double. For a similar reason, option D is also\nincorrect because only the primitive double is compatible with this\nexpression.\nOption C is correct and results in just a blank line being printed. Finally,\noption F is incorrect because of incompatible data types. The method\nreference code is inside of a lambda expression, which would only be\nallowed if the functional interface returned another functional interface\nreference."
      }
    },
    "14": {
      "nbr": 14,
      "value": "Given the following class structure, what is the proper way to create an\ninstance of Spinner inside the bake() method? (Choose three.)\npublic class Kitchen {\nclass Mixer {\nclass Spinner {}\n}\npublic void bake() {\n// INSERT CODE HERE\n}\n}",
      "responses": [{
        "code": "A",
        "value": "var a = new Kitchen().new Mixer().new Spinner();"
      }, {
        "code": "B",
        "value": "Mixer.Spinner b = Mixer.new Spinner();"
      }, {
        "code": "C",
        "value": "var c = new Spinner();"
      }, {
        "code": "D",
        "value": "var d = new Mixer().new Spinner();"
      }, {
        "code": "E",
        "value": "Kitchen.Mixer.Spinner e = new Kitchen().new Mixer().new\nSpinner();"
      }, {
        "code": "F",
        "value": "Spinner f = new Kitchen().new Mixer().new Spinner();"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "E"
        ],
        "explanation": "14. A,D,E. Mixer and Spinner are member inner classes that require an\ninstance of Kitchen and Mixer, respectively, to instantiate. Since bake() is\ndefined as an instance method of Kitchen, the Kitchen instance can be\nimplied. For this reason, option D is correct. Options A and E are also\ncorrect and rely on a new instance of Kitchen rather than the implied one.\nOptions B and C are incorrect because there is no instance of Mixer used.\nOption F is incorrect because the reference type Spinner is undefined\nwithout the names of the enclosing classes."
      }
    },
    "15": {
      "nbr": 15,
      "value": "Which line of code belongs in a service locator?",
      "responses": [{
        "code": "A",
        "value": "ServiceLoader<Mouse> sl = ServiceLoader.load(Mouse.class);"
      }, {
        "code": "B",
        "value": "ServiceLoader<Mouse> sl =\nServiceLoader.loader(Mouse.class);"
      }, {
        "code": "C",
        "value": "ServiceLoader<Mouse> sl =\nServiceLoader.lookup(Mouse.class);"
      }, {
        "code": "D",
        "value": "ServiceLocator<Mouse> sl = ServiceLoader.load(Mouse.class);"
      }, {
        "code": "E",
        "value": "ServiceLocator<Mouse> sl =\nServiceLoader.loader(Mouse.class);"
      }, {
        "code": "F",
        "value": "ServiceLocator<Mouse> sl =\nServiceLoader.lookup(Mouse.class);"
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "15. A. The service locator contains a ServiceLoader call to the load()\nmethod to look up the service loader, which is option A."
      }
    },
    "16": {
      "nbr": 16,
      "value": "Fill in the blanks: The __________ annotation determines whether\nannotations are retained in generated Javadoc, while the __________\nannotation determines the location an annotation can be applied. (Choose\ntwo.)",
      "responses": [{
        "code": "A",
        "value": "@Documented in the first blank"
      }, {
        "code": "B",
        "value": "@Javadoc in the first blank"
      }, {
        "code": "C",
        "value": "@Preserve in the first blank"
      }, {
        "code": "D",
        "value": "@Location in the second blank"
      }, {
        "code": "E",
        "value": "@Retention in the second blank"
      }, {
        "code": "F",
        "value": "@Target in the second blank"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "F"
        ],
        "explanation": "16. A,F. The @Documented annotation allows annotations to be included in\ngenerated Javadoc, while the @Target annotation determines the valid\nusage locations of an annotation. For these reasons, options A and F are\ncorrect."
      }
    },
    "17": {
      "nbr": 17,
      "value": "Which of the following use generics and compile without warnings?\n(Choose two.)",
      "responses": [{
        "code": "A",
        "value": "List<String> a = new ArrayList();"
      }, {
        "code": "B",
        "value": "List<> b = new ArrayList();"
      }, {
        "code": "C",
        "value": "List<String> c = new ArrayList<>();"
      }, {
        "code": "D",
        "value": "List<> d = new ArrayList<>();"
      }, {
        "code": "E",
        "value": "List<String> e = new ArrayList<String>();"
      }, {
        "code": "F",
        "value": "List<> f = new ArrayList<String>();"
      }
      ],
      "answer": {
        "codes": [
          "C",
          "E"
        ],
        "explanation": "17. C,E. The diamond operator, <>, is only allowed to be used when\ninstantiating rather than declaring. In other words, it can't go on the left side\nof the equals (=) sign. Therefore, options B, D, and F are incorrect. The\nremaining three options compile. However, option A produces a warning\nbecause generics are not used on the right side of the assignment operator.\nTherefore, options C and E are correct. Option C is preferred over option E,\nsince it uses the diamond operator rather than specifying a redundant type."
      }
    },
    "18": {
      "nbr": 18,
      "value": "Which of the following changes, when applied independently, will print the\nsame result as the original implementation? (Choose two.)\n10: long sum = IntStream.of(4, 6, 8)\n11: .boxed()\n12: .parallel()\n13: .mapToInt(x -> x)\n14: .sum();\n15: System.out.print(sum);",
      "responses": [{
        "code": "A",
        "value": "Change the type on line 10 to double"
      }, {
        "code": "B",
        "value": "Change the type on line 10 to int"
      }, {
        "code": "C",
        "value": "Change line 11 to unboxed()"
      }, {
        "code": "D",
        "value": "Remove line 11"
      }, {
        "code": "E",
        "value": "Remove line 12"
      }, {
        "code": "F",
        "value": "Remove line 13"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "E"
        ],
        "explanation": "18. B,E. The original implementation compiles and prints 18. When using an\nIntStream, the sum() method returns an int. This makes option B correct\nas both an int and a long will print 18. By contrast, option A is incorrect\nbecause a double will print 18.0. Removing line 11 causes the code to not\ncompile on line 13 since mapToInt() is not defined on IntStream (the\nstream is already made of int values), making option D incorrect.\nRemoving line 13 causes the code to not compile on line 14, as sum() is\nonly defined on primitive streams, not Stream<Integer>, making option F\nincorrect. Option E is the remaining correct answer. Running operations in\nparallel for such a tiny list is not helpful, but it does not change the result."
      }
    },
    "19": {
      "nbr": 19,
      "value": "What does the following code print?\n// Hare.java\npackage com.animal;\npublic class Hare {\nvoid init() {\nSystem.out.print(\"init-\");\n}\nprotected void race() {\nSystem.out.print(\"hare-\");\n}\n}\n// Tortoise.java\npackage com.animal;\npublic class Tortoise {\nprotected void race(Hare hare) {\nhare.init(); // x1\nhare.race(); // x2\nSystem.out.print(\"tortoise-\");\n}\npublic static void main(String[] args) {\nvar tortoise = new Tortoise();\nvar hare = new Hare();\ntortoise.race(hare);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "init‐hare‐tortoise"
      }, {
        "code": "B",
        "value": "init‐hare"
      }, {
        "code": "C",
        "value": "The first line with a compiler error is line x1."
      }, {
        "code": "D",
        "value": "The first line with a compiler error is line x2."
      }, {
        "code": "E",
        "value": "The code does not compile due to a different line."
      }, {
        "code": "F",
        "value": "The code throws an exception."
      }
      ],
      "answer": {
        "codes": [
          "A"
        ],
        "explanation": "19. A. The init() method is accessible from the same package. The race()\nmethod is available from the same package or subclasses. Since Tortoise is\nin the same package, both methods are available and option A is correct."
      }
    },
    "20": {
      "nbr": 20,
      "value": "Which statements are true about the requires directive? (Choose two.)",
      "responses": [{
        "code": "A",
        "value": "Changing it to a requires direct directive is always allowed."
      }, {
        "code": "B",
        "value": "Changing it to a requires direct directive is never allowed."
      }, {
        "code": "C",
        "value": "Changing it to a requires direct directive is sometimes allowed."
      }, {
        "code": "D",
        "value": "Including requires java.base is allowed, but redundant."
      }, {
        "code": "E",
        "value": "Including requires java.base is never allowed."
      }, {
        "code": "F",
        "value": "Including requires java.base is sometimes needed to change the\nmeaning of a file."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "20. B,D. There is not a requires direct directive, making option B correct.\nIf the requires transitive directive where used in the answer options\ninstead, option A would be the answer, since it represents a superset of the\nfunctionality. Additionally, option D is correct because java.base is\nimplied whether you specify it or not."
      }
    },
    "21": {
      "nbr": 21,
      "value": "What is the output of the following?\n1: package reader;\n2: import java.util.stream.*;\n3:\n4: public class Books {\n5: public static void main(String[] args) {\n6: IntStream pages = IntStream.of(200, 300);\n7: long total = pages.sum();\n8: long count = pages.count();\n9: System.out.println(total + \"-\" + count);\n10: }\n11: }",
      "responses": [{
        "code": "A",
        "value": "2‐2"
      }, {
        "code": "B",
        "value": "200‐1"
      }, {
        "code": "C",
        "value": "500‐0"
      }, {
        "code": "D",
        "value": "500‐2"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "21. F. When summing int primitives, the return type is also an int. Since a\nlong is larger, you can assign the result to it, so line 7 is correct. All the\nprimitive stream types use long as the return type for count(). Therefore,\nthe code compiles, and option E is incorrect. When actually running the\ncode, line 8 throws an IllegalStateException because the stream has\nalready been used. Both sum() and count() are terminal operations, and\nonly one terminal operation is allowed on the same stream. Therefore,\noption F is the answer."
      }
    },
    "22": {
      "nbr": 22,
      "value": "What is the output of the following?\npublic class InitOrder {\n{ System.out.print(\"1\"); }\nstatic { System.out.print(\"2\"); }\npublic InitOrder() {\nSystem.out.print(\"3\");\n}\npublic static void callMe() {\nSystem.out.print(\"4\");\n}\npublic static void main(String[] args) {\ncallMe();\ncallMe();\nSystem.out.print(\"5\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "1223445"
      }, {
        "code": "B",
        "value": "2445"
      }, {
        "code": "C",
        "value": "22445"
      }, {
        "code": "D",
        "value": "223445"
      }, {
        "code": "E",
        "value": "2233445"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "22. B. This class is never instantiated, so the instance initializer never outputs\n1, and the constructor never outputs 3. This rules out options A, D, and E. A\nstatic initializer runs only once for the class, which rules out option C.\nOption B is correct because the static initializer runs once printing 2,\nfollowed by the static method callMe() printing 4 twice, and ending with\nthe main() method printing 5."
      }
    },
    "23": {
      "nbr": 23,
      "value": "What is the output of the following application? Assume the file system is\navailable and able to be written to and read from.\npackage boat;\nimport java.io.*;\npublic class Cruise {\nprivate int numPassengers = 1;\nprivate transient String schedule = \"NONE\";\n{ numPassengers = 2; }\npublic Cruise() {\nthis.numPassengers = 3;\nthis.schedule = \"Tropical Island\";\n}\npublic static void main(String… p) throws Exception {\nfinal String f = \"ship.txt\";\ntry (var o = new ObjectOutputStream(\nnew FileOutputStream(f))) {\nCruise c = new Cruise();\nc.numPassengers = 4;\nc.schedule = \"Casino\";\no.writeObject(c);\n}\ntry (var i = new ObjectInputStream(\nnew FileInputStream(f))) {\nCruise c = i.readObject();\nSystem.out.print(c.numPassengers + \",\" +\nc.schedule);\n} } }",
      "responses": [{
        "code": "A",
        "value": "2,NONE"
      }, {
        "code": "B",
        "value": "3,null"
      }, {
        "code": "C",
        "value": "4,Casino"
      }, {
        "code": "D",
        "value": "4,null"
      }, {
        "code": "E",
        "value": "One line would need to be fixed for this code to run without throwing\nan exception."
      }, {
        "code": "F",
        "value": "Two lines would need to be fixed for this code to run without throwing\nan exception."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "23. F. The readObject() method returns an Object instance, which must be\nexplicitly cast to Cruise in the second try‐with‐resources statement. For this\nreason, the code does not compile. If the explicit cast was added, the code\nwould compile but throw a NotSerializableException at runtime, since\nCruise does not implement the Serializable interface. For this reason,\noption F is correct. If both of these issues were fixed, then the code would\nrun and print 4,null. The schedule variable is marked transient, so it\ndefaults to null when deserialized, while numPassengers is assigned the\nvalue it had when it was serialized. Remember that on deserialization, the\nconstructors and instance initializers are not executed."
      }
    },
    "24": {
      "nbr": 24,
      "value": "What does ServiceLocator.load(ChocolateLab.class) return?",
      "responses": [{
        "code": "A",
        "value": "Collection"
      }, {
        "code": "B",
        "value": "List"
      }, {
        "code": "C",
        "value": "Stream"
      }, {
        "code": "D",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "24. D. The load() method is on ServiceLoader, not ServiceLocator.\nTherefore, option D is the answer."
      }
    },
    "25": {
      "nbr": 25,
      "value": "Fill in the blanks: Because of ___________, it is possible to ___________ a\nmethod, which allows Java to support ___________.",
      "responses": [{
        "code": "A",
        "value": "abstract methods, override, inheritance"
      }, {
        "code": "B",
        "value": "virtual methods, override, polymorphism"
      }, {
        "code": "C",
        "value": "concrete methods, overload, inheritance"
      }, {
        "code": "D",
        "value": "virtual methods, overload, interfaces"
      }, {
        "code": "E",
        "value": "inheritance, abstract, polymorphism"
      }, {
        "code": "F",
        "value": "abstract methods, inherit, multiple inheritance"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "25. B. For this question, it helps to try all answers out. Most of them do not\nmake any sense. For example, overloading a method is not a facet of\ninheritance. Likewise, concrete and abstract methods can both be\noverridden, not just one. The only answer that is valid is option B. Without\nvirtual methods, overriding a method would not be possible, and Java\nwould not truly support polymorphism."
      }
    },
    "26": {
      "nbr": 26,
      "value": "What is true about the following?\nimport java.util.*;\npublic class Yellow {\npublic static void main(String[] args) {\nList list = Arrays.asList(\"Sunny\");\nmethod(list); // c1\n}\nprivate static void method(Collection<?> x) { // c2\nx.forEach(a -> {}); // c3\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code doesn't compile due to line c1."
      }, {
        "code": "B",
        "value": "The code doesn't compile due to line c2."
      }, {
        "code": "C",
        "value": "The code doesn't compile due to line c3."
      }, {
        "code": "D",
        "value": "The code compiles and runs without output."
      }, {
        "code": "E",
        "value": "The code compiles but throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "26. D. This code actually does compile. Line c1 is fine because the method\nuses the ? wildcard, which allows any collection. Line c2 is a standard\nmethod declaration. Line c3 looks odd, but it does work. The lambda takes\none parameter and does nothing with it. Since there is no output, option D is\ncorrect."
      }
    },
    "27": {
      "nbr": 27,
      "value": "What is the output of the following application?\nabstract class TShirt {\nabstract int insulate();\npublic TShirt() {\nSystem.out.print(\"Starting…\");\n}\n}\npublic class Wardrobe {\nabstract class Sweater extends TShirt {\nint insulate() {return 5;}\n}\nprivate void dress() {\nfinal class Jacket extends Sweater { // v1\nint insulate() {return 10;}\n};\nfinal TShirt outfit = new Jacket() { // v2\nint insulate() {return 20;}\n};\nSystem.out.println(\"Insulation:\"+outfit.insulate());\n}\npublic static void main(String… snow) {\nnew Wardrobe().dress();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Starting…Insulation:20"
      }, {
        "code": "B",
        "value": "Starting…Insulation:40"
      }, {
        "code": "C",
        "value": "The code does not compile because of line v1."
      }, {
        "code": "D",
        "value": "The code does not compile because of line v2."
      }, {
        "code": "E",
        "value": "The code does not compile for a different reason."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "27. D. The code does not compile because the Jacket is marked final and\ncannot be extended by the anonymous class declared on line v2. Since this\nline doesn't compile, option D is correct. If the final modifier were\nremoved from line v1, then the code would compile and print Starting…\nInsulation:20 at runtime."
      }
    },
    "28": {
      "nbr": 28,
      "value": "Suppose we have a peacocks table with two columns: name and rating.\nWhat does the following code output if the table is empty?\nvar url = \"jdbc:derby:birds\";\nvar sql = \"SELECT name FROM peacocks WHERE name = ?\";\ntry (var conn = DriverManager.getConnection(url);\nvar stmt = conn.prepareStatement(sql)) { // s1\nstmt.setString(1, \"Feathers\");\ntry (var rs = stmt.executeQuery()) { // s2\nwhile (rs.hasNext()) {\nSystem.out.println(rs.next());\n}\n}\n}",
      "responses": [{
        "code": "A",
        "value": "false"
      }, {
        "code": "B",
        "value": "true"
      }, {
        "code": "C",
        "value": "The code does not compile due to line s1."
      }, {
        "code": "D",
        "value": "The code does not compile due to line s2."
      }, {
        "code": "E",
        "value": "The code does not compile due to another line."
      }, {
        "code": "F",
        "value": "The code throws an exception at runtime."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "28. E. The ResultSet interface does not have a hasNext() method. Since the\ncode does not compile due to a line without a comment, option E is the\nanswer."
      }
    },
    "29": {
      "nbr": 29,
      "value": "What is the output of the following application?\npackage ballroom;\npublic class Dance {\npublic static void swing(int… beats)\nthrows ClassCastException {\ntry {\nSystem.out.print(\"1\"+beats[2]); // p1\n} catch (RuntimeException e) {\nSystem.out.print(\"2\");\n} catch (Exception e) {\nSystem.out.print(\"3\");\n} finally {\nSystem.out.print(\"4\");\n}\n}\npublic static void main(String… music) {\nnew Dance().swing(0,0); // p2\nSystem.out.print(\"5\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "145"
      }, {
        "code": "B",
        "value": "1045"
      }, {
        "code": "C",
        "value": "24, followed by a stack trace"
      }, {
        "code": "D",
        "value": "245"
      }, {
        "code": "E",
        "value": "The code does not compile because of line p1."
      }, {
        "code": "F",
        "value": "The code does not compile because of line p2."
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "29. D. The code compiles without issue, so options E and F are incorrect. Note\nthat line p2 accesses a static method using an instance reference, which is\ndiscouraged but permitted in Java. First, a varargs int array of [0,0] is\npassed to the swing() method. The try block throws\nArrayIndexOutOfBoundsException, since the third element is requested\nand the size of the array is two. For this reason, the print() statement in\nthe try block is not executed.\nNext, since ArrayIndexOutOfBoundsException is a subclass of\nRuntimeException, the RuntimeException catch block is executed, and 2\nis printed. The rest of the catch blocks are skipped, since the first one was\nselected. The finally block then executes and prints 4. Lastly, control is\nreturned to the main() method without an exception being thrown, and 5 is\nprinted. Since 245 is printed, option D is the correct answer."
      }
    },
    "30": {
      "nbr": 30,
      "value": "What is the output of this code?\n10: var m = new TreeMap<Integer, Integer>();\n11: m.put(1, 4);\n12: m.put(2, 8);\n13:\n14: m.putIfAbsent(2, 10);\n15: m.putIfAbsent(3, 9);\n16:\n17: m.replaceAll((k, v) -> k + 1);\n18:\n19: m.entrySet().stream()\n20: .sorted(Comparator.comparing(Entry::getKey))\n21: .limit(1)\n22: .map(Entry::getValue)\n23: .forEach(System.out::println);",
      "responses": [{
        "code": "A",
        "value": "1"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "3"
      }, {
        "code": "D",
        "value": "4"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "The code compiles but prints something else."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "30. B. Lines 10–12 created a map with two key/value pairs. Line 14 does not\nadd to the map, since the key 2 is present. Line 15 adds a third key/value to\nthe map. At this point, the map contains {1=4, 2=8, 3=9}. Line 17\nreplaces the values with one higher than the key, and the map contains\n{1=2, 2=3, 3=4}. The stream on lines 19–23 goes through the map and\nsorts ascendingly by key. It gets the lowest key from that sort, which is 1.\nThen it prints the value that goes with that key, which is 2. This makes\noption B the answer."
      }
    },
    "31": {
      "nbr": 31,
      "value": "Which can fill in the blank so this code outputs true?\nimport java.util.function.*;\nimport java.util.stream.*;\npublic class HideAndSeek {\npublic static void main(String[] args) {\nvar hide = Stream.of(true, false, true);\nPredicate<Boolean> pred = b -> b;\nvar found = hide.filter(pred).________(pred);\nSystem.out.println(found);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Only anyMatch"
      }, {
        "code": "B",
        "value": "Only allMatch"
      }, {
        "code": "C",
        "value": "Both anyMatch and allMatch"
      }, {
        "code": "D",
        "value": "Only noneMatch"
      }, {
        "code": "E",
        "value": "The code does not compile with any of these options."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "31. C. The filter() method passes two of the three elements of the stream\nthrough to the terminal operation. This is redundant, since the terminal\noperation checks the same Predicate. There are two matches with the same\nvalue, so both anyMatch() and allMatch() return true, and option C is\ncorrect."
      }
    },
    "32": {
      "nbr": 32,
      "value": "_______________ modules are on the classpath, while ____________\nmodules never contain a module‐info file.",
      "responses": [{
        "code": "A",
        "value": "Automatic, named"
      }, {
        "code": "B",
        "value": "Automatic, unnamed"
      }, {
        "code": "C",
        "value": "Named, automatic"
      }, {
        "code": "D",
        "value": "Named, unnamed"
      }, {
        "code": "E",
        "value": "Unnamed, automatic"
      }, {
        "code": "F",
        "value": "Unnamed, named"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "32. E. Unnamed modules are always on the classpath. Both automatic and\nnamed modules are on the module path. Named modules always contain a\nmodule‐info file, but automatic modules never do. Option E is correct as it\nmeets both these criteria."
      }
    },
    "33": {
      "nbr": 33,
      "value": "Given the following class, how many lines contain compilation errors?\n1: import java.io.*;\n2: class StungException extends Exception {}\n3: class Suit implements Closeable {\n4: public void close() throws IOException {}\n5: }\n6: public class BeeCatcher {\n7: public static void main(String[] b) throws\nIOException {\n8: var s = new Suit();\n9: var t = new Suit();\n10: try (s; t) {\n11: throw new StungException();\n12: } catch (StungException | Exception e) {\n13: s = null;\n14: } finally {\n15: }\n16: }\n17: }",
      "responses": [{
        "code": "A",
        "value": "One"
      }, {
        "code": "B",
        "value": "Two"
      }, {
        "code": "C",
        "value": "Three"
      }, {
        "code": "D",
        "value": "Four"
      }, {
        "code": "E",
        "value": "None. The code compiles as is."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "33. B. The code does not compile, so option E is incorrect. A variable\ndeclared before the start of a try‐with‐resources statement may be used if it\nis final or effectively final. Since s is modified on line 13, it is not either,\ntherefore line 10 does not compile. Line 12 also does not compile. In a\nmulti‐catch expression, the two classes cannot be subtypes of each other.\nOther than lines 10 and 12, the rest of the code compiles, making option B\ncorrect."
      }
    },
    "34": {
      "nbr": 34,
      "value": "What is the output of the Light program?\npackage physics;\nclass Wave {\npublic int size = 7;\n}\npublic class Light extends Wave {\npublic int size = 5;\npublic static void main(String… emc2) {\nLight v1 = new Light();\nvar v2 = new Light();\nWave v3 = new Light();\nSystem.out.println(v1.size +\",\"+ v2.size +\",\"+\nv3.size);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "5,5,5"
      }, {
        "code": "B",
        "value": "5,5,7"
      }, {
        "code": "C",
        "value": "5,7,7"
      }, {
        "code": "D",
        "value": "7,7,7"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "34. B. When replacing a variable in a subclass, Java uses the reference type to\ndetermine the variable to use. Option A would be correct if the size\nvariables were treated like method overriding, since all of the objects in the\nmain() method are instances of Light. Instead, the reference type is used.\nThe variables v1 and v2 are of reference type Light, so 5 is selected.\nLikewise, the variable v3 is of type Wave, so 7 is used. The output is 5,5,7,\nmaking option B correct."
      }
    },
    "35": {
      "nbr": 35,
      "value": "How many of the following could be valid JDBC URL formats for an\nimaginary driver named magic and a database named box?\nString first = \"jdbc;box;magic\";\nString second = \"jdbc;magic;@127.0.0.1:1234\";\nString third = \"jdbc;magic;127.0.0.1:1234/box\";",
      "responses": [{
        "code": "A",
        "value": "Only first"
      }, {
        "code": "B",
        "value": "Only second"
      }, {
        "code": "C",
        "value": "Only third"
      }, {
        "code": "D",
        "value": "first and second"
      }, {
        "code": "E",
        "value": "first and third"
      }, {
        "code": "F",
        "value": "None of these"
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "35. F. A JDBC URL has three components separated by colons. None of these\noptions uses the correct colon delimiter, making option F the correct\nanswer."
      }
    },
    "36": {
      "nbr": 36,
      "value": "Which of the following statements about interface methods are correct?\n(Choose three.)",
      "responses": [{
        "code": "A",
        "value": "A private static interface method can call default methods."
      }, {
        "code": "B",
        "value": "A public static interface method can call abstract methods."
      }, {
        "code": "C",
        "value": "A private static interface method can call static methods."
      }, {
        "code": "D",
        "value": "A default interface method can call private static methods."
      }, {
        "code": "E",
        "value": "A default interface method can call abstract methods."
      }, {
        "code": "F",
        "value": "A public static interface method can call default methods."
      }
      ],
      "answer": {
        "codes": [
          "C",
          "D",
          "E"
        ],
        "explanation": "36. C,D,E. A static interface method can only call other static interface\nmethods, private or public, making option C correct. They cannot call\ndefault or abstract methods, making options A, B, and F incorrect. On\nthe other hand, a default interface method can call all instance‐based\nmethods (abstract, default) and all static methods, making option D\nand E correct."
      }
    },
    "37": {
      "nbr": 37,
      "value": "Which of the following are true right before the main() method ends?\n(Choose two.)\npublic static void main(String[] args) {\nString state1 = new String(\"ice\");\nString state2 = new String(\"water\");\nString state3 = new String(\"mist\");\nstate1 = state2;\nstate2 = state3;\nstate3 = state1;\n}",
      "responses": [{
        "code": "A",
        "value": "No objects are eligible for garbage collection."
      }, {
        "code": "B",
        "value": "One object is eligible for garbage collection."
      }, {
        "code": "C",
        "value": "Two objects are eligible for garbage collection."
      }, {
        "code": "D",
        "value": "No objects are guaranteed to be garbage collected."
      }, {
        "code": "E",
        "value": "One object is guaranteed to be garbage collected."
      }, {
        "code": "F",
        "value": "Two objects are guaranteed to be garbage collected."
      }
      ],
      "answer": {
        "codes": [
          "B",
          "D"
        ],
        "explanation": "37. B,D. At the end of the method, state1 and state3 both point to \"water\",\nwhile state2 points to \"mist\". Since there are no references to \"ice\", it is\neligible for garbage collection, making option B correct. However, garbage\ncollection is not guaranteed to run, so option D is also correct."
      }
    },
    "38": {
      "nbr": 38,
      "value": "Which of the following can fill in the blank to output sea lion, bald\neagle?\nString names = Stream.of(\n\"bald eagle\", \"pronghorn\", \"puma\", \"sea lion\")\n_____________________\n.collect(Collectors.joining(\", \"));\nSystem.out.println(names);",
      "responses": [{
        "code": "A",
        "value": ".filter(s -> s.contains(\" \"))\n.collect(Collectors.toSet())\n.stream()\n.entrySet()\n.stream()\n.filter(e -> e.getKey())\n.map(Entry::getValue)\n.flatMap(List::stream)\n.sorted(Comparator.reverseOrder())"
      }, {
        "code": "B",
        "value": ".filter(s -> s.contains(\" \"))\n.collect(Collectors.toUnmodifiableSet())\n.stream()\n.entrySet()\n.stream()\n.filter(e -> e.getKey())\n.map(Entry::getValue)\n.flatMap(List::stream)\n.sorted(Comparator.reverseOrder())"
      }, {
        "code": "C",
        "value": ".collect(Collectors.toUnmodifiableSet())\n.stream()\n.collect(Collectors.groupingBy(s -> s.contains(\" \")))\n.entrySet()\n.stream()\n.filter(e -> e.getKey())\n.map(Entry::getValue)\n.map(List::stream)\n.sorted(Comparator.reverseOrder())"
      }, {
        "code": "D",
        "value": ".collect(Collectors.toSet())\n.stream()\n.collect(Collectors.groupingBy(s -> s.contains(\" \")))\n.entrySet()\n.stream()\n.filter(e -> e.getKey())\n.map(Entry::getValue)\n.flatMap(List::stream)\n.sorted(Comparator.reverseOrder())"
      }, {
        "code": "E",
        "value": ".filter(s -> s.contains(\" \"))\n.collect(Collectors.toUnmodifiableSet())\n.stream()\n.collect(Collectors.groupingBy(s -> s.contains(\" \")))\n.entrySet()\n.stream()\n.filter(e -> e.getKey())\n.map(Entry::getValue)\n.map(List::stream)\n.sorted(Comparator.reverseOrder())"
      }, {
        "code": "F",
        "value": ".collect(Collectors.toUnmodifiableSet())\n.stream()\n.collect(Collectors.groupingBy(s -> s.contains(\" \")))\n.entrySet()\n.stream()\n.filter(e -> e.getKey())\n.map(Entry::getValue)\n.map(List::stream)\n.sorted(Comparator.reverseOrder())"
      }
      ],
      "answer": {
        "codes": [
          "D"
        ],
        "explanation": "38. D. In options A and B, the stream pipeline attempts to call entrySet() on\nthe stream. However this method is only defined on Map, which makes these\ntwo options incorrect. Options C, E, and F are incorrect because the second\nto last line is map() instead of flatMap(). It doesn't make sense to sort the\nStream generated by map(), and the code does not compile. By contrast,\noption D is correct. It creates a Set of matching String objects. It then\nbuilds a map where the key represents whether they match. Next, the code\ngets the list of all matching values, turns it into a Stream and uses\nflatMap() to turn it back into individual objects. Finally, the code sorts in\ndescending order and turns the result back into a String."
      }
    },
    "39": {
      "nbr": 39,
      "value": "What is the minimum number of lines that need to be removed to make this\ncode compile and be able to implemented as a lambda expression?\n@FunctionalInterface\npublic interface Play {\npublic static void baseball() {}\nprivate static void soccer() {}\ndefault void play() {}\nvoid fun();\nvoid game();\nvoid toy();\n}",
      "responses": [{
        "code": "A",
        "value": "1"
      }, {
        "code": "B",
        "value": "2"
      }, {
        "code": "C",
        "value": "3"
      }, {
        "code": "D",
        "value": "4"
      }, {
        "code": "E",
        "value": "The code compiles as is."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "39. B. This code is not a functional interface because it has three abstract\nmethods: fun(), and game(), and toy(). Removing two of these three\nmethods would cause the code to compile leaving it with a single abstract\nmethod. Note that removing the @FunctionalInterface annotation would\nallow the interface to compile, but not be implementable as a lambda\nexpression."
      }
    },
    "40": {
      "nbr": 40,
      "value": "Which message does the following application print?\npackage ranch;\npublic class Cowboy {\nprivate int space = 5;\nprivate double ship = space < 2 ? 3L : 10.0f; // g1\npublic void printMessage() {\nif(ship>1) {\nSystem.out.print(\"Goodbye!\");\n} if(ship<10 && space>=2) // g2\nSystem.out.print(\"Hello!\");\nelse System.out.print(\"See you again!\");\n}\npublic static final void main(String… stars) {\nnew Cowboy().printMessage();\n}\n}",
      "responses": [{
        "code": "A",
        "value": "Hello!"
      }, {
        "code": "B",
        "value": "Goodbye!"
      }, {
        "code": "C",
        "value": "See you again!"
      }, {
        "code": "D",
        "value": "It does not compile because of line g1."
      }, {
        "code": "E",
        "value": "It does not compile because of line g2."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "F"
        ],
        "explanation": "40. F. The code compiles without issue, making options D and E incorrect.\nApplying the ternary ? : operator, the variable ship is assigned a value of\n10.0. Both values are implicitly cast to double. The expression in the first\nif statement evaluates to true, so Goodbye is printed. Notice that there is\nno else statement on line g2; therefore, the second if statement is also\nexecuted, causing See you again to also be printed. Since two statements\nare printed, option F is correct."
      }
    },
    "41": {
      "nbr": 41,
      "value": "Which are included in the Java Platform Module System? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "A format for module JARs"
      }, {
        "code": "B",
        "value": "A list of all possible modules for Java"
      }, {
        "code": "C",
        "value": "A new file format called jdeps"
      }, {
        "code": "D",
        "value": "Additional command‐line options for Java tools"
      }, {
        "code": "E",
        "value": "Decommissioning of the jar format"
      }, {
        "code": "F",
        "value": "Partitioning of the JDK into modules"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "F"
        ],
        "explanation": "41. A,D,F. The module system consists of a format for module jars, not a\nreplacement making option A correct and option E incorrect. It also divides\nthe JDK into modules, making option F correct. Since many modules are\nnot part of the JDK, it cannot provide a complete list as suggested by option\nB. Modules can continue to use jar format or alternatively, use the JMOD\nformat. Option C is tricky because jdeps was added. However, it is a\ncommand, not a file format. This does make option D correct."
      }
    },
    "42": {
      "nbr": 42,
      "value": "Given the following two classes in the same package, which constructors\ncontain compiler errors? (Choose three.)\npublic class Big {\npublic Big(boolean stillIn) {\nsuper();\n}\n}\npublic class Trouble extends Big {\npublic Trouble() {}\npublic Trouble(int deep) {\nsuper(false);\nthis();\n}\npublic Trouble(String now, int… deep) {\nthis(3);\n}\npublic Trouble(long deep) {\nthis(\"check\",deep);\n}\npublic Trouble(double test) {\nsuper(test>5 ? true : false);\n}\n}",
      "responses": [{
        "code": "A",
        "value": "public Big(boolean stillIn)"
      }, {
        "code": "B",
        "value": "public Trouble()"
      }, {
        "code": "C",
        "value": "public Trouble(int deep)"
      }, {
        "code": "D",
        "value": "public Trouble(String now, int… deep)"
      }, {
        "code": "E",
        "value": "public Trouble(long deep)"
      }, {
        "code": "F",
        "value": "public Trouble(double test)"
      }
      ],
      "answer": {
        "codes": [
          "B",
          "C",
          "E"
        ],
        "explanation": "42. B,C,E. The constructors declared by options A, D, and F compile without\nissue. Option B does not compile. Since there is no call to a parent\nconstructor or constructor in the same class, the compiler inserts a noargument\nsuper() call as the first line of the constructor. Because Big does\nnot have a no‐argument constructor, the no‐argument constructor\nTrouble() does not compile. Option C also does not compile because\nsuper() and this() cannot be called in the same constructor. Finally,\noption E does not compile. There is no matching constructor that can take a\nString followed by a long value."
      }
    },
    "43": {
      "nbr": 43,
      "value": "Fill in the blanks: The name of the abstract method in the Function\ninterface is ______________, while the name of the abstract method in\nthe Consumer interface is ______________.",
      "responses": [{
        "code": "A",
        "value": "accept(), apply()"
      }, {
        "code": "B",
        "value": "accept(), get()"
      }, {
        "code": "C",
        "value": "apply(), accept()"
      }, {
        "code": "D",
        "value": "apply(), apply()"
      }, {
        "code": "E",
        "value": "apply(), test()"
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "43. C. The Function interface uses apply(), while the Consumer interface\nuses accept(), making option C the correct answer. For reference, get() is\nthe name of the method used by Supplier, while test() is the name of the\nmethod used by Predicate."
      }
    },
    "44": {
      "nbr": 44,
      "value": "How many lines fail to compile?\nclass Roller<E extends Wheel> {\npublic void roll(E e) { }\n}\nclass Wheel { }\nclass CartWheel extends Wheel { }\npublic class RollingContest {\nRoller<CartWheel> wheel1 = new Roller<CartWheel>();\nRoller<Wheel> wheel2 = new Roller<CartWheel>();\nRoller<? extends Wheel> wheel3 = new Roller<CartWheel>\n();\nRoller<? extends Wheel> wheel4 = new Roller<Wheel>();\nRoller<? super Wheel> wheel5 = new Roller<CartWheel>();\nRoller<? super Wheel> wheel6 = new Roller<Wheel>();\n}",
      "responses": [{
        "code": "A",
        "value": "One"
      }, {
        "code": "B",
        "value": "Two"
      }, {
        "code": "C",
        "value": "Three"
      }, {
        "code": "D",
        "value": "Four"
      }, {
        "code": "E",
        "value": "Five"
      }, {
        "code": "F",
        "value": "Six"
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "44. B. The Roller class uses a formal type parameter named E with a\nconstraint. The key to this question is knowing that with generics, the\nextends keyword means any subclass or the class can be used as the type\nparameter. This means both Wheel and CartWheel are allowed. The wheel1\ndeclaration is fine because the same type is used on both sides of the\ndeclaration. The wheel2 declaration does not compile because generics\nrequire the exact same type when not using wildcards. The wheel3 and\nwheel4 declarations are both fine because this time there is an upper bound\nto specify that the type can be a subclass. By contrast, the super keyword\nmeans it has to be that class or a superclass. The wheel6 declaration is OK,\nbut the wheel5 one is a problem because it uses a subclass. Since wheel2\nand wheel5 don't compile, the answer is option B."
      }
    },
    "45": {
      "nbr": 45,
      "value": "What is the output of the following program?\nvar bed = List.of((short)2,(short)5);\nvar pillow = bed.parallelStream().reduce(0,\n(a,b) -> b.doubleValue() + a.doubleValue(),\n(c,d) -> d.doubleValue() + c.doubleValue());\nSystem.out.println(pillow);",
      "responses": [{
        "code": "A",
        "value": "0"
      }, {
        "code": "B",
        "value": "0.0"
      }, {
        "code": "C",
        "value": "7"
      }, {
        "code": "D",
        "value": "7.0"
      }, {
        "code": "E",
        "value": "The code does not compile"
      }, {
        "code": "F",
        "value": "None of the above"
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "45. E. Since it's not a primitive stream, the underlying type is Stream<Short>,\nwhich means the data type of b is Short. On the other hand, the data type of\na, c, and d is Integer. Because Short and Integer both define a\ndoubleValue() method, these statements compile. The problem is with the\nreturn type of the two lambda expressions. The identity is set as 0, not 0.0,\nso the expected return type of each lambda expression is Integer, not\nDouble. For this reason, neither lambda expression matches the method\nparameters of the reduce() method, and option E is correct."
      }
    },
    "46": {
      "nbr": 46,
      "value": "Given the following three property files, what does the following method\noutput?\ntoothbrush.properties\ncolor=purple\ntype=generic\ntoothbrush_es.properties\ncolor=morado\ntype=lujoso\ntoothbrush_fr.properties\ncolor=violette\nvoid brush() {\nLocale.setDefault(new Locale.Builder()\n.setLanguage(\"es\")\n.setRegion(\"MX\").build());\nvar rb = ResourceBundle.getBundle(\"toothbrush\",\nnew Locale(\"fr\"));\nvar a = rb.getString(\"color\");\nvar b = rb.getString(\"type\");\nSystem.out.print(a + \" \" + b);\n}",
      "responses": [{
        "code": "A",
        "value": "morado null"
      }, {
        "code": "B",
        "value": "violette generic"
      }, {
        "code": "C",
        "value": "morado lujoso"
      }, {
        "code": "D",
        "value": "violette null"
      }, {
        "code": "E",
        "value": "The code does not compile."
      }, {
        "code": "F",
        "value": "An exception is thrown at runtime."
      }
      ],
      "answer": {
        "codes": [
          "B"
        ],
        "explanation": "46. B. Java starts out by looking for a properties file with the requested locale.\nIn this case, the requested locale is the fr language, which it finds with\ntoothbrush_fr.properties. For this reason, the default locale of es_MX is\nignored, and the first value for color printed is violette. Next, it looks for\na value for type property. Since it doesn't find it in the first properties file,\nit checks the default toothbrush.properties, where it does find it, and\nprints generic. For these reasons, option B is correct."
      }
    },
    "47": {
      "nbr": 47,
      "value": "Which of the following are valid functional interfaces in the\njava.util.function package? (Choose three.)",
      "responses": [{
        "code": "A",
        "value": "BooleanSupplier"
      }, {
        "code": "B",
        "value": "CharSupplier"
      }, {
        "code": "C",
        "value": "DoubleUnaryOperator"
      }, {
        "code": "D",
        "value": "ObjectIntConsumer"
      }, {
        "code": "E",
        "value": "ToLongBiFunction"
      }, {
        "code": "F",
        "value": "TriPredicate"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "C",
          "E"
        ],
        "explanation": "47. A,C,E. BooleanSupplier, DoubleUnaryOperator, and ToLongBiFunction\nare all valid functional interfaces in java.util.function, making options\nA, C, and E correct. Remember that BooleanSupplier is the only primitive\nfunctional interface in the API that does not use double, int, or long. For\nthis reason, option B is incorrect, since char is not a supported primitive.\nOption D is incorrect because the functional interfaces that use Object are\nabbreviated to Obj. The correct name for this functional interface is\nObjIntConsumer. That leaves option F, which is incorrect. There is no builtin\nPredicate interface that takes three values."
      }
    },
    "48": {
      "nbr": 48,
      "value": "What change, if any, should be made to the following method to improve\nsecurity?\n10: public List<String> accessNetworkList(String fileName)\n{\n11: return AccessController.doPrivileged(\n12: new PrivilegedAction<List<String>>() {\n13: public List<String> run() {\n14: try {\n15: return Collections.unmodifiableList(\n16: Files.readAllLines(Path.of(fileName)));\n17: } catch (IOException e) {\n18: throw new SecurityException(\"No access\");\n19: } } });\n20: }",
      "responses": [{
        "code": "A",
        "value": "On line 10, the method should be marked private."
      }, {
        "code": "B",
        "value": "On line 15, an ArrayList instance should be returned instead of an\nunmodifiable list."
      }, {
        "code": "C",
        "value": "Prior to line 16, the fileName should be validated against a list of\nconstants."
      }, {
        "code": "D",
        "value": "The exception on line 18 should be removed and an empty List\nshould be returned."
      }, {
        "code": "E",
        "value": "None of the above, as the code is safe as is."
      }
      ],
      "answer": {
        "codes": [
          "C"
        ],
        "explanation": "48. C. The method does not validate the input filename, which gives the user\ncarte blanche to access the entire file system. The input should be validated\nin some way. One option to validate the data would be to check it against a\nlist of known constants, making option C correct. The rest of the options do\nnot improve security."
      }
    },
    "49": {
      "nbr": 49,
      "value": "What is the result of executing the Clownfish program?\npackage ocean;\nclass BubbleException extends Exception {}\nabstract class Fish {\nFish getFish() {\nthrow new RuntimeException(\"fish!\");\n}\n}\npublic final class Clownfish extends Fish {\npublic final Clownfish getFish() throws BubbleException\n{\nthrow new RuntimeException(\"clown!\");\n}\npublic static void main(String[] bubbles) throws\nException {\nfinal var v = (Fish)new Clownfish();\nClownfish f = v;\nf.getFish();\nSystem.out.println(\"swim!\");\n}\n}",
      "responses": [{
        "code": "A",
        "value": "The code compiles and prints swim!"
      }, {
        "code": "B",
        "value": "The code compiles and prints fish!"
      }, {
        "code": "C",
        "value": "The code compiles and prints a stack trace."
      }, {
        "code": "D",
        "value": "One line of the program does not compile."
      }, {
        "code": "E",
        "value": "Two lines of the program do not compile."
      }, {
        "code": "F",
        "value": "None of the above."
      }
      ],
      "answer": {
        "codes": [
          "E"
        ],
        "explanation": "49. E. The Clownfish class contains an invalid override of the getFish()\nmethod. In particular, it cannot declare any new or broader checked\nexceptions. Next, there is an error in the main() method. Since v is a var, it\nis given a specific type based on the reference at compile time, in this case\nFish. Fish is a supertype of Clownfish, so it cannot be assigned to a\nClownfish reference without an explicit cast, resulting in a compiler error.\nSince the code contains two lines that do not compile, option E is correct."
      }
    },
    "50": {
      "nbr": 50,
      "value": "What statements about the following method are correct? (Choose three.)\npublic String findWaffles(String connectionStr, String\nsearch)\nthrows SQLException {\nvar query = \"SELECT * FROM meal WHERE type =\n'\"+search+\"'\";\nvar con = DriverManager.getConnection(connectionStr);\ntry (con;\nvar ps = con.prepareStatement(query);\nvar rs = ps.executeQuery()) {\nreturn rs.getString(\"name\");\n} }",
      "responses": [{
        "code": "A",
        "value": "It protects against a denial of service attack."
      }, {
        "code": "B",
        "value": "It does not protect against denial of service attacks."
      }, {
        "code": "C",
        "value": "It protects against SQL injection because it uses a\nPreparedStatement."
      }, {
        "code": "D",
        "value": "It does not protect against SQL injection."
      }, {
        "code": "E",
        "value": "Assuming the database and related table exist and are available, this\nmode is expected to run without any exceptions being thrown."
      }, {
        "code": "F",
        "value": "This method will always produce an exception at runtime.\n"
      }
      ],
      "answer": {
        "codes": [
          "A",
          "D",
          "F"
        ],
        "explanation": "50. A,D,F. This code uses try‐with‐resources to ensure all resources it creates\nare closed; therefore, it does protect from a denial of service attack, making\noption A correct. While it's preferable to declare the Connection inside the\ntry‐with‐resources statement, it is not required, so long as there are no\nmethods that can throw an exception between its declaration and the trywith‐\nresources statement.\nWhile this method uses a PreparedStatement, it does not bind the query\nparameter using setString(), so this code is at risk for SQL injection. For\nthis reason, option D is correct. Finally, this code will always produce an\nexception at runtime, even if the database and related table are available,\nbecause rs.next() is not called before rs.getString(). For this reason,\noption F is cor"
      }
    }
  }
}
]
